                                 java
								 

ultimate goal -> to become a software engineer

software engineer

  -> to develop the software
  -> to build the software
  -> to implement the application 
  
  
  what type of applications ?
  
    1.desktop application 
	2.interent based application 
	
what is the difference between in these two types of applications?

desktop or standalone applicatins results are not sharable across the globe

where as internet based applications results are sharable across the globe.

examples for desktop applications 
	
	calculator
	antivirus
	acroabatic reader... etc.. 
	
    facebook 
    gmail 
	flipkart
	amazon etc.. 
	
java was released in the year of 1995 
  java -popularity 
  so many tools came and then gone 
  
who is the author of java?
 
    james gosling
	
he released into three editions 

   1.jse(java standard edition ) -core java
   2.jee( java enterprise edition ) - advanced java 
   3.jme (java micro/mobile edition) -android -> mobile based application 
   
   
 using java software what type of applications we can develop?

    we can develop both standalone and distributed(internet/web based) applications

	using core java or jse we can develop only standalone applications 
	
	
    using advanced java or jee we can develop both desktop & interent applications
	
	
    to understand adv java, we should learn core java 
	
	 because on top of core java architecture adv java got implemented. 
	 
   
 
as a programmer we have to follow some rules while we are writing the program 

those rules are given by sunmicrosystem. 


those rules technically we can call it as -> syntaxes 

	
	what will happen if we are not following the syntaxes?
	
	  ->
	
as a programmer, after we wrote the program, we have to follow two steps 

    1. we have to compile the java program 
	2. we have to run/execute the java program 
	
why should i compile the program?

  to check whether programmer follows syntaxes correctly or not?

  java compiler 
    
     -> it is the predefined java program 

     responsibility -> to check the syntaxes 

     java compiler will give the errors if we do any syntactical mistakes.

	 
	 whenever you write the java program 
	 
	 1.save the java program (.java)
	 2.compile the java program 
	     java compiler will generate one -> .class file 
		 
		 .java -> whatever the code we are writing 
		 .class -> byte code 
		 
	byte code:

           this is not human readable code 
           jvm can read this code and convert this byte code into machine level 
		   code
		   
	 3.execute the java program -> to get the output
	 
	    who is the executing the java program 
		   jvm (java virtual machine)
		   
		   
requuirement is i want to write the java program?

 jdk is required 
 jdk -> java development kit 
 
 opensource
  
   you can download and install freely from the internet 
   official website is : 
   www.oracle.com 
   
   1995 -> sunmicrosystem
   
after installing jdk in our machines to cross check whether it gets installed 
or not 

open the command prompt and type the below command 

 cmd:/> java --version 
  java 21.0.2 2024-01-16 LTS
  Java(TM) SE Runtime Environment (build 21.0.2+13-LTS-58)
  Java HotSpot(TM) 64-Bit Server VM (build 21.0.2+13-LTS-58, mixed mode, sharing)

write the java program?

 
basic struture of the java program 

 java is case sensitive programming language
 
 
		   
	java progarm should always starts with by defining the class. 
	
	
	
	    class Techm
		{
		
		
		}
	  

whenever we compile the java program, based on the class name .class file will 
be generated which contains byte code that is not understable by human but can 
be read by jvm .


what is the command to compile the java program?

   javac <filename>.java

what is the command to execute/run the java program?

   java <classname>

to compile the java program, main method is not required. 
but to execute the java program, main method is mandatory 

without main() can we compile the program?
 yes
 
without main(),can we execute the program?

  no 
  
 because execution of the java program starts from main method only . 
 
who is executing the java program?
  jvm 
  
  internally jvm is calling main method , 
   
simple java program:


class Techm
{
		
	 public static void main(String[] args)
	 {
         System.out.println("welcome to techm java training");
	 }		 
}
	
	
path:
path is the location where all java related tools are available 

note:

by default java tools couldn't recognized by the operating system, to recognized
by the o.s. we have to set the path 

 to set the path we have to follow following steps
 
 1.click on the environment variables
 
 2.user variables seciton 
 
 3.select the path 
 
 4.click on the edition
 
 5.double click on that and paste the location 
 6.click on ok (3 times)
 
 
 exit the command prompt and re open the command prompt and try java 
 commands it starts to recognize 
 
 




why java is so popular?
   java features
   
   simple
   platform independent
   architectural neutral 
   networked
   dynamic
   mulithreaded
   object oriented
   robust
   distributed
   portable
   

simple:

   user friednly library
   garbage collector
   
   automatically reclaiming memory occupied by objects that 
   are no longer in use by the program. 
   
   prevent memory leaks 
   efficient memory management 


   object  


platform independent:
```````````````````````
 Techm.java 

    |
 
 Techm.class (windows)
 
 i copied this .class file and i gave to my friend(unix)
 
 
 but he wants to execute this .class file 
 
 
 can he?
 
    yes 
	
irrespective of any o.s we are using, we are allowed to run 

  java slogan -> wora 

  write once run/reuse anywhere.

 o.s -> o.s

 
object oriented:
``````````````````
  java is object oriented programming language
  
  why?
  
    because it follows the principles of OOP.
	
	 ->encapsulation 
	 ->inheritance
	 ->polymorphsim 
	 ->abstraction 
	 
	  oops principles are given -> OMG(object management group)
	  
	 
 python
 .net
 cpp
 object c...
 
 
how can we achieve these oops principles in java?
 answer: by using class and object
 
 
 class 
 object 
 
 using these two concepts we are achieving 4 oops principles.
 
 class:
 
  class is the collection of variables and methods 


object:
 object is the instance of the class. 
 
 instance:
    memory creation for variables and methods what we are declaring inside
	the class. 
	
	
note:
for a single class , we can create multiple obejcts based on the requirement. 


how can i define the class?

   syntax:
      
	     class <classname>
		 {
		    //variables
			//methods 
		 
		 }
		 
   ex:
   
      class Student
	  {
	     stid = 51; 
		
	  }

variable:
variable is a named storage location in the computers memory that holds 
a value. 

purpose: to store the data 
  data can be manipulated 
  and accessed within the program .
  
 syntax:
 
   <datatypename> <variablename> = <value>;
   
   ex:
     short stid = 51;
	 
   
integer 
   byte - 1 byte      - 8 bits
   short  - 2 bytes   - 16 bits
   int    - 4 bytes
   long   - 8 bytes
   
   
   range of the byte datatype:
   
   -2^n-1 to (2^n-1) -1
   
   n -> no.of bits
   
   
   -2^7 to 2^7 -1
   
   -128 to 127
   
   short b = 128;
   
   
   
   
   
   
float 
   float - 4
   double - 8
   
   to store decimal values 
   
   float f = 5.6;
  

by default any decimal type is double type 
 
length of the precision size for float type is upto 6 digits 
where as length of the precision size for double is upto 15 digits. 

 
character
   char-2 bytes 
   
     to store single character we will use this datatype. 
	 
	 char c = a;
	 
it should be enclosed with in the single quotes. 

    char c = 'a';
	
boolean 
   boolean -undefined 
   to store logical values either true or false
   
   boolean b = true;
   boolean c = false;
   
   
note:
every datatype is maintaining range and memory size
 
 based on the value we can decide what type of datatype we should use
 
 
note:
all the java reserved keywords must be in lowercase letters only .


method:

method is a place where we are writing the logic, to perform some operation 
based on the requirement.

syntax:

  [accessmodifier] <returntype> <methodname>([if any parameters])
  {
     //logic 
  }


if a method is not returning any value we should mention the return type 
as 'void'.


   void display()
   {
      //logic 
   }

if a method is returning a value, you should mention that return type 

  double getMarks()
  {
    return 98.5;
  }

return type and return value must be matched otherwise we will get compile time 
error. 


1.define the method which accepts firstname and surname and returns fullname?

        String getFullName(String firstname,String surname)
		{
		   return firstname+surname;
		}
        
		
		
		String fullName = getFullName("rama","krishna");
		
		System.out.println(fullName);//ramakrishna
		
		

2.define the method which displays sum of two numbers?

        void sum()
		{
		System.out.println(2+3);
		}
		




3.define the methods which returns his/her annual salary?


         double getAnnualSalary()
		 {
		 return 450000.00;
		 }
		 

4.define the method which accepts two integers and returns their product?

        int getProduct(int x, int y)
		{
		  return x*y;
		}
       

5.define the method which accepts radious as input and returns area of the circle?

      double getAreaOfCircle(int r)
	  {
	    return 3.14*r*r;
	  }


6.define the method which accepts your name and add Mr/Ms to your name based on 
  the gender and returns the full name?

     String getName("ram")
	 {
	   return "Mr" + "ram";
	 }
	 
  
  class is the collection of variables and methods 
  
  example:
  
   class Student
   {
     int stid = 100;
	 String stname="ram";
	 
	 //define one method to display the stid and stname
	 public void getStudentInfo()
	 {
	 System.out.println("student id is:" + stid);
	 System.out.println("student name is:" + stname);
	 }
  }

example:
class Student
   {
	   //variables 
     static int stid = 100;
	 static String stname="ram";
	 
	 //define one method to display the stid and stname- user defined method
	 //our own logic or business logic
	 public static void getStudentInfo()
	 {
	 System.out.println("student id is:" + stid);
	 System.out.println("student name is:" + stname);
	 }
	 
	 //main method 
	 
	 public static void main(String[] args)
	 {
		 //call this method 
		 getStudentInfo();
		 
	 }
	 
  }


note:
while we are storing character values , what is the rule?

  it should be enclosed with in single quotes.
  
  ex:   char c = 'a';
        
requirement:
i want to store series of characters then we should use String as the 
datatype

what is the rule?
 it should be enclosed with in double quotes.
 

  ex:   String s = "rama";
  

camelcase notataion or naming convention or hungarian notation?

 class/interface:
 
  everyword first letter should be capitalized.
  
   class Bicycle
   {
   }

   interface MountainBicycle
   {
   }
   
methods:
 if it is a single word, first letter should be lower case 
 
 if a method name contains multiple words, first letter should be in lower case
 and remaining words first letters should be in upper case.
 
 
     void sum(){}
	 int getAge(){return 2;}
	 void getEmployeeInformation(){}
 


note:
in java to declare the constants, we must use one keyword i.e final 

constants values will not be changed, even we try to change we will get 
compile time error. 

     final double PI=3.14;
	 
     final float POSITIVE_INFINITY = 1.0f / 0.0f;
     final float NEGATIVE_INFINITY = -1.0f / 0.0f;


note:
execution of the java program should starts from main() method .


object:
object is an instance of the class. 

instance: 

  memory allocation 
  
    variables 
	
syntax to create the object:

  <classname> <objectname> = new <classname>();
  
  Student obj = new Student();
  
  
  
example:
`````````
//class definition 
class Student
{
	   //variable declaration 
	   int stid=100;
	   String stname="ram";
	   //methods definition - to keep the logic
	   
	   public void getStudentInfo()
	   {
		   //display the student information 
		   System.out.println("student id:" + stid);
		   System.out.println("student name:" + stname);
	   }
	   
	   public static void main(String[] args)
	   {
		   
		   //create the object 
		   Student obj = new Student();
		   
		   //call the method using object name 
		   obj.getStudentInfo();
		   
		   
		   
	   }
	  	 
}


example:
`````````
//class definition 
class Student
{
	   //variable declaration 
	   static int stid=100;
	   
	   public static void main(String[] args)
	   {
		   
		  System.out.println("student id is: " + stid);
		   
	   }
	  	 
}



note:
for static properites memory will be created at the time of class loading 
into main memory(RAM)
  ->CLASS LOADER SUBSYSTEM 
      WHICH IS THE SUBPART OF JVM 
	  
When should i go for declaring the properties as static?

  
   college

      1000 students 

                     common property -> collegename 
					 
          anjali       sameera       philip    
          id,name      id,name       id,name 

		  
memory single time creation 
 
  -> we should declare that property as static.
  
  static properties memory creation is happening for single time only 
  where as non static properties memory creation is happening for multiple 
  times whenever we create the object. 
  
  
  object : 
  instance of class
  instance: memory creation for non-static properties
  
  
//class definition 
class Student
{
	   //non-static variables
	  int stid=100;
	  String stname="rama";
	  
	  //static variables 
	  static String collegeName="techm";
	  
	  //instance or non-static method
	  public void display()
	  {
		//non-static area or instance area 
		
		System.out.println("student id is:" + stid);
		System.out.println("student name is: "+ stname);
		System.out.println("college name is:" + collegeName);//direct access
		System.out.println("college name is:" + Student.collegeName);//using cn
		
		
	  }
	  
	   
	   public static void main(String[] args)
	   {
		   //static area
		 
		   //create the object 
		   Student obj = new Student();
		   System.out.println("student id is: " + obj.stid);
		   System.out.println("student name is: " + obj.stname);
		   System.out.println("college name is:" + collegeName);
		   System.out.println("college name is:" + Student.collegeName);
		   
		   //using object 
		   System.out.println("==================================");
		   obj.display();
		   
	   }
	  	 
}


object:
``````
instance of a class

instance: memory creation for instance properties 


syntax 

    <classname> <objectname> = new <classname>();
	
	
	Student obj = new Student();
	

eclipse ide(integrated development environment)->apache software foundaion 
open source 
 

  intellijide 
  netbeans
  myeclipse 
  
  how to download and install the eclipse ide in your machine(s):
  `````````````````````````````````````````````````````````````````
  https://www.eclipse.org/downloads/download.php?file=/oomph/epp/2024-03/R/eclipse-inst-jre-win64.exe
  
  
note:
the code which we are writing inside the ide is getting compiled automatically 
so that's why we have to run this code directly to get the output.

constructor:
constructor is a special member method which is used to initialize the 
object. 

for every datatype we have default values

for integer category default value is 0

for float category default value is 0.0

for string default value is null 
for character category default value is single space

for boolean datatype default value is false


without constructor example:
````````````````````````````

public class Employee {

	// variables declaration 
	int empid;
	String empname;
	double empsal;

	// user defined method 
	public void setValues()
	{
		//initialization logic
		empid=100;
		empname="Ram";
		empsal=8765.8;
	}

	// instance method
	public void getEmpInfo() {

		System.out.println("employee id is: " + empid);
		System.out.println("employee name is:" + empname);
		System.out.println("employee salary is:" + empsal);
	}

	public static void main(String[] args) {

		// static area
		// object creation
		Employee obj = new Employee();
		obj.setValues();
		obj.getEmpInfo();

	}

}

rules to define the constructor:
``````````````````````````````````

constructor name must be similar to class name
constructor should not return anything even void also.
constructor should not be static 
constructor should not be inherited.


note:
constructor will be invoked when you create the object, 
if we create the object for many times, corresponding constructor gets invoked 
many times. 


example with constructor:
```````````````````````````

public class Employee {

	// variables declaration 
	int empid;
	String empname;
	double empsal;

	public Employee()
	{
		//initialization logic
		empid=100;
		empname="ram";
		empsal=5687.5;
	}

	// instance method
	public void getEmpInfo() {

		System.out.println("employee id is: " + empid);
		System.out.println("employee name is:" + empname);
		System.out.println("employee salary is:" + empsal);
	}

	public static void main(String[] args) {

		// static area
		// object creation
		Employee obj = new Employee();
		Employee obj1 = new Employee();
		
		obj.getEmpInfo();
		

	}

}

types of constructor:
``````````````````````
1.default constructor 
    system defined default constructor 
	user defined default constructor 
	
	
  it is a constructor which doesn't takes any parameters 
  
    public Employee()
	{
	}
2.parameterized constructor 
  it is a constructor which takes parameters
  
     public Employee(.....)
	 {
	 }

note:
in my class, if i am not defining any constructor still compiler can generate
one constructor for us to assign default values
that constructor is known as system defined default constructor 

in case of paramerized constructor , while we are creating the object only 
values will be initalized.

in case of default constructor, first default values will be initalzied and then 
our own values will be replaced. 


default constructor we can define only once 
where as paramerized constructor we can define as many as you want.



public class Employee {

	// variables declaration 
	int empid;
	String empname;
	double empsal;
	
	//parameterized constructor
	public Employee(int x, String y, double z)
	{
		empid=x;
		empname=y;
		empsal=z;
	}
	

	//default constructor 
	public Employee()
	{
		System.out.println("default constructor");
	}	//default constructor 
	
	
	// instance method
	public void getEmpInfo() {

		System.out.println("employee id is: " + empid);
		System.out.println("employee name is:" + empname);
		System.out.println("employee salary is:" + empsal);
	}

	public static void main(String[] args) {

		// static area
		// object creation using parameters
		Employee obj = new Employee(100,"ram",7865.5);
		
		
		//object creation using default constructor 
		Employee obj1 = new Employee();
		
		
		obj.getEmpInfo();
		

	}

}


example on parameterized constructor:
`````````````````````````````````````

public class Employee {

	// variables declaration 
	int empid;
	String empname;
	double empsal;
	
	//parameterized constructor
	public Employee(int x, String y, double z)
	{
		empid=x;
		empname=y;
		empsal=z;
	}
	

	//default constructor 
	public Employee()
	{
		System.out.println("default constructor");
	}	//default constructor 
	
	
	// instance method
	public void getEmpInfo() {

		System.out.println("employee id is: " + empid);
		System.out.println("employee name is:" + empname);
		System.out.println("employee salary is:" + empsal);
	}

	public static void main(String[] args) {

		// static area
		// object creation using parameters
		Employee obj = new Employee(100,"ram",7865.5);
		
		
		//object creation using default constructor 
		Employee obj1 = new Employee();
		
		
		obj.getEmpInfo();
		

	}

}


in a single class, how many constructor(s) we can define?

  ->we can define multiple constructor(s) based on the requirement.
  
  
note:
in a single class, we can define default constructor only once, but we can 
define multiple parameterized constructors by changing the parameters 

note:
object name always must be unique.
this keyword:
````````````
this is the java reserved keyword which is pointing to current class 
object always. 


1.whenever we define the class level variables and method level parameters are 
same to differentiate those we are using this keyword before class level variables 

2.to call the current class constructors from other constructors 

  this() -> to call current class default constructor 
  this(..) -> to call current class parametrized constructor.
  
  



example-1:
```````````

public class Student {
	
	//variables 
	int stid;
	String stname;
	
	//parameterized constructor
	public Student(int stid, String stname)
	{
		this.stid=stid;
		this.stname=stname;
	}
	
	public void getStudentInfo()
	{
		System.out.println("student id is:" + this.stid);
		System.out.println("student name is: " + this.stname);
	}
	public static void main(String[] args) {
		
		//create the object using parameterized constructor 
		Student obj = new Student(100,"rama");
		
		//call the method 
		obj.getStudentInfo();
	}
	
	

}

example-2:
`````````


public class Student {
	
	//variables 
	int stid;
	String stname;
	
	//default constructor
	public Student()
	{
		//call current class three parameterized constructor 
		this(100,200,300);
		//initialization logic
		stid=200;
		stname="kushwanth";
		//call getStudentInfo()
		
		this.getStudentInfo();
	}
	
	//current class double parameterized constructor
	public Student(int stid, String stname)
	{
		//call the current class default constructor 
		this();
		//initialization logic
		this.stid=stid;
		this.stname=stname;
		
		//call getStudentInfo
		
		this.getStudentInfo();
	}
	
	//three parameterized constructor 
	public Student(int x, int y, int z)
	{
		System.out.println("three parameterized constructor");
	}
	
	public void getStudentInfo()
	{
		System.out.println("student id is:" + this.stid);
		System.out.println("student name is: " + this.stname);
	}
	public static void main(String[] args) {
		
		//create the object using parameterized constructor 
		Student obj = new Student(100,"rama");
		
	}
	
	

}


note:
constructor calling is from top to bottom whereas execution is from 
bottom to top. 

note:
constructor calling is always must be the first  statement  inside the constructor otherwise we will get compile time error.

 

java is object oriented programming language

  because it follows oops principles.
  
  1.inheritance
  2.polymorphsim
  3.abstraction
  4.encapsulation 
  

  -> class & object 
  
inheritance(is-a relation)
```````````````````````````
 inheritance is the process of taking the properties from one class 
 to another class. 
 
the class which is giving the properties is known as 
parent class / super class / base class 

the class which is taking the properties is known as 
child class / sub class / derived class. 

syntax:

 class <childclassname> extends <parentclassname>
 {
 
 }
 
 
note:
extends is the java reserved keyword using this we can achieve is-a relation 
between two classes. 

example:
`````````
//child class 
 class B extends A
 {
 }
 
note:
when we create the object for child class, memory locations will be created 
for both parent class and child class properties 
that is why using child class object, we can access both parent class 
and child class properties. 


example:
``````

//Parent class cum business logic class 
public class A {

	// business logic method - instance method
	public void sum(int x, int y) {
		System.out.println("sum is : " + (x + y));
	}

	
}

B.java:
`````````


//child class cum business logic class cum execution logic class
public class B extends A{

	//child class property
	public void sub(int x, int y)
	{
		System.out.println("substraction is: " + (x-y));
	}
	
	public static void main(String[] args) {
		
		B obj = new B();
		obj.sum(5, 6);
		obj.sub(6, 5);
		
		
	}
	
}

inheritance advantages:

1.reusability
2.memory consumption will be reduced
3.performance gets increased.


polymorphsim:
``````````````
poly -> many

morph -> forms 

 ->many forms 
 
 
kushwanth -> one object -> student object 

  |
    son object 
	
	|
bank -> customer object 


Bank 
  ->rateOfInterest()
   
 icici customer -> icicibankrateofinterest
 sbi customer -> sbibankrateofinterest
 pnb customer ->pnbbankrateofinterest
 
 
->method overloading 
->method overriding 

method overloading:

method overloading 

  -method name is same 
  -but parameters are different 
  

  void sum(int x, int y)
  {
   System.out.println(x+y);
  }
    -->integer sum 
	
  void sum(double x, double y)
  {
    System.out.println(x+y);
  }
    -->double sum 
	
  void sum(double x, double y, double z)
  {
  }
	
	
  void display(int x, String y)
  {
  }
  void display(String x, int y)
  {
  }
  
	by changing type of parameters 
	by changing no.of parameters 
	by changing order of parameters 
	

advantage of method overloading?

  
   1.Readability
   
   2.Compiletime polymorphsim 
   
   
example:
``````````

public class Test1 {
	
	void sum(int x, int y)
	{
		System.out.println("integer sum is:" +(x+y));
	}
	
	void sum(double x, double y)
	{
		System.out.println("double sum is:" + (x+y));
	}
	public static void main(String[] args) {
		
		Test1 obj=new Test1(); 
		
		
		obj.sum(3, 4);
		obj.sum(4.5,6.6);
	}

}

method overriding:
`````````````````````
 method name is same 
 but logic is differnt from parent class to child class. 
 
 parent class 
   method(){
      //logic1 
   }
 
 child class 
   method(){
     //logic2
   }
 
advantage:
```````````
1.polymorphism
2.code reusability
3.flexibility
4.encapsulation 
5.runtime polymorphism or dynamic binding 


A.java:
```````

//Parent class cum business logic class 
public class A {

	// business logic method - instance method
	public void sum(int x, int y) {
		System.out.println("addition is : " + (x + y));
	}

	
}

B.java:
```````

//child class cum business logic class 
public class B extends A{

	//method overriding
	public void sum(int x, int y)
	{
		System.out.println("substraction is: " + (x-y));
	}
	
}

C.java
```````

//execution logic class
public class C {

	public static void main(String[] args) {
		
	   //runtime polymorphism or dynamic binding
		A obj3 = new B();
		obj3.sum(5, 6);
		
	}
}



note:
in case of method overriding, based on the object type method binding will be 
happening 
that's why using method overriding we are allowed to achieve runtime polymorphism.

  
encapsulation:
`````````````
encapsulation is the process of binding data members and methods into a single unit. 

class is the best example for an encapsulation.

it controls access to the data.
it allows to access and modify the data through well defined methods.

data integrity and security.


every class is not an encapsulated class. 
if we want to make an encapsulated class, it has to follow or maintain some 
rules. 

1.we should declare private variables 
2.we should define public setter and getter methods for each and every 
variable which we are declaring inside the class. 


purpose of setter method:

  to set the data or to modify the data 
  
purpose of getter method:

  to get the data or to access the data. 
  
  

Customer.java:
``````````````

//encapsulated class 
public class Customer {
	
	//private variables
	private int customerId;
	private String customerName;
	
	
	//public setter method for customerId variable
	
	public void setCustomerId(int customerId)
	{
		this.customerId=customerId;
	}
	
	//public getter method for customerId variable
	 
	public int getCustomerId()
	{
		return customerId;
	}
	
	//public setter method for customerName
	public void setCustomerName(String customerName)
	{
		this.customerName=customerName;
	}
	
	//public getter method for customerName
	
	public String getCustomerName()
	{
		return customerName;
	}
	
}

Test2.java:
```````````
//execution logic class
public class Test2 {

	public static void main(String[] args) {

		Customer obj = new Customer();

		obj.setCustomerId(100);
		obj.setCustomerName("rama");
		
		System.out.println("customer id is: " + obj.getCustomerId());
		System.out.println("customer name is: " + obj.getCustomerName());
	}
}


BankAccount.java:
```````````````

public class BankAccount {
	
	private String accountNumber;
	private double balance;
	
	//Parameterized constructor
	public BankAccount(String accountNumber,double balance)
	{
		//initialization logic
		this.accountNumber=accountNumber;
		this.balance=balance;
	}

	//getter method for account number
	public String getAccountNumber() {
		return accountNumber;
	}

	
    //getter method for balance
	public double getBalance() {
		return balance;
	}

	
	//method to deposit money into the account
	
	public void deposit(double amount)
	{
		balance = balance + amount;
	}
	
	//method to withdraw money from the account 
	
	public void withdraw(double amount)
	{
		if(amount <= balance) {
			balance -= amount;
		}
		else {
			System.out.println("insufficient funds");
		}
	}
	

}




abstraction:
``````````````

it is the process of hiding implementatin details and providing services. 

it is hiding the logic and providing the services to an end user. 



->using two concepts 

 1.abstract class (0 to 100%)
 2.interface (100% security)



  advantage of abstraction is getting security .
   
   
abstract class:
`````````````````
abstract class Test1{
 
   void m1(){
      //body-logic 
   }
   void m2(){
     //body-logic 
   }
   
   //undefined method or unimplemented method or abstract method
   abstract void m3();//method heading ->method declaration 
}


q: can we create an object for an abstract class?

   no 
   since it contains abstract method(s).
   
q:for a single abstract class, how many implementation classe(s) we can define?
   as many as we want based on the requirement 



if a class contains atleast one abstract method corresponding class is known 
as abstract class. 

abstract is the java reserved keyword which is used to declare a method 
or class as an abstract . 

Test3.java:
````````````

//unimplemented class or abstract class or undefined class or parent class 
public abstract class Test3 {
	
	//undefined method or abstract method
	public abstract void sum(int x, int y);

}

Test4.java
```````````


//implementation class cum child class cum business logic classs
public class Test4 extends Test3{

	@Override
	public void sum(int x, int y) {
		System.out.println("addition  is : " + (x+y));
		
	}

}

Test5.java:
``````````

//implementation class 
public class Test5 extends Test3 {

	@Override
	public void sum(int x, int y) {
		System.out.println("substraction is: " + (x-y));
	}

}

AbstractDemo.java:
`````````````````
//execution logic class
public class AbstractDemo {

	public static void main(String[] args) {

		
		//runtime polymorphism or dynamic binding
		Test3 obj = new Test4();
		obj.sum(4, 5);
	}
}


interface:
```````````
interface means it contains only abstract methods.

  undefined methods
  

syntax:
 
    interface <interfacename>
	{
	    //abstract methods 
		//constants
	}

note:
by default interface variables are public static final 
by default interface methods are public abstract 
explicitly we no need to add these keywords like in abstract class. 


i1.java:
`````````

//parent interface
public interface i1 {
	
	void sum(int x, int y);

}

Test6.java:
`````````````

//implementation class cum child class 
public class Test6 implements i1{

	@Override
	public void sum(int x, int y) {
		
		System.out.println("addition is: " + (x+y));
		
	}

}

Test7.java:
````````````
//implementation class 
public class Test7 implements i1 {

	@Override
	public void sum(int x, int y) {
		System.out.println("substraction is: " + (x-y));
		
	}

	
}

Test8.java:
`````````````

public class Test8 {

	public static void main(String[] args) {
		
		i1 obj = new Test7();
		obj.sum(4, 5);
	}
}


note:
multiple inheritance is possible through the concept of interfaces 
or not?
 yes it is possible 
 
 but it is not possible through the concept of classes
 
i1.java:
````````

//parent interface
public interface i1 {
	
	void sum(int x, int y);

}

i2.java:
`````````

public interface i2 {
	
	void sub(int x, int y);

}

Test6.java:
``````````````

//implementation class cum child class 
public class Test6 implements i1,i2{

	@Override
	public void sum(int x, int y) {
		
		System.out.println("addition is: " + (x+y));
		
	}

	@Override
	public void sub(int x, int y) {
	System.out.println("substraction is: " + (x-y));
		
	}

}

interface inheritance:
```````````````````````

//parent interface
public interface i1 {
	
	void sum(int x, int y);

}

i2.java:
`````````

//child interface -interface inheritance
public interface i2 extends i1{
	
	void sub(int x, int y);

}

Test6.java:
``````````

//implementation class cum child class 
public class Test6 implements i2{

	@Override
	public void sum(int x, int y) {
		
		System.out.println("addition is: " + (x+y));
		
	}

	@Override
	public void sub(int x, int y) {
	System.out.println("substraction is: " + (x-y));
		
	}

}

Test9.java:
```````````

public class Test9 {

	public static void main(String[] args) {
		
		//i1 obj =new i1();//invalid
		//i2 obj = new i2();//invalid 
		
		i2 obj = new Test6();
		
		obj.sum(4, 5);
		obj.sub(8,7);
		
		
	}
}

realtime scenario example on interface(s):
``````````````````````````````````````````
Bank.java:
`````````


public interface Bank {
	
	 double getRateOfInterest();

}

Icici.java:
```````````

public class Icici implements Bank {

	@Override
	public double getRateOfInterest() {
		return 7.5;
	}

}

SBI.java:
`````````

public class SBI implements Bank {

	@Override
	public double getRateOfInterest() {
		// TODO Auto-generated method stub
		return 6.5;
	}

}

CityBank.java:
```````````````

public class CityBank implements Bank {

	@Override
	public double getRateOfInterest() {
		// TODO Auto-generated method stub
		return 9.5;
	}

}

InterfaceDemo.java:
``````````````````
//execution logic class
public class InterraceDemo {

	 public static void main(String[] args) {
		
		 Bank obj = new Icici();
		 
		 if(obj instanceof CityBank) {
		 System.out.println("citybank rate of interest is: " + obj.getRateOfInterest());
		 }
		 else if(obj instanceof SBI)
		 {
			 System.out.println("sbi rate of interest is : " + obj.getRateOfInterest());
		 }
		 else if(obj instanceof Icici)
		 {
			 System.out.println("icici rate of interest is: " + obj.getRateOfInterest());
		 }
		 
	}
}


package:
``````````
package is  a collectin of classes ,interfaces and sub pacakges 

advantage:
 1.reusability
 2.avoids naming conflicts
 
syntax to create or define the package:

  package <packagename>;
  

example:
````````
  package p1;
  public class Test1{
  
    //variables
	//methods
	
  }

  package p1;
  public interface i1{
  }
  
naming convention for package:

<reverseofthecompanywebsiteurl>.<projectname>.<modulename>

examples:

 com.techm.banking.withdrawl
 com.wipro.insurance.fundtransfer
 com.infy.sales.deposit
 

how to import the pacakge :

syntax: 
  import <packagename>.<classname>/<interfacename>;
  
  import <packagename>.*;
  
  * -> it will import everything from that package 
  
  
Test1.java:
```````````
package p1;

public class Test1 {
	
	public void sum(int x, int y)
	{
		System.out.println("sum is: " + (x+y));
	}

}
Test2.java:
````````````
package p2;
import p1.Test1;
public class Test2 {
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(4, 5);
	}

}


packages can be two types 

  1.predefined pacakges are developed by sunmicrosystem
  2.user defined packages are developed by java developers.
  
  
 core java -> predefined packages?

String (java.lang)
System (java.lang)
File(java.io)
ArrayList(java.util)


list of core java predefined packages:
``````````````````````````````````````
java.applet
java.awt
java.awt.color
java.awt.datatransfer
java.awt.dnd
java.awt.event
java.awt.font
java.awt.geom
java.awt.im
java.awt.im.spi
java.awt.image
java.awt.image.renderable
java.awt.print
java.beans
java.beans.beancontext
java.io
java.lang
java.lang.annotation
java.lang.instrument
java.lang.invoke
java.lang.management
java.lang.ref
java.lang.reflect
java.math
java.net
java.nio
java.nio.channels
java.nio.channels.spi
java.nio.charset
java.nio.charset.spi
java.nio.file
java.nio.file.attribute
java.nio.file.spi
java.rmi
java.rmi.activation
java.rmi.dgc
java.rmi.registry
java.rmi.server
java.security
java.security.acl
java.security.cert
java.security.interfaces
java.security.spec
java.sql
java.text
java.text.spi
java.time
java.time.chrono
java.time.format
java.time.temporal
java.time.zone
java.util
java.util.concurrent
java.util.concurrent.atomic
java.util.concurrent.locks
java.util.function
java.util.jar
java.util.logging
java.util.prefs
java.util.regex
java.util.spi
java.util.stream
java.util.zip
   

https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/System.html



note:
by default for every java program, which package will be imported?
 
   java.lang
   
  
access modifiers:
`````````````````
 in java, how many access modifiers are there?
 
    ->4
	
	private
	default 
	protected 
	public 
	
	
	  private int a;
	  int a;--> default access modifier is not a keyword 
	  protected int a;
	  public int a ;
	  

->these access modifiers are used to control the visibility of the data 
  over the packages. 


private:

   with in the class -> yes
   same package other class -> no
   other package other class -> no 
   
default:
    with in the class -> yes
	same package other class -> yes
	other package class -> no 
	
protected:
    with in the class -> yes
	same package other class -> yes
	other package indpendent class -> no 
	other package child class -> yes
	
public:
    no restriction from anywhere we can access.
	
	

Test1.java:
```````````
package p1;

public class Test1 {
	
	//public property
	public void sum(int x, int y)
	{
		System.out.println("sum is: " + (x+y));
	}
	
	public static void main(String[] args) {
		
		new Test1().sum(4, 5);
	}

}

Test2.java:
`````````````
package p1;

public class Test2 {

	public static void main(String[] args) {
		
		new Test1().sum(4,5);
	}
}

Test3.java:
```````````
package p2;

import p1.Test1;

//other package independent class
public class Test3 {
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(4,5);
	}

}


exception handling in java:
```````````````````````````

errors are of two types 

1.compile time error 
2.runtime error (exception)

when you pass the invalid input, jvm couldnot process inreturn it gives the 
error at runtime. 

exception -> runtime error 
why -> logical problem/invalid input 

what happend if we get exception?

1.abnormal termination 
2.system error messages

exception handling in java:
how can we handle the exception in java?

  using 5 java keywords 
  
  1.try 
  2.catch
  3.finally
  4.throws
  5.throw
 
without handling the exception:
````````````````````````````````
package com.exceptions;

public class Test1 {
	
	public static void main(String[] args) {
		int x = 100,y=0;
		int z = x/y;
		System.out.println("division is : " + z);
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		
	}
	
	
	
	

}

 
  
try block is used to keep the problematic statements 

syntax:

  try
  {
  
     //problematic statements
  
  }


catch:
catch is the java reserved keyword which is used to catch the exception and 
provides user friendly message. 

syntax:

   catch(exceptionclassname <referecnevariablename>)
   {
     //userfriendly message
   }
   

example;
`````````
package com.exceptions;

public class Test1 {

	public static void main(String[] args) {
		int x = 100, y = 0;
		try {
			int z = x / y;
			System.out.println("division is : " + z);
		} catch (ArithmeticException ae) {
			System.out.println("don't enetr zero as denominator");
		}
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");

	}

}

using Scanner class:
````````````````````
package com.exceptions;

import java.util.Scanner;

public class Test1 {

	public static void main(String[] args) {
		
		try {
			Scanner s= new Scanner(System.in);
			System.out.println("enter first no:");
			int fno = s.nextInt();
			System.out.println("enter second no:");
			int sno = s.nextInt();
			
			int z = fno / sno;
			System.out.println("division is : " + z);
		} 
		
		
		catch (ArithmeticException ae) {
			System.out.println("don't enetr zero as denominator");
		}
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");

	}

}

for a single try block, how many catch block(s) we can define?

  as many as we want based on the requirement.
  
  
even though we have multiple catch block(s) at a time, how many catch block(s)
gets executed?
 only one.
 
note:
while we are handling the exceptions, order must be from child class exceptions 
to super class excpetions not from super class to child class because if we do like that we will get compile time error saying that unreachable catch block



example:
```````
package com.exceptions;

import java.util.InputMismatchException;
import java.util.Scanner;

public class Test1 {

	public static void main(String[] args) {
		
		try {
			Scanner s= new Scanner(System.in);
			System.out.println("enter first no:");
			int fno = s.nextInt();
			System.out.println("enter second no:");
			int sno = s.nextInt();
			
			int z = fno / sno;
			System.out.println("division is : " + z);
		} 
		
		
		
		
		
		catch (ArithmeticException ae) {
			System.out.println("don't enetr zero as denominator");
		}
		
		catch(InputMismatchException im)
		{
			System.out.println("please enter only numeric values");
		}
		catch(RuntimeException re)
		{
			System.out.println(re);
		}
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");

	}

}

example:
```````````
package com.exceptions;

import java.util.InputMismatchException;
import java.util.Scanner;

public class Test1 {

	public static void main(String[] args) {

		try {
			Scanner s = new Scanner(System.in);
			System.out.println("enter first no:");
			int fno = s.nextInt();
			System.out.println("enter second no:");
			int sno = s.nextInt();

			int z = fno / sno;
			System.out.println("division is : " + z);
		}

		catch (RuntimeException re) {
			if (re instanceof ArithmeticException) {
				System.out.println("don't enter zero as denominator");
			} else if (re instanceof InputMismatchException) {
				System.out.println("please pass only numeric values");
			}
		}
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");

	}

}

finally block:
```````````````
finally block is used to release/reliquish the resources.

inside the finally block it is recommended to keep closing related logic(s).

->Files 

   (open the file)
   (operations on file)
      ->data leakage issues
   (close the file)
   
->db

    get the connection from db
	perform the db operations 
	  
	close the connection 
	
->if we write any statement /logic inside the finally block whether you have 
an exception or not in your application, irrespective of that everytime finally 
block gets executed so that closing related logic gets executed 

	
   
-  file open 
-  int x = 100/0;
-
-
-
-
-finally{
closing related logic
}
 
 example:
 ``````````
 package com.exceptions;

import java.util.InputMismatchException;
import java.util.Scanner;

public class Test1 {

	public static void main(String[] args) {

		try {
			Scanner s = new Scanner(System.in);
			System.out.println("enter first no:");
			int fno = s.nextInt();
			System.out.println("enter second no:");
			int sno = s.nextInt();

			int z = fno / sno;
			System.out.println("division is : " + z);
		}

		catch (RuntimeException re) {
			if (re instanceof ArithmeticException) {
				System.out.println("don't enter zero as denominator");
			} else if (re instanceof InputMismatchException) {
				System.out.println("please pass only numeric values");
			}
		}
		
		finally
		{
			System.out.println("finally block gets executed always");
		}
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");
		System.out.println("code executed");

	}

}


throws:
````````
throws is a java reserved keyword.

which gives an indication/warning/instruction to the calling function to keep the called function under try and catch block.


Test2.java:
````````````
package com.exceptions;
//called program
public class Test2 {

	
	//called function
	public void division() throws ArithmeticException
	{
		int z = 100/0;
		System.out.println("division is: " + z);
	}
}


Test3.java:
``````````
package com.exceptions;
//calling program
public class Test3 {
	
	//calling function
	public static void main(String[] args) {
		
		
		Test2 obj = new Test2();
		try {
		obj.division();
		}
		catch(ArithmeticException ae)
		{
			System.out.println("something is wrong with divsion method");
		}
		System.out.println("rest statements executed");
		System.out.println("rest statements executed");
		System.out.println("rest statements executed");
		System.out.println("rest statements executed");
		System.out.println("rest statements executed");
	}

}


throw:
``````
throw is a java reserved keyword using this we can throw an excpetion 
explicitly.

syntax for throwing an exception:

  throw new <exceptionclassname>();
  

->ecommerce website

->checking the products based on the weight


->if weight > 100kgs ->product is valid


->if weight < 100 -> throw new InvalidProductException();
  

Test4.java:
````````````
package com.exceptions;
//business logic class
public class Test4 {
	
	public void checkProduct(int weight)
	{
		if(weight>100)
		{
			System.out.println("product is valid");
		}
		else
		{
			try {
			throw new InvalidProductException();
			}
			catch(InvalidProductException ipe)
			{
				System.out.println("product weight must be greater than 100");
			}
		}
		System.out.println("rest statements executed");
		System.out.println("rest statements executed");
		System.out.println("rest statements executed");
		System.out.println("rest statements executed");
		
	}

}

InvalidProductException.java:
````````````````````````````
package com.exceptions;
//user defined exception class
public class InvalidProductException extends Exception {

}

Test5.java:
```````````
package com.exceptions;

import java.util.Scanner;

//exceution logic class
public class Test5 {
	
	public static void main(String[] args) {
		
		Scanner s = new Scanner(System.in);
		System.out.println("enter product weight");
		
		int weight = s.nextInt();
		//create the object 
		Test4 obj = new Test4();
		
		obj.checkProduct(weight);
		
	}

}



->finally
->throws
->throw 

collection framework:
```````````````````````

int x = 100;
int y = 200;

  array
  
  int x[]={100,200,300,400};//size will be decided 
  
   size of an array -> 4 
   
   sysout(x.length);//4
   
   length is an implicit variable which gives you length of an array. 
   
  
using arrays, we can store only same type values . we are not allowed to store 
multiple values of different types. 

because while we are declaring an array variable, we should declare the type 
of an array.



  int x[];//array declaration
  x = new int[5];//memory allocation 
  
  index ->0
  
  maximum index =array size -1 =4
  
  //values assigning 
  x[0]=100;
  x[1]=200;
  x[2]=300;
  
 size of an array is always fixed, you can't increase the memory or 
 you can't decrease it.
 
drawbacks:
1.array size is fixed
2.only homogenious type of data we can store.
3.arrays are not following proper ds internally.
4.for every operation in arrays, we should write the logic manually.


example:
``````````
package com.collections;

public class Test1 {
	
	
	public static void main(String[] args) {
		
		
		int x[]= {100,200,300};
		
		System.out.println(x[0]);
		System.out.println(x[1]);
		System.out.println(x[2]);
		System.out.println(x[3]);
	}

}

example:
````````````
package com.collections;

public class Test1 {
	
	
	public static void main(String[] args) {
		
		
		int x[];//array declaration
		x=new int[3];//memory allocation
		//assigning values
		
		x[0]=100;
		x[1]=200;
		x[2]=300;
		
		
		System.out.println(x[0]);
		System.out.println(x[1]);
		System.out.println(x[2]);
		
	}

}

using for loop on arrays:
``````````````````````````
package com.collections;

public class Test1 {
	
	
	public static void main(String[] args) {
		
		
		int x[];//array declaration
		x=new int[3];//memory allocation
		//assigning values
		
		x[0]=100;
		x[1]=200;
		x[2]=300;
		
		//displaying	
		System.out.println(x[0]);
		System.out.println(x[1]);
		System.out.println(x[2]);
		
		
		System.out.println("using for loop i am displaying");
		
		for(int i=0;i<=2;i++)
		{
			System.out.println(x[i]);
		}
		
		
		
	}

}

using foreach loop:
```````````````````
package com.collections;

public class Test1 {
	
	
	public static void main(String[] args) {
		
		
		int x[];//array declaration
		x=new int[3];//memory allocation
		//assigning values
		
		x[0]=100;
		x[1]=200;
		x[2]=300;
		
		//displaying	
		System.out.println(x[0]);
		System.out.println(x[1]);
		System.out.println(x[2]);
		
		
		System.out.println("using for loop i am displaying");
		
		for(int i=0;i<=2;i++)
		{
			System.out.println(x[i]);
		}
		
		System.out.println("using foreach loop i am displaying");
		
		for(int y:x)
		{
			System.out.println(y);
		}
	}

}


Student.java:
````````````````
package com.collections;

public class Student {
	
	private int stid;
	private String stname;
	
	
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	//parameterized constructor
	public Student(int stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	
	public Student()
	{
		
	}

	//toString() override
	@Override
	public String toString()
	{
		return stid + " " + stname;
	}
	
}


Test2.java:
```````````````
package com.collections;

public class Test2 {

	public static void main(String[] args) {
		
		//array variable of Student type 
		
		Student st[];
		
		//size 
		
		st = new Student[2];
		
		Student obj1 = new Student(100,"rama");
		Student obj2 = new Student(200,"anjali");
		//assign the values 
		
		st[0]=obj1;
		st[1]=obj2;
		
		//display using for each loop
		
		for(Student s:st)
		{
			System.out.println(s);
		}
		
	}
}



Test3.java:
```````````
package com.collections;

public class Test3 {

	@Override
	public String toString()
	{
		return "kushvanth";
	}
	
	public static void main(String[] args) {
		
		
		Test3 obj = new Test3();
		System.out.println(obj.toString());
	}
}


collection framework in java:
`````````````````````````````
collection f/w is the standardized mechanism of grouping same type of data 
and different type of data in a single variable. that single variable is known 
as collection variable. 

benefits of collection framework over arrays:

1.it supports both homogenious and heterogenious data. 
2.collection size is not fixed, you can increase or decrease the memory size. 
3.cfw internally using standardized datastructures.
4.inside cfw, we have readymade methods for maximum requirements.

to achieve this, we will use some predefined interfaces and classes. 
those are availble in one predefined package i.e. java.util package.

   1.Collection 
   2.List
                   3.Set
                                     4.Queue
                   5.SortedSet
   
interface Collection 
{
}
do we have any direct implementation class for Collection?

  no , we don't have 
  
  
interface List extends Collection 
{
}  
implementaion classes for List interface:

  ->ArrayList
  ->LinkedList
  ->Vector
  ->Stack
  
we should go for List collection type 

if our requirement is 

1.to store both homogenious and heterogenious 
2.it allows duplicate elements
3.insertion order is preserved.
4.null insertion is possible. 

   List l = new ArrayList();//valid
   
   
   
   
   
class ArrayList implements List extends Collection 
{
} 
  

example:
``````````
package com.collections;

import java.util.LinkedList;
import java.util.List;

public class Test4 {
	
	public static void main(String[] args) {
		
		
		//create the object for List
		
		List l = new LinkedList();
		l.add(Integer.valueOf(100));
		l.add(Integer.valueOf(100));//valid , duplicates are allowed
		
		l.add(Double.valueOf(3.4));
		l.add(new String("rk"));
		
		l.add(null);
		
		System.out.println(l);
		
		System.out.println("size of collection is:" + l.size());
		
		l.remove(Double.valueOf(3.4));
		System.out.println(l);
		
	    l.remove(3);
	    System.out.println(l);
		
		System.out.println(l.contains("rk"));
		
		l.add(0, Double.valueOf(5.6));
		
		System.out.println(l);
		
		//l.clear();
		
		//using foreach loop on list collection variable
		System.out.println("==================");
		for(Object o:l) {
			System.out.println(o);
		}
		
		
	}

}
  
  note:
  if our frequent operation is insertion/deletion/updation -> LinkedList
  if our frequent operation is selection/accessing -> ArrayList
 
 
interface Set extends Collection 
{
}

link for eclipse keyboard shortcuts:

https://cheatography.com/gaspoza/cheat-sheets/eclipse-for-java/



Set contains any new methods?
  Set interface doesn't contains new methods
  
->it allows both homogenious and heterogenious objects
->duplicates are not allowed.
->insertion order is also not preserved.
->null insertion is possible but only for one time.

  HashSet 
  LinkedHashSet
  
  
Set s = new HashSet();

note:
from java 1.5 version onwards they introduced two concepts 

1.autoboxing->primitive type to object type conversion 

2.autounboxing->Object type to primitive type conversion 




Test5.java:
````````````
package com.collections;

import java.util.LinkedHashSet;
import java.util.Set;

public class Test5 {
	
	public static void main(String[] args) {
		
		//creating an object for Set //ctrl+shift+o  -> to organize the imports
		
		Set s = new LinkedHashSet();
		
		s.add(100);
		s.add("rama");
		s.add(4.5);
		s.add(true);
		s.add('a');
		s.add(100);
		s.add(null);
		
		
		for(Object o:s)
		{
			System.out.println(o);
		}
		
	}

}

how to add user defined object to any collection object:
````````````````````````````````````````````````````````
package com.collections;

import java.util.LinkedHashSet;
import java.util.Set;

public class Test5 {
	
	public static void main(String[] args) {
		
		//creating an object for Set //ctrl+shift+o  -> to organize the imports
		
		Set s = new LinkedHashSet();
		
		Student st1 = new Student(100,"rama");
		Student st2 = new Student(87,"anjali");
		Student st3 = new Student(76,"ankit");
		Student st4 = new Student(8,"kushwanth");
		
		s.add(st1);
		s.add(st2);
		s.add(st3);
		s.add(st4);
		
		
		for(Object o:s)
		{
			System.out.println(o);
		}
		
	}

}

example:
````````
package com.collections;

import java.util.ArrayList;

public class Test6 {
	
	public static void main(String[] args) {
		
		ArrayList al = new ArrayList();
		
		for(int i=1;i<=10;i++)
		{
			al.add(i);
		}
		
		for(Object o:al)
		{
			//type casting from Object type to Integer type 
			Integer i = (Integer)o;
			
			if(i%2!=0)
			{
				System.out.println(i);
			}
		}
	}

}

generics advantage:
`````````````````````
1.type casting is not required 
2.we will get compile time errors not runtime erros. 

example:
````````
package com.collections;

import java.util.ArrayList;

public class Test6 {
	
	public static void main(String[] args) {
		
		ArrayList<Integer> al = new ArrayList();
		
		for(int i=1;i<=10;i++)
		{
			al.add(i);
		}
		
		
		
		for(Integer i:al)
		{
			
			
			if(i%2!=0)
			{
				System.out.println(i);
			}
		}
	}

}


example:
````````
package com.collections;

import java.util.ArrayList;

public class Test6 {
	
	public static void main(String[] args) {
		
		ArrayList<Student> al = new ArrayList();
		
		al.add(new Student(100,"rama"));
		al.add(new Student(23,"kushwanth"));
		al.add(new Student(8,"kiran"));
		
		
		
		for(Student st:al)
		{
			
			if(st.getStid()%2==0)
			{
				System.out.println(st);
			}
			
		}
	}

}

interface SortedSet extends Set extends Collection 
{
}

SortedSet s = new SortedSet();

  //invalid 
  
implementation classes sunmicrosystem have given

 1.TreeSet
 
SortedSet s = new TreeSet();

SortedSet contains some specific methods along with Collection interface methods

1.it must be homogenious and comparable objects.
2.data will be coming in sorted order(natural sorting order -> ascending , alphabetical)
3.duplicates are not allowed
4.null insertion is not possible.

example:
````````````
package com.collections;

import java.util.SortedSet;
import java.util.TreeSet;

public class Test7 {
	
	public static void main(String[] args) {
		
		SortedSet<Integer> s  = new TreeSet();
		s.add(23);
		s.add(8);
		s.add(789);
		s.add(90);
		s.add(-7);
		s.add(678);
		s.add(234);
		s.add(123);
		
		System.out.println(s.headSet(90));
		System.out.println(s.tailSet(90));
		System.out.println(s.first());
		System.out.println(s.last());
		
		System.out.println(s.subSet(90, 789));
		
		
		
	}

}


 example:
````````````
package com.collections;

public class Student implements Comparable<Student>{
	
	private int stid;
	private String stname;
	
	
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	//parameterized constructor
	public Student(int stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	
	public Student()
	{
		
	}

	//toString() override
	@Override
	public String toString()
	{
		return stid + " " + stname;
	}
	@Override
	public int compareTo(Student o) {
		
		if(this.getStid()>o.getStid())
		{
			return 8;
		}
		else if (this.getStid()<o.getStid())
		{
			return -8;
		}
		else
		{
			return 0;
		}
		
	}
	
}

Test7.java:
``````````
package com.collections;

import java.util.SortedSet;
import java.util.TreeSet;

public class Test7 {
	
	public static void main(String[] args) {
		
		SortedSet<Student> s  = new TreeSet();
		
		s.add(new Student(100,"rk"));
		s.add(new Student(45,"pavan"));
		s.add(new Student(456,"kiran"));
		
	
		
		System.out.println(s);
		
		
		
	}

}

 

based on student name how to sort:
````````````````````````````````````
package com.collections;

import java.util.SortedSet;
import java.util.TreeSet;

public class Test7 {
	
	public static void main(String[] args) {
		
		SortedSet<Student> s  = new TreeSet();
		
		s.add(new Student(100,"rk"));
		s.add(new Student(45,"pavan"));
		s.add(new Student(456,"kiran"));
		
	
		
		System.out.println(s);
		
		
		
	}

}


Test7.java:
`````````````
package com.collections;

public class Student implements Comparable<Student>{
	
	private Integer stid;
	private String stname;
	
	
	public Integer getStid() {
		return stid;
	}
	public void setStid(Integer stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	//parameterized constructor
	public Student(Integer stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	
	public Student()
	{
		
	}

	//toString() override
	@Override
	public String toString()
	{
		return stid + " " + stname;
	}
	@Override
	public int compareTo(Student o) {
		
		return o.getStname().compareTo(this.getStname());
		
	}
	
}



compareTo() -> Comparable interface 

  ->in natural sorting order 
  
  Comparable is meant for getting the data in natural sorting order. 
  
  
StudentIdComparator:
````````````````````
package com.collections;

import java.util.Comparator;

public class StudentIdComparator implements Comparator<Student> {

	@Override
	public int compare(Student o1, Student o2) {
		
		if(o1.getStid()>o2.getStid()) {
			return 7;
		}
		else if(o1.getStid()<o2.getStid())
		{
			return -8;
		}
		else
		{
			return 0;
		}
		
	}

}


StudentNameComparator.java:
````````````````````````````

package com.collections;

import java.util.Comparator;

public class StudentNameComparator implements Comparator<Student> {

	@Override
	public int compare(Student o1, Student o2) {		
		
		return o2.getStname().compareTo(o1.getStname());
	}

}


Test7.java:
`````````````
package com.collections;

import java.util.SortedSet;
import java.util.TreeSet;

public class Test7 {
	
	public static void main(String[] args) {
		
		//SortedSet<Student> s  = new TreeSet(new StudentIdComparator());
		SortedSet<Student> s  = new TreeSet(new StudentNameComparator());
		s.add(new Student(100,"rk"));
		s.add(new Student(45,"pavan"));
		s.add(new Student(456,"kiran"));
		
	
		
	    for(Student x:s)
	    {
	    	System.out.println(x.getStid() + "====>" + x.getStname());
	    }
		
		
		
	}

}


cursors in cfw:
```````````````````
cursor is pointing to something.

Iterator is one of the predefineed interface available in java.util package.

for the purpose of iterating the elements from collection .

->using Iterator we can remove the elements from underlying collection object 

example:
`````````
package com.collections;

import java.util.ArrayList;
import java.util.Iterator;

public class Test8 {
	
	public static void main(String[] args) {
		
		ArrayList<Integer> al = new ArrayList();
		
		for(int i=1;i<=10;i++)
		{
			al.add(i);
		}
		
		//create an object for Iterator 
		
		  Iterator<Integer> itr = al.iterator();
		  
		  while(itr.hasNext())
		  {
			  if(itr.next()%2==0)
			  {
				  itr.remove();
			  }
		  }
		  
		System.out.println(al);
	}

}

Iterator is an uni-directional cursor, using this we can iterate the data 
in single direction or forward direction only, we can't achieve in bidrection 
and using Iterator only we are able to remove the elements from underlying 
collection object

requirement:
 i want to iterate both in forward and backward direction 
 add the elements 
 update the elements
 remove the elements 
 
by using ListIterator  it is possible. 

ListIterator: ListIterator is the predefined interface 
available in java.util package
 
 ArrayList al = new ArrayList();
 
  ListIterator ltr =  al.listIterator();
  
Iterator -> universal cursor
ListIterator -> only we can use this on List realated collections only.

example:
```````
package com.collections;

import java.util.ArrayList;
import java.util.ListIterator;

public class Test8 {
	
	public static void main(String[] args) {
		
		ArrayList<Integer> al = new ArrayList();
		
		for(int i=1;i<=10;i++)
		{
			al.add(i);
		}
		
		//create an object for Iterator 
		
		  ListIterator<Integer> ltr = al.listIterator();
		  
		  System.out.println("getting elements in forward direction");
		  while(ltr.hasNext())
		  {
			  System.out.println(ltr.next());
		  }
		  System.out.println("fetching elements in backward direction");
		  
		  while(ltr.hasPrevious())
		  {
			 if(ltr.previous()%2==0)
			 {
				 ltr.set(100);
			 }
		  }
		  
		  System.out.println(al);
		  
		  
		
	}

}




to organize the data in the form of (key,value) pair

  then we should use Map interface.
  
  
properties of Map:

1.insertion order is not preserved 
2.duplicate key objects are not allowed where as duplicate value objects are allowed.
3.multiple null value objects  possible, but single null key object is only 
  possible 
4.supports both homogenious and heterogenious objects

example:
````````
package com.collections;

import java.util.HashMap;
import java.util.Map;

public class Test9 {
	
	public static void main(String[] args) {
		
		//creating an object for Map interface
		Map map = new HashMap();
		
		map.put(100, "ram");
		map.put(200, "anjali");
		map.put(300, "Philip");
		map.put(400, "lakshmi");
		map.put("shiva", 500);
		map.put(100, "rk");
		map.put(700, "anjali");
		map.put(null, null);
		map.put(800, null);
		
		
		System.out.println(map);
		
	}

}

example:
```````
package com.collections;

import java.util.HashMap;
import java.util.Map;

public class Test9 {
	
	public static void main(String[] args) {
		
		//creating an object for Map interface
		Map<Integer,String> map = new HashMap();
		
		map.put(100, "ram");
		map.put(200, "anjali");
		map.put(300, "Philip");
		map.put(400, "lakshmi");
		
		
		for(Map.Entry  m: map.entrySet())
		{
			System.out.println(m.getKey() + " " + m.getValue());
		}
		
		
	}

}

note:
in case of HashMap, insertion order we can't predict but in case of 
LinkedHashMap insertion order is preserved in which order we insert in the same 
order we will get the output.

example:
`````````
package com.collections;

import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;

public class Test9 {
	
	public static void main(String[] args) {
		
		//creating an object for Map interface
		Map<Student,Employee> map = new HashMap();
		
		Student st1 = new Student(100,"ram");
		Student st2 = new Student(200,"anjali");
		
		Employee emp1 = new Employee(300,"vinitha");
		Employee emp2 = new Employee(400,"sameera");
		
		
		map.put(st1, emp1);
		map.put(st2, emp2);
		
		for(Map.Entry<Student,Employee> m : map.entrySet())
		{
			System.out.println(m.getKey().getStid() + "--> " + m.getValue().getEmpname());
		}
	
	}

}

SortedMap is the child interfaace for Map interface 

by default, it sorts the data based on the key object in natural sorting 
order. 

it accepts only homogenious objects as key objects. 

null insertion is not possible for key objects where as null insertion 
is possible for value object(s).

how to add user defined object as key object to the SortedMap:
````````````````````````````````````````````````````````````````
package com.collections;

import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;

public class Test9 {
	
	public static void main(String[] args) {
		
		//creating an object for Map interface
		SortedMap<Student,String> map = new TreeMap(new StudentNameComparator());
		
		map.put(new Student(300,"rk"), "rk");
		map.put(new Student(200,"john"), "john");
		map.put(new Student(100,"ajay"), "ajay");
		map.put(new Student(400,"ganesh"), "ganesh");
		
		for(Map.Entry m:map.entrySet())
		{
			System.out.println(m.getKey()  + "-->" + m.getValue());
		}
	
		
		
		
	}

}


interface Queue extends Collection 
{
}
  
   Collection is the predefined interfacae available in java.util pacakge 
   ->this is the root interface parent interface for all collection interfaces.
   
 

file handling in java:
``````````````````````
iostreams in java:
``````````````````

  stream:  flow of data in between primary memory to secondary memory  &viceversa.
  
  secondary memory -> harddisk
  
  where exactly programme is running?
  primary memory ->ram 


file handling in java is nothing but performing read and write operations on top 
of files. 

to work with files, we should use some predefined classes which are available 
in java.io package. 

in case of read operation data flow is happening between secondary memory to 
primary memory. 
in case of write operation, data flow is happening between primary memory 
to secondary memory.


as we discussed, if data flow is happening byte by byte we call it as 
bytestream .
and if data flow is happening character by character we call it as characterstream.

requirement:
 want to create the file in java?
 
 
example:
````````
package com.files;
import java.io.File;
import java.io.IOException;
public class Test1 {
	
	
	public static void main(String[] args) {
		
		File f = new File("rk.txt");
		try {
		f.createNewFile();
		}
		catch(IOException ioe)
		{
			System.out.println(ioe);
		}
		
		
		System.out.println(f.exists());
		
	}

}

requirement:
want to write/insert/save the data  into the file?

  do we have any specific classe(s) in java.io package?
  
    FileWriter
	
	BufferedWriter
	
	PrintWriter
	
	
FileWriter is one of the predefined class available in java.io pacakge 

purpose: to write the data into the file 

example:
````````````
package com.files;

import java.io.FileWriter;
import java.io.IOException;

public class Test2 {
	
	public static void main(String[] args) {
		try {
		
		//create the object for FileWriter
		
		FileWriter fw = new FileWriter("rk.txt");
		
		
		fw.write("lakshmi\n");
		fw.write("sailaja\n");
		fw.write("rk\n");
		fw.write(100);
		
		fw.flush();
		
		System.out.println("write operation has done successfully");
		
		}
		catch(IOException ioe)
		{
			System.out.println(ioe);

		}
		
		
	}

}


drawbacks
``````````
1.it is not possible to insert any type of data 
2.for line separator everytime we should append \n which is not recommended 
  and moreover this functionality is platform dependent.
  
  
to avoid the above drawbacks, the next level writer class is 
BufferedWriter.

BufferedWriter:
BufferedWriter is one of the predefined class available in java.io package. 
purpose: to write the data into a file.

drawbacks:

1.it is not possible to insert any type of data 
2.new line problem got resolved by using newLine() of BufferedWriter class.

example:
````````
package com.files;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class Test3 {

	public static void main(String[] args) {

		try {

			BufferedWriter bw = new BufferedWriter(new FileWriter("rk.txt"));

			bw.write("rk");
			bw.newLine();
			bw.write(100);
			bw.newLine();

			bw.write("anjali");
			bw.newLine();
			bw.write(8);

			bw.flush();

			System.out.println("write operation has done successfuly");

		}

		catch (IOException ioe) {
			System.out.println(ioe);
		}

	}

}

PrintWriter:
```````````
PrintWriter is one of the predefined class available in java.io package. 

purpose: to write the data 

example:
````````
package com.files;

import java.io.PrintWriter;

public class Test4 {

	public static void main(String[] args) throws Exception  {
		
		
		//create the object for PrintWriter 
		
		PrintWriter pw = new PrintWriter("rk.txt");
		
		pw.println(100);
		pw.println("rk");
		pw.println(true);
		pw.println(7.8);
		pw.print('a');
		
		pw.flush();
		
		System.out.println("write operation has done successfully");
		
		
	}
}

File
FileWriter
BufferedWriter
PrintWriter


 input operation / read 


to read the data or to perform input operation majorly we are using following 
two classes

 1.FileReader
 2.BufferedReader
 
FileReader: it is one of the predefined class available in java.io package 

purpose: to read the data from the file. 

object creation:
  
   FileReader fr = new FileReader("rk.txt");
   

example:
``````````
package com.files;

import java.io.FileReader;

public class Test5 {
	
	public static void main(String[] args) throws Exception{
		
		//create the object for FileReader
		
		FileReader fr = new FileReader("rk.txt");
		
		int x = fr.read();
		
		while(x!=-1) {
		System.out.print((char)x);
		x=fr.read();
		}
		
	}

}

drawback:
`````````
Using FileReader, it reads the data character by character so that in between 
secondary memory to primary memory network traffic will be increased , so that 
performance may degrade so to avoid this we should use next level reader class 
i.e BufferedReader


BufferedReader: 
it is one of the predefined class 
available in java.io package

purpose: read the data from the file line by line 

example:
`````````
package com.files;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class Test6 {

	
	public static void main(String[] args) {
		BufferedReader br = null;
		try {

			// creating the object for BufferedReader

			 br = new BufferedReader(new FileReader("rk.txt"));
			String s = br.readLine();

			while (s != null) {
				System.out.println(s);
				s = br.readLine();
			}
		} catch (Exception e) {
			System.out.println(e);
		}
           finally {
		           try {
					br.close();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
           }
	}

}

example without closing the file:
``````````````````````````````````
package com.files;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class Test6 {

	public static void main(String[] args) throws Exception {

		// creating the object for BufferedReader

		BufferedReader br = new BufferedReader(new FileReader("rk.txt"));
		String s = br.readLine();

		while (s != null) {
			System.out.println(s);
			s = br.readLine();
		}
	}

}

read and write operations we can also perfrom by using bytestream related 
classes.

   InputStream 
   OutputStream 
   
     
 task:
   read and write the image data using above two classe(s)?

   
  
serialization and deserialization in java:
```````````````````````````````````````````
  
serialization -> write operation  -> writing /saving object type data 
into a file.

 greeting card along with one baloon (with air or without air)
 format will not be supported to send the baloon over the network
 
object data over the network -> not supported


 network supported formats
 
 java -> object format 
 
  requirement: you need to send that object data
  
  object data -> write -> network supported format 
  
  

  writi

deserialization -> read opreation 

serialization: 
the process of writing the object data into a file is known as 
serialziation 

note:
to serialize any java object, corresponding class must be implementing from 
java.io.Serializable which is marker interface.

otherwise we will get runtime exception saying that java.io.NotSerializableException

note:

to achieve the serialization, we will use following class 
i.e. 

ObjectOutputStream and corresponding method i.e. writeObject()


example:
`````````
package com.files;

import java.io.Serializable;

public class Student implements Serializable{
	
	private int stid;
	private transient String stname;
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	@Override
	public String toString() {
		return "Student [stid=" + stid + ", stname=" + stname + "]";
	}
	public Student(int stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	
	public Student()
	{
		
	}

}

Test7.java:
`````````````
package com.files;

import java.io.FileOutputStream;
import java.io.ObjectOutputStream;

public class Test7 {
	
	public static void main(String[] args) throws Exception {
		
		ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("ser.txt"));
		
		Student st = new Student(100,"Ram");
		oos.writeObject(st);
		System.out.println("serialization has done successfully");
		
	}

}

Deserializatio:
the process of reading the object data from a file is known as 
deserialization.

to achieve the deserialization, we will use following class and corresponding 
method i.e 

 ObjectInputStream and readObject()
 
example:
``````````
package com.files;

import java.io.FileInputStream;
import java.io.ObjectInputStream;

public class Test8 {

	public static void main(String[] args) throws Exception {

		ObjectInputStream ois = new ObjectInputStream(new FileInputStream("ser.txt"));
		
		//type casting (from Object type to Student type) (parent to child) -downcasting
		Student student = (Student)ois.readObject();

		System.out.println("student id is: " + student.getStid());
		System.out.println("student name is: " + student.getStname());
	}

}


note:
```````
transient is a variables modifier used in serialization. At the time of serialization, if we don't want to save value of a particular variable in a file, then we use transient keyword. When JVM comes across transient keyword, it ignores original value of the variable and save default value of that variable data type.


Student 

  ArrayList
  HashSet
  
why serializtion:
 to persist the object 
 
 
multithreading:
`````````````````

why java is multithreaded programming langugage.?

  in java, we can create multiple threads based on the requirement. 
  
  thread: flow of action 
  executing one task 
  
  
 10 days 

1 person ->10 days
5 persons -> 2 days 

10 persons - > 1 day 

 
using multithrading, performance will be increased. 

   memory will be distributed 
   
   
how can we create thread in java?

    in java, we have two ways
	
	1.by extends Thread
	
	2.by implements Runnable interface
	
	
whenever we create the thread, it is maintaining following states

 1.new state
 2.runnable state
 3.running state 
 4.wait/sleep state
 5.halted/dead state 
 
 
 
 note:
  creating a thread is nothing but creating an object of Thread class. 
  
   class Test1 extends Thread
   {
   }
   Test1 obj = new Test1();
   obj.start();
    
run() of Thread class purpose is to write the thread logic. 


example:
```````
package com.multithrading;

public class Test1 extends Thread {

	@Override
	public void run()
	{
		for(int i=1;i<=10;i++)
		{
			System.out.println(Thread.currentThread().getName() + " " +i);
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
	

	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.setName("anjali");
		System.out.println(Thread.currentThread().getName());
		obj.start();
		
		for(int i = 1;i<=10;i++)
		{
			System.out.println(Thread.currentThread().getName() + " " + i);
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		
	}

}

by using multithreading, we are achieveing parallel execution or concurrent 
execution.


hyderabad -> vijaywada

   search operation 
   
   
   
we have one more approach is also there to create thread
by implements Runnable interface. 

   example:
   
   package com.multithrading;

public class Test1 implements Runnable {

	@Override
	public void run()
	{
		for(int i=1;i<=10;i++)
		{
			System.out.println(Thread.currentThread().getName() + " " +i);
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
	

	public static void main(String[] args) {
		
		//Runnable object 
		Test1 t = new Test1();
		//convert Runnable object to Thread object
		
		Thread obj = new Thread(t);
		
		
		obj.setName("anjali");
		System.out.println(Thread.currentThread().getName());
		obj.start();
		
		for(int i = 1;i<=10;i++)
		{
			System.out.println(Thread.currentThread().getName() + " " + i);
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		
	}

}








JDBC:
`````
 java database connectivity
 
    developers
	testers
	
	db admin
	
	
by executing the java program -> row will be inserted into the db. 

jdbc program 

  
once you install oracle db in your machine, 
click on start 
|
type sql 
|
click on runsql command line 
|
connect as sysdba
enter username: system/system 
connected


what is jdbc?

 jdbc is  a technology given by sunmicrosystem 
 implementations are provided by db vendors like oracle,ingress,sybase,db2,
 etc..in the form of jar files .
 
 
 
 it is a specification which means it contains only interfaces.
 
 
 interface Bank{
    rateOfInterest();
	}
	
	->java.sql package 
	
	
	
 oracle -> ojdbc6.jar 
 mysql  -> connector.jar
 
  
  
 steps to write the jdbc program?


  1.load the driver class

  
    Class.forName("oracle.jdbc.driver.OracleDriver");
	

  2.obtain the connection 
  
    Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe","system","system");
	
  3.create the Statement object to send the sql statements using Connection     object
      
	    Statement st = con.createStatement();
	
   4.process the queries by invoking corresponding methods on Statement object 

            int x= st.executeUpdate("insert into student values(103,'anjali')");
			 
   5.close the connection 
   

example:
````````
package com.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;

public class Test1 {

	
	public static void main(String[] args) throws Exception {
		
		//load the driver class (type4 driver)
		
		Class.forName("oracle.jdbc.driver.OracleDriver");
		System.out.println("driver class loaded");
		
		//obtain the connection 
		Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe", "system", "system");
		System.out.println("i got the connection");
		
		//sending the sql statements to the db by creating Statement object 
		
		Statement st = con.createStatement();
		
		//process the query
		
		String query = "insert into student values(104,'sameera')";
		
		int x = st.executeUpdate(query);
		
		System.out.println(x + "row(s) inserted");
		
		//close the connection 
		con.close();
		
	}
}


static query:
if a query itself contains data, those queries we can call it as 
static queries. 

 to process static queries, we have to create an object for Statement 
 interface. 
 
dynamic query:
it is a query which doesn't contains any data. 
that data we have to pass while we are executing the program. 

at runtime we have to supply the data. 

to process these dynamic queries we have to create an object for 
PreparedStaement 

to create the object for PreparedStaement , we have to call prepareStatement()
on Connection object. 

once we get this object, we have different setter methods based on the column 
type we have to invoke those setter methods to set the dynamic data. 

once data got set, we can invoke proper method to process the query 

 to process non select querites (insert/update/delete) - > executeUpdate()
 
 
example:
`````````
package com.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.util.Scanner;

public class Test2 {
	
	public static void main(String[] args)throws Exception {
		
		//load the driver class 
		
		Class.forName("oracle.jdbc.driver.OracleDriver");
		
		//connection 
		
		Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe", "system", "system");
		
		//create the object for PreparedStatement 
		
PreparedStatement ps = 
          con.prepareStatement("insert into student values(?,?)");


        Scanner s = new Scanner(System.in);
        
        System.out.println("enter student id:");
        
        int x =  s.nextInt();
        
        System.out.println("enter student name:");
        
        String y = s.next();
        
        ps.setInt(1, x);
        ps.setString(2, y);
        
        int z = ps.executeUpdate();

        System.out.println(z + "row(s) inserted");
        
        con.close();
	}

}


insert
update
delete
  -static 
  -dynamic
  
  executeUpdate()
  
how to process select queries:
``````````````````````````````
to process the select queries , we have to invoke executeQuery() on top 
of either PreparedStaement object or Statement object. 

 executeQuery method return type is ResultSet
 
ResultSet is a predefined interface available in java.sql package. 

it contains different getter methods w.r.to different columns of different 
datatypes. 

 ex: getInt(),getString(),getDouble(),getFloat()
 ....
 
getInt(1)- > 1st column of Integer type 

 
example:
`````````
package com.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;

public class Test3 {
	
	public static void main(String[] args) throws Exception {
		
		//load the driver class
		
		Class.forName("oracle.jdbc.driver.OracleDriver");
		
		//obtain the connection 
		Connection con = 
				DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe","system","system");
		
		//create the Statement object
		
		Statement st = con.createStatement();
		
		//process the select query
		
		ResultSet rs = st.executeQuery("select * from student");
		
		while(rs.next())
		{
			System.out.println(rs.getInt(1) + "==>" + rs.getString(2)); 
		}
		
		rs.close();
		con.close();
	}

}


ResultSetMetaData:
``````````````````
it is one of the predefined interface available in java.sql package 

purpose: to fetch the meta information about the database object (table)

meta data: data about data

 example:
 
 stid,stname
 number,varchar
 and it's sizes all this information we can consider as meta inforamtion.
 
note:
if we want ResultSetMetaData object , we should require ResultSet object

because on ResultSet object only we should invoke getMetaData(), which gives
ResultSetMetaData object

inside this we do have some specific methods, using these we are allowed to 
get the meta inforamtion. 

example:
`````````
package com.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.Statement;

public class Test4 {
	
	public static void main(String[] args) throws Exception{
		
		
		//load the driver class 
		
		Class.forName("oracle.jdbc.driver.OracleDriver");
		
		//get the connection 
		Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe", "system", "system");
		
		//create the object for Statement
		
		Statement st  = con.createStatement();
		
		ResultSet rs = st.executeQuery("select * from student");
		
		
		ResultSetMetaData rsmd = rs.getMetaData();
		
		System.out.println("total no.of columns: " + rsmd.getColumnCount());
		
	    for(int i=1;i<=rsmd.getColumnCount();i++)
	    {
	    	System.out.println(rsmd.getColumnName(i) + " " + rsmd.getColumnTypeName(i) + "(" +rsmd.getPrecision(i) + ")");
	    }
	    
	    con.close();
		
	}

}


batch processing:
``````````````````

   batch processing in jdbc allows you to execute multiple sql statements
   as a single batch, which can imporove performance by reducing overhead.
   
   means if we add multiple sql statements to a batch, instead of sending 
   individual sql statements from java environment to db environment, we can 
   send like a batch where it contains multiple sql queries. 
   
   so that network traffic gets reduced in between these two environments. 
   
   
how can i add mulitple sql statements to a batch?
``````````````````````````````````````````````````````

   addBatch() of Statement interface using this we can add multple sql 
   statements to the batch. 
   
how to process the batch:
````````````````````````````  
executeBatch() of Statement interface

return type: int[]


only we are allowed to add non-select queries to the batch, 
we are not allowed to add select queries to the batch. 
because executeBatch() return type is integer array, where as executeQuery() 
method return type is ResultSet which is not compatible with that. 

example:
```````````
package com.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;

public class Test1 {

	
	public static void main(String[] args) throws Exception {
		
		//load the driver class (type4 driver)
		
		Class.forName("oracle.jdbc.driver.OracleDriver");
		System.out.println("driver class loaded");
		
		//obtain the connection 
		Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe", "system", "system");
		System.out.println("i got the connection");
		
		//sending the sql statements to the db by creating Statement object 
		
		Statement st = con.createStatement();
		
		//process the query
		
		String query1 = "insert into student values(106,'charviha')";
		String query2 = "update student set stname='sailu' where stid=105";	
		String query3 ="delete from student where stid=103";
		//String query4 = "select * From student";
		
		//adding multiple queries to the batch
		st.addBatch(query1);
		st.addBatch(query2);
		st.addBatch(query3);
		//st.addBatch(query4);
		
		
		int x[] = st.executeBatch();
				
				
				
		System.out.println(x[0] + "row(s) inserted");
		System.out.println(x[1] + "row(s) updated");
		System.out.println(x[2] + "row(s) deleted");
		
		//close the connection 
		con.close();
		
	}
}


transaction management in jdbc:
``````````````````````````````````
transaction:

   do everything or do nothing 
   
   amount (account no -> friend's account no)
   
    debit + credit -> transaction 
	
	
	transaction involeve so many operations 
	
	
	
create table rama(accno number(5),accname varchar2(30),bal number(8,2));
create table sitha(accno number(5),accname varchar2(30),bal number(8,2));

 insert some data 
 and observe the below example;
 

example:
``````````
package com.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;

public class Test5 {
	
	public static void main(String[] args) throws Exception {
		
		//load the driver class
		
		Class.forName("oracle.jdbc.driver.OracleDriver");
		
		//get the Connection 
		
		Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe", "system", "system");
		
		con.setAutoCommit(false);
		
		//create the Statement object
		
		Statement st = con.createStatement();
		
		int x = st.executeUpdate("update rama set bal=bal-20000 where accno=1000");
		
		int y = st.executeUpdate("update sitha set bal=bal+20000 where accno=1001");
		
		if(x>0 && y>0)
		{
			con.commit();
			System.out.println("funds transffered successfully");
		}

		else
		{
			con.rollback();
			System.out.println("something went wrong! kindly check account numbers");
		}
		
		
		con.close();
		
	}

}




jdbc:
  jdbc is a technology given by sunmicrosystem
  implementations provided by diffeent db vendors like oracle,mysql,sybase,
  redhat,ingress etc.. 
  
why jdbc?
  to perform the db operations from java env.
  
steps:
  1.load the driver class 
  2.get the connection 
  3.create Statement/PreparedStatement 
  4.process the query 
  5.close the connection 
  

insert/update/delete -> executeUpdate()
select -> executeQuery() ->ResultSet
batch processing 
  addBatch(),executeBatch()
getMetaData() -> ResultSetMetaData 
transaction management 

   
     core java -> 
	 
	 using corejava what applications we can develop?
	    standalone applications/desktop applications 
	
     using adv-java what kind of applicaitons we can develop?

        standalone app & distributed apps

		
		
servlet:
`````````

   internet based applications 
   
        ->client server architecture
		
		
   servlet is a java serverside 
   technology/specification given by sunmicrosystem
   
   implmeentations are provided by different server vendors like 
   apache tomcat,weblogic,glassfish,jboss etc..
   
   
Servlet:
 Servlet is a predefined interface ->javax.servlet package
 
  


http://localhost:9090/welcomedemo/WelcomeServlet



example:
````````
package com.servlet;

import javax.servlet.GenericServlet;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.annotation.WebServlet;

@WebServlet("/WelcomeServlet1")
public class WelcomeServlet extends GenericServlet {

	@Override
	public void init() {
		System.out.println("Iam from init method");
	}

	@Override
	public void destroy() {
		System.out.println("iam from destroy");
	}

	@Override
	public void service(ServletRequest req, ServletResponse res)
	{
	   System.out.println("iam from service method");
	}

}



package com.servlet;

import java.io.PrintWriter;

import javax.servlet.GenericServlet;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.annotation.WebServlet;

@WebServlet("/WelcomeServlet1")
public class WelcomeServlet extends GenericServlet{

	@Override
	public void service(ServletRequest req, ServletResponse res) 
	{
	   try {
		PrintWriter pw = res.getWriter();
		
		pw.println("welcome to servlets");
		
		
		
		
	   }
	   catch(Exception e)
	   {
		   System.out.println(e);
	   }
		
		
	}

}




steps:

  1.create new -> choose dynamic web project 
  
  2.add target runtime -> add the server -> tomcat folder
  
  3.click on next
  
  4.click on next 
  
  5.click on finish 
  
  under src/main/java
    -create one package with any name 
	
	-right click 
	
	-create new servlet 
	
	-give the servlet class name -> 
	
	->super class -> javax.servlet.GenericServlet
	
	
	->overrdide init(),service() and destroy() 
	  to observe the outputs
	  
	  
note:
while you are running if server is not visible , 

  window -> show view -> other -> server 
  
  click here to add server 
  
  -> add the server 
  
  ->right click on the project 
  
  ->run as -> server 
  
  ->choose the server -> run it 
  
  
  if you get any port issue double click on added server 
  change the http port no and then ctrl+s (to save it) 
  and after rerun the application 
  
  
 defining the servlet by extending from HttpServlet:

package com.servlet;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


@WebServlet("/philip")
public class HelloServlet extends HttpServlet {
	
	
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException
	{
		PrintWriter pw = response.getWriter();
		
		pw.println("<h1>welcome to servlets</h1>");
		pw.println("<h2>welcome to servlets</h2>");
		pw.println("<h3>welcome to servlets</h3>");
		pw.println("<h4>welcome to servlets</h4>");
		pw.println("<h5>welcome to servlets</h5>");
		pw.println("<h6>welcome to servlets</h6>");
	}
	
}


 form handling in servlet:
 `````````````````````````````
 
 index.html:
 ````````````
 <!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
<form action="add">

   Enter first no: <input type="text" name="fno"/><br/>
   Enter second no: <input type="text" name="sno"/><br/>
   <input type="submit" value="sum"/>
   
   
</form>
</body>
</html>

 
AddServlet.java:
`````````````````
package com.servlet;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class AddServlet
 */
@WebServlet("/add")
public class AddServlet extends HttpServlet {
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {

		int x = Integer.parseInt(request.getParameter("fno"));
		int y = Integer.parseInt(request.getParameter("sno"));
		int z= x+y;
		
		PrintWriter pw = response.getWriter();
		pw.println("<h1>The sum of given two no.s is :" + z +"</h1>");
		pw.close();
	}
}


->how can we define the servlet by extends HttpServlet
->GenericServlet vs HttpServlet
->doGet()
->form handling 
 


http://localhost:9090/welcomedemo/add?fno=23&sno=23




servlet -> dynmaic web applications




http://localhost:9090/welcomedemo/add?uname="Ram"&password="Techm"


banking apps
 username:
 pasword: 
 
  submit
     
	 http://localhost:9090/postmethoddemo/add
	 
if our requirement is to handle sensitive data, we should override doPost(), 
to overrdide doPost() method we should provide method attribute value of form element as post

if our requirement is to handle insensitive data, we should override doGet()
by default method attribute value is get only.


redirecting mechanism:

  if you make a request to a servlet,then it will be redirected to someother 
  resource 
  
  to achieve this, inside HttpServletResponse, we have one method ie. 
  sendRedirect()
  
  
example:
`````````
package com.servlet;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class RedirectedServlet
 */
@WebServlet("/RedirectedServlet")
public class RedirectedServlet extends HttpServlet {
	
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
		response.sendRedirect("https://www.google.com/");
		response.getWriter().println("welcome to redirectedservlet");
		
	}

}

servlet collaboration:
`````````````````````````

package com.servlet;

import java.io.IOException;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


@WebServlet("/Servlet1")
public class Servlet1 extends HttpServlet {
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
		RequestDispatcher rd = request.getRequestDispatcher("/Servlet2");
		
		rd.forward(request, response);
		
		
	}

}


Servlet2.java:
`````````````
package com.servlet;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


@WebServlet("/Servlet2")
public class Servlet2 extends HttpServlet {
	
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		response.getWriter().println("welcome to second servlet");
	}

}


include():
````````````
package com.servlet;

import java.io.IOException;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


@WebServlet("/Servlet1")
public class Servlet1 extends HttpServlet {
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
		response.getWriter().println("welcome to first servlet ");
		RequestDispatcher rd = request.getRequestDispatcher("/Servlet2");
		
		rd.include(request, response);
		
		
	}

}

Servlet2.java:
``````````````
package com.servlet;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


@WebServlet("/Servlet2")
public class Servlet2 extends HttpServlet {
	
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		response.getWriter().println("welcome to second servlet");
	}

}

RequestDispatcher usecase:
````````````````````````````
index.html:

<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
<form action="Servlet1">

Enter username: <input type="text" name="uname"/><br/>
Enter password: <input type="password" name="pwd" /><br/>
<input type="submit" value="login"/>
</form>
</body>
</html>

Servlet1.java:
`````````````````
package com.servlet;

import java.io.IOException;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


@WebServlet("/Servlet1")
public class Servlet1 extends HttpServlet {
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
		String uname = request.getParameter("uname");
		String pwd = request.getParameter("pwd");
		
		if(pwd.equals("admin"))
		{
		RequestDispatcher rd = request.getRequestDispatcher("/Servlet2");
		
		rd.forward(request, response);
		}
		else
		{
			response.getWriter().println("sorry username or password error,kindly check once");
			RequestDispatcher rd = request.getRequestDispatcher("/index.html");
			
			rd.include(request, response);
		}
		
	}

}

Servlet2.java:
`````````````
package com.servlet;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


@WebServlet("/Servlet2")
public class Servlet2 extends HttpServlet {
	
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		String uname=request.getParameter("uname");
		response.getWriter().println("welcome to" + uname);
	}

}

scopes in servlet:
scopes refer to the contexts in which objects can be stored and shared.
There are three primary scopes in servlets.

  1.request
  2.session 
  3.application 
  
Each scope has a different lifecycle and is used for different purposes.


Request scope:
``````````````
The request scope is specific to a single client request. 
Objects stored in this scope are accessible only during the processing of that 
request.

Servlet1.java:
````````````
package com.servlet;

import java.io.IOException;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


@WebServlet("/Servlet1")
public class Servlet1 extends HttpServlet {
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

		request.setAttribute("name", "rk");
		
		RequestDispatcher rd = request.getRequestDispatcher("/Servlet2");
		rd.forward(request, response);
		
	}

}


Servlet2.java:
````````````````
package com.servlet;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


@WebServlet("/Servlet2")
public class Servlet2 extends HttpServlet {
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
		String name = (String)request.getAttribute("name");
		response.getWriter().println("welcome to " + name);
	}

}


session scope:
``````````````
The session scope is tied to a user's session.
Objects stored in this scope are accessible across multiple requests from the same client.

An object in session scope exists from the moment the session is created 
until the session is invalidated or times out.

This scope is suitable for storing user-specific data that needs to persist 
across multiple requests such as user login information, shopping cart contents, or user preferences.


Servlet1.java:
`````````````
package com.servlet;

import java.io.IOException;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;


@WebServlet("/Servlet1")
public class Servlet1 extends HttpServlet {
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

		
		HttpSession session = request.getSession();
		session.setAttribute("name", "rk");
		
		RequestDispatcher rd = request.getRequestDispatcher("/Servlet2");
		rd.forward(request, response);
		
	}

}


Servlet2.java:
``````````````
package com.servlet;

import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;


@WebServlet("/Servlet2")
public class Servlet2 extends HttpServlet {
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		HttpSession session = request.getSession();
		String name = (String)session.getAttribute("name");
		response.getWriter().println("welcome to " + name);
	}

}

application scope:
``````````````````
The application scope is available to all servlets and jsp pages 
with in the web application

Objects stored in this scope are shared across all sessions and requests.

An object in application scope exists from the moment the web application 
is started until it is stopped or the server is shut down.

package com.servlet;

import java.io.IOException;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


@WebServlet("/Servlet1")
public class Servlet1 extends HttpServlet {
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

		//add the object to the application scope
		ServletContext context = request.getServletContext();
		context.setAttribute("name", "rk");
		
		RequestDispatcher rd = request.getRequestDispatcher("/Servlet2");
		rd.forward(request, response);
		
	}

}

Servlet2.java:
```````````````
package com.servlet;

import java.io.IOException;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


@WebServlet("/Servlet2")
public class Servlet2 extends HttpServlet {
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		ServletContext context = request.getServletContext();
		String name = (String)context.getAttribute("name");
		response.getWriter().println("welcome to " + name);
	}

}

web.xml :
``````````
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" id="WebApp_ID" version="4.0">
 
 <servlet>
 
    <servlet-name>rk</servlet-name>
    <servlet-class>com.servlet.WelcomeServlet</servlet-class>
 
 </servlet>
 
 <servlet-mapping>
 
    <servlet-name>rk</servlet-name>
    <url-pattern>/welcome</url-pattern>
 </servlet-mapping>
 
  
</web-app>

 
 

servlet with jdbc integration:
`````````````````````````````````

 servlet -> web applications 
 
 jdbc -> connect with database
 
 dynamic web applications -> database
 
 
index.html:
``````````
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
<form action="welcome" method="post">

Enter Account no: <input type="text" name="acno"/><br/>
<input type="submit" value="getBalance"/>

</form>

</body>
</html>


WelcomeServlet.java
````````````````````
package com.servlet;

import java.io.IOException;
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


@WebServlet("/welcome")
public class WelcomeServlet extends HttpServlet {
	public  void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
		
		  int accno = Integer.parseInt(request.getParameter("acno"));
		
		  try {
		  Class.forName("oracle.jdbc.driver.OracleDriver");
		  
		  Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe","system","system");
		  
		  PreparedStatement ps = con.prepareStatement("select bal from accounts where accno=?");
		  
		  ps.setInt(1, accno);
		  
		  ResultSet rs = ps.executeQuery();
		  
		  PrintWriter pw = response.getWriter();
		  
		  if(rs.next())
			 
		  pw.println("the available balance is : " + rs.getInt(1));
		  
		  }
		  catch(Exception e)
		  {
			  System.out.println(e);
		  }
		  
		  
		
	}

}


people are moving from servlets to jsp
 -to develop dynamic web applications 
 
 servlet
 jsp 
 
   ->java server pages
   
   
->even non-it person also can easily develop dynamic web application 
  using jsp 
  
->jsp is a tag based programming language


  mvc architecture 
  
    model     -> java class (data)-pojo classes 
	
	
	view      -> jsp's(presentation)
	
	controller  -> business logic (servlet)
	
	
example:
`````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>

   <h1>welcome to jsp technology - sunmicrosystem</h1>
</body>
</html>

   
jsp ->tag based programming language

jsp 

   -> 3 types of tags
   
   
   1.scripting tags
   2.directive tags
   3.action tags
   
scripting tags:

    purpose: to insert the java code
	
	
	scripting tags
	   ->scriptlet tag
	   ->expression tag
	   ->declaration tag
	   
	   
scriptlet tag:

   syntax: 
   
     <%   
	 
	    java code 
		
		
     %>
	 
	 
jsp -> equivalent servlet class ->server 

example of scriptlet tag:
``````````````````````````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>

  <%
  
  int x = 100;
    out.println("the value of x is: " +x);
  
  %>
</body>
</html>


expression tag:

 syntax:

  <%=


  %>

  
drawbacks of scriptlet and expression tags:

 1.we can't define the method 
 2.we can't declare the global variables


if the above two are my drawbacks, to avoid these we should go for next
scripting tag i.e 

declaration tag:

    
 syntax:
 
    <%!
	
	   //java code 
	
	%>

becuase whatever the code we are keeping under declaration tag that will be 
moved to equivalent servlet class 

 example:
 `````````
 <%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>

<!-- scriptlet tag -->
  <%
  
  int x = 100;
    out.println("the value of x is: " +x);
    
    
  
  %>
  <br/>
  
  <!-- expression tag -->
  <%=
  
  "welcome to jsp"
  %>
  <br/>
  
  <!-- declaration tag -->
  <%!
  
   static int square(int n)
    {
	  return n*n;
    }
  
  
  %>
  
  <%
     int square = square(10);
  out.println("square of given number is:" + square);
  %>
  <br/>
  
  <%=
  "the square of give number is:" +square(4)
  %>
  
</body>
</html>


directive tags:
````````````````

   why directive tags:
   
      these tags affect the overall structure and behaviour of the jsp page.
	  

    ->page directive
	->include directive
	->taglib directive
	
page directive:
  
    this directive tag defines some attributes that affect the entire 
	jsp page. 
	
	  syntax:
	  
	    <%@ page ....
		
		%>
		
attributes:

   language
   import
   contenntType
   session 
   errorPage
   isErrorPage
   autoFlush
   buffer
.....

  example:

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"
    import="java.util.Date" %>
    
    
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
  <%
  
    out.println("today's date is: " + new Date());
  
  %>
</body>
</html>

  
include directive:
````````````````````
	  this directive includes the content of another file at the time the 
	  jsp page is translated into a servlet.
	  
	  It's a way to include static content or another jsp page.
	  

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"
    import="java.util.Date" %>
    
    
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
  <%@ include file="header.jsp" %>
</body>
</html>

header.jsp:
``````````````
	<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>

  <h1>header-1</h1>
    <h1>header-1</h1>
      <h1>header-1</h1>
        <h1>header-1</h1>
          <h1>header-1</h1>
</body>
</html>  

->scripting tags
->directive tags

action tags/action elements:
`````````````````````````````
action tags in jsp are used to perfrom dynamic actions such as 

  forwarding requests,
  including other resources,
  
  invoking javabean components.
  
  
 <jsp:forward/>
 <jsp:include/>
 <jsp:setProperty/>
 <jsp:getPropert/>
 <jsp:param/>
 <jsp:useBean/>
 
 
 
 jsp implicit objects:
 ````````````````````````
out	          JspWriter
request	      HttpServletRequest
response	  HttpServletResponse
config	      ServletConfig
application	  ServletContext
session       HttpSession
pageContext	  PageContext
page	      Object
exception	  Throwable
 
 
 action-demo.jsp:
 ````````````````
 <%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
<jsp:forward page="header.jsp">

    <jsp:param value="rk" name="t1"/>
</jsp:forward>
</body>
</html>

header.jsp:
```````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>

  <h1>header-1</h1>
    <h1>header-1</h1>
      <h1>header-1</h1>
        <h1>header-1</h1>
          <h1>header-1</h1>
          
  <hr/>
  <!-- expression tag -->
  <h1>
  <%=
  request.getParameter("t1")
  %>
  </h1>
</body>
</html>
 
 
 jsp:include:
 ```````````````
 include directive -> to include the content at translation time 
 
 jsp:include - > to include the content of another resource but at what time ?
   request time.
   
   
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
<jsp:include page="header.jsp"></jsp:include>
</html>

 
 <jsp:useBean>:
 
 java bean
 
Student.java:
````````````````
 package com.beans;

import java.io.Serializable;

//java bean class
public class Student implements Serializable{
	
	private int stid;
	private String stname;
	
	public Student()
	{
		
	}

	public int getStid() {
		return stid;
	}

	public void setStid(int stid) {
		this.stid = stid;
	}

	public String getStname() {
		return stname;
	}

	public void setStname(String stname) {
		this.stname = stname;
	}
	
	

}


useBean.jsp:
``````````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
	pageEncoding="ISO-8859-1" import="com.beans.Student"%>
<jsp:useBean id="obj" class="com.beans.Student" />

<jsp:setProperty property="stid" name="obj" value="100" />
<jsp:setProperty property="stname" name="obj" value="philip" />
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
	
the student id is: <jsp:getProperty property="stid" name="obj"/><br/>
the student name is:<jsp:getProperty property="stname" name="obj"/>

</body>
</html>

 
 mvc -
 
  model view controller 
  
   model - business data
    view = presentation (jsp)
	controller -> servlet
	
 index.jsp:
 ```````````
 <form action="ControllerServlet" method="post">  
Name:<input type="text" name="name"><br>  
Password:<input type="password" name="password"><br>  
<input type="submit" value="login">  
</form>  

ControllerServlet.jsp:
````````````````````````
package com.servlet;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.bean.LoginBean;


@WebServlet("/ControllerServlet")
public class ControllerServlet extends HttpServlet {
	public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
		response.setContentType("text/html");  
        PrintWriter out=response.getWriter();  
          
        String name=request.getParameter("name");  
        String password=request.getParameter("password");  
          
        LoginBean bean=new LoginBean();  
        bean.setName(name);  
        bean.setPassword(password);  
        
        
        request.setAttribute("bean",bean);  
          
        boolean status=bean.validate();  
          
        if(status){  
            RequestDispatcher rd=request.getRequestDispatcher("login-success.jsp");  
            rd.forward(request, response);  
        }  
        else{  
            RequestDispatcher rd=request.getRequestDispatcher("login-error.jsp");  
            rd.forward(request, response);  
        } 
		
	}

}

LoginBean.java:
```````````````
package com.bean;

import java.io.Serializable;

public class LoginBean implements Serializable{
	
		private String name,password;

		public String getName() {
			return name;
		}

		public void setName(String name) {
			this.name = name;
		}

		public String getPassword() {
			return password;
		}

		public void setPassword(String password) {
			this.password = password;
		}  
		
		public LoginBean()
		{
			
		}
		public boolean validate(){  
		    if(password.equals("admin")){  
		        return true;  
		    }  
		    else{  
		        return false;  
		    }  
		}  
}

login-success.jsp:
`````````````````
<%@page import="com.bean.LoginBean"%>  
  
<p>You are successfully logged in!</p>  
<%  
LoginBean bean=(LoginBean)request.getAttribute("bean");  
out.print("Welcome, "+bean.getName());  
%>  

login-error.jsp:
`````````````````
<p>Sorry! username or password error</p>  
<%@ include file="index.jsp" %>  


 -> assignment:
 do the crud application 
 by applying mvc design pattern
 
 insert
 fetch
 update
 delete
  
 
 
 jsp - > view 
 servlet -> controller 
 model -> bean 
 
 
 
spring framework:
````````````````````
 using spring f/w 
 
    desktop app + web apps
	
class A{

   main()
    {
	  B obj = new B();
	 
	}
}

class B{
}


A class is depending on B class .

Both these classes are tightly coupled with each other which is not 
recommended. 

to achieve loose coupling in between these classes/components people start  
to use spring f/w/

-> inversion of control / dependency injection 

 
   
ioc container is taking care of injecting the bean into another class whenever
it is required. 

  -> ioc container is an interface.

ApplicationContext

   -> rod johnson

   

spring f/w contains several modules 

spring core -desktop apps
spring web mvc- web app
spring jdbc  - database related apps
spring orm   - object relational mapping (hibernate)
spring test   - unit testing 

...


Student.java:
````````````
package com.beans;

public class Student {
	private int stid;
	private String stname;
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	
	public Student()
	{
		
	}

	//business logic method
	public void display()
	{
		System.out.println("student id is: " +stid);
		System.out.println("student name is: " +stname);
	}
}

Test.java:
```````````
package com.beans;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test {
	
	public static void main(String[] args) {
		
		
	   ApplicationContext context = new 
			    ClassPathXmlApplicationContext("applicationcontext.xml");
	   
	   
	   
	    Student student = (Student) context.getBean("stu");
	   
		student.setStid(100);
		student.setStname("ram");
		
		student.display();
	}

}

applicationcontext.xml:
````````````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
        
<bean id = "stu" class="com.beans.Student"/>
</beans>


note:
what are the jar files required to work with spring core module?

  spring context
  spring expression 
  spring core 
  spring beans
  commons logging
  



setter injection & constructor injection:
```````````````````````````````````````````
if we inject the values by invoking setter method is called setter injection 

if we inject the values by invoking constructor is called constructor injection .

to achieve these in spring f/w, we will use following two tags of <bean> element
<beans>
<bean>
 <property name="" value=""/>
 
 <constructor-arg name="" value=""/>
</bean>
</beans>

Student.java:
`````````````
package com.beans;

public class Student {
	private int stid;
	private String stname;

	public int getStid() {
		return stid;
	}

	public void setStid(int stid) {
		this.stid = stid;
	}

	public String getStname() {
		return stname;
	}

	public void setStname(String stname) {
		this.stname = stname;
	}

	public Student() {

	}

	public Student(int stid, String stname) {
		super();
		System.out.println("constructor-1");
		this.stid = stid;
		this.stname = stname;
	}

	// business logic method
	public void display() {
		System.out.println("student id is: " + stid);
		System.out.println("student name is: " + stname);
	}
}

applicationcontext.xml:
`````````````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
        
<bean id = "stu" class="com.beans.Student">

<!-- setter injection -->
     <property name="stid" value="100"/>  
     <property name="stname" value="Rk"/>

<!-- constructor injection -->
<constructor-arg name="stid" value="101"/>
<constructor-arg name="stname" value="guru"/>

</bean>
        
</beans>


Test.java:
````````````
package com.beans;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test {
	
	public static void main(String[] args) {
		
		
	   ApplicationContext context = new 
			    ClassPathXmlApplicationContext("applicationcontext.xml");
	   
	   
	   
	    Student student = (Student) context.getBean("stu");
	   
		
		
		student.display();
	}

}

how to inject reference based type data:
```````````````````````````````````````````

package com.beans;

public class Student {
	private int stid;
	private String stname;
	
	private Address address;
	
	
	public Student(int stid, String stname, Address address) {
		super();
		this.stid = stid;
		this.stname = stname;
		this.address = address;
	}
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	public Address getAddress() {
		return address;
	}
	public void setAddress(Address address) {
		this.address = address;
	}
	
	public Student()
	{
		
	}
	
	public String toString()
	{
		return stid + " " + stname + " " + address;
	}

	
}


Address.java:
````````````
package com.beans;

public class Address {
	
	private String cityName;
	private String stateName;
	public String getCityName() {
		return cityName;
	}
	public void setCityName(String cityName) {
		this.cityName = cityName;
	}
	public String getStateName() {
		return stateName;
	}
	public void setStateName(String stateName) {
		this.stateName = stateName;
	}
	public Address(String cityName, String stateName) {
		super();
		this.cityName = cityName;
		this.stateName = stateName;
	}
	public Address()
	{
		
	}
	
	public String toString()
	{
		return cityName + " " + stateName;
	}

}


Test.java:
````````````
package com.beans;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test {
	
	public static void main(String[] args) {
		
		
	   ApplicationContext context = new 
			    ClassPathXmlApplicationContext("applicationcontext.xml");
	   
	   
	   
	    Student student = (Student) context.getBean("stu");
	   
		
		
		System.out.println(student);
	}

}

applicationcontext.xml:
```````````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
        
<bean id = "stu" class="com.beans.Student">

     <!-- setter injection -->
     <property name="stid" value="100"/>  
     <property name="stname" value="Rk"/>
     <property name="address" ref="add"/>

</bean>

<bean id="add" class="com.beans.Address">
    <!-- setter injection  -->
    <property name="cityName" value="Hyderabad"/>
    <property name="stateName" value="Telangana"/>

</bean>
   
    
</beans>
 
assigment: 
 do the same program, but apply constructor injection 
 
 
how to inject list type collection property:
````````````````````````````````````````````````` 
 
 Student.java:
 `````````````
 package com.beans;

import java.util.List;

public class Student {
	private int stid;
	private String stname;
	
	private List<String> address;

	public int getStid() {
		return stid;
	}

	public void setStid(int stid) {
		this.stid = stid;
	}

	public String getStname() {
		return stname;
	}

	public void setStname(String stname) {
		this.stname = stname;
	}

	public List<String> getAddress() {
		return address;
	}

	public void setAddress(List<String> address) {
		this.address = address;
	}

	public Student(int stid, String stname, List<String> address) {
		super();
		this.stid = stid;
		this.stname = stname;
		this.address = address;
	}
	
	public Student()
	{
		
	}
	
	public String toString()
	{
		return stid + " " + stname + " " + address;
	}
	
}

applicationcontext.xml:
`````````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
        
<bean id = "stu" class="com.beans.Student">

     <!-- setter injection -->
     <property name="stid" value="100"/>  
     <property name="stname" value="Rk"/>
     <property name="address">
     
        <list>
            <value>Hyderabad</value>
            <value>Bangalore</value>
            <value>Pune</value>
            <value>Chennai</value>
        </list>
     </property>

</bean>
   
</beans>


 how to inject list type reference data:
 ````````````````````````````````````````
 
Student.java:
`````````````
package com.beans;

import java.util.List;

public class Student {
	private int stid;
	private String stname;
	
	private List<Address> address;

	
	
	public int getStid() {
		return stid;
	}



	public void setStid(int stid) {
		this.stid = stid;
	}



	public String getStname() {
		return stname;
	}



	public void setStname(String stname) {
		this.stname = stname;
	}



	public List<Address> getAddress() {
		return address;
	}



	public void setAddress(List<Address> address) {
		this.address = address;
	}



	public String toString()
	{
		return stid + " " + stname + " " + address;
	}
	
}

applicationcontext.xml:
````````````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
        
<bean id = "stu" class="com.beans.Student">

     <!-- setter injection -->
     <property name="stid" value="100"/>  
     <property name="stname" value="Rk"/>
     <property name="address">
     
        <list>
            <ref bean="add1"/>
            <ref bean="add2"/>
        </list>
     </property>

</bean>

<bean id="add1" class="com.beans.Address">

    <property name="cityName" value="Hyderabad"/>
    <property name="stateName" value="Telangana"/>

</bean>

<bean id="add2" class="com.beans.Address">

    <property name="cityName" value="Vijaywada"/>
    <property name="stateName" value="Andhra"/>
</bean>
      
</beans>

 
   class Student 
   {
     private int stid;
	 private String stname;
	 private List<String> address;
   }
   
    class Student 
   {
     private int stid;
	 private String stname;
	 private List<Address> address;
   }
   
   -----------assignments---------------
   
   class Student 
   {
     private int stid;
	 private String stname;
	 private Set<String> address;
   }
   
    class Student 
   {
     private int stid;
	 private String stname;
	 private Set<Address> address;
   }
   -----------------------------------------------------
   
 how to inject map type data:
````````````````````````````````
 package com.beans;

import java.util.List;
import java.util.Map;

public class Student {
	private int stid;
	private String stname;
	
	private Map<String,String> address;
	

	public int getStid() {
		return stid;
	}

	public void setStid(int stid) {
		this.stid = stid;
	}


	public String getStname() {
		return stname;
	}


	public void setStname(String stname) {
		this.stname = stname;
	}

	public Map<String, String> getAddress() {
		return address;
	}

	public void setAddress(Map<String, String> address) {
		this.address = address;
	}

	public String toString()
	{
		return stid + " " + stname + " " + address;
	}
	
}

  
applicationcontext.xml:
```````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
        
<bean id = "stu" class="com.beans.Student">

     <!-- setter injection -->
     <property name="stid" value="100"/>  
     <property name="stname" value="Rk"/>
     <property name="address">
     
        <map>
            <entry key="hyd" value="telangana"></entry>
            <entry key="bang" value="karnataka"></entry>
        </map>
     </property>

</bean>

<bean id="add1" class="com.beans.Address">

    <property name="cityName" value="Hyderabad"/>
    <property name="stateName" value="Telangana"/>

</bean>

<bean id="add2" class="com.beans.Address">

    <property name="cityName" value="Vijaywada"/>
    <property name="stateName" value="Andhra"/>
</bean>
      
</beans>
  
  
 how to inject map type reference data:
````````````````````````````````````````````
 package com.beans;

import java.util.List;
import java.util.Map;

public class Student {
	private int stid;
	private String stname;
	
	private Map<Address1,Address2> address;
	

	public int getStid() {
		return stid;
	}

	public void setStid(int stid) {
		this.stid = stid;
	}


	public String getStname() {
		return stname;
	}


	public void setStname(String stname) {
		this.stname = stname;
	}

	

	public Map<Address1, Address2> getAddress() {
		return address;
	}

	public void setAddress(Map<Address1, Address2> address) {
		this.address = address;
	}

	public String toString()
	{
		return stid + " " + stname + " " + address;
	}
	
}

 
 Address1.java:
 ``````````````
 package com.beans;

public class Address1 {
	
	private String cityName;
	
	
	
	public String getCityName() {
		return cityName;
	}

	public void setCityName(String cityName) {
		this.cityName = cityName;
	}

	public Address1()
	{
		
	}
	
	public String toString()
	{
		return cityName;
	}

}

Address2.java:
````````````````
package com.beans;

public class Address2 {

	private String stateName;

	public String getStateName() {
		return stateName;
	}

	public void setStateName(String stateName) {
		this.stateName = stateName;
	}
	
	public Address2()
	{
		
	}
	public String toString()
	{
		return stateName;
	}
}

applicationcontext.xml:
```````````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
        
<bean id = "stu" class="com.beans.Student">

     <!-- setter injection -->
     <property name="stid" value="100"/>  
     <property name="stname" value="Rk"/>
     <property name="address">
     
        <map>
            <entry key-ref="add1" value-ref="add2"></entry>
            <entry key-ref="add3" value-ref="add4"></entry>
        </map>
     </property>

</bean>

<bean id="add1" class="com.beans.Address1">

    <property name="cityName" value="Hyderabad"/>
    

</bean>

<bean id="add2" class="com.beans.Address2">

    
    <property name="stateName" value="Telangana"/>
</bean>

<bean id="add3" class="com.beans.Address1">

    <property name="cityName" value="Bangalore"/>
    

</bean>

<bean id="add4" class="com.beans.Address2">

    
    <property name="stateName" value="Karnataka"/>
</bean>
    
</beans>

autowiring:
`````````````
explicit wiring

autowiring 

 
annotation based wiring 

autodiscovery


  autowiring:
  autowiring is the process of wiring the objects automatically by the spring 
  ioc container 
  
  possible values for autowire attribute of <bean> element is 
    
	  ->byName
	  ->byType
	  ->constructor
	  
note:
when we give autowire attribute value as byName, bean id value and bean class 
property name must be same.

and internally it will look for settter methods to perform setter injection 

Student.java:
`````````````
package com.beans;

import java.util.List;
import java.util.Map;

public class Student {
	
	
	private Address address;
	
	//setter method
	
	//getter method

	public String toString()
	{
		return  " " + address;
	}
	
}

applicationcontext.xml:
````````````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

	<bean id="stu" class="com.beans.Student" autowire="byName"/>
	
		<bean id="address" class="com.beans.Address">

			<property name="cityName" value="Hyderabad" />
		</bean>
</beans>


note:
when we give autowire attribute value as byType , spring ioc container will 
look for bean class type and property type, if both are compatible or matched 
then automatically injection will happen.

in case of byType, we no need to maintain bean id value and property name 
as same.

but bean property type and class type must be matched 


Student.java:
`````````````
package com.beans;

import java.util.List;
import java.util.Map;

public class Student {
	
	
	private Address address;
	
	//setter method
	
	//getter method

	public String toString()
	{
		return  " " + address;
	}
	
}

applicationcontext.xml:
````````````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

	<bean id="stu" class="com.beans.Student" autowire="byType"/>
	
		<bean id="add" class="com.beans.Address">

			<property name="cityName" value="Hyderabad" />
		</bean>
</beans>
  
 
note:
when we give autowire attribute value as constructor, it is exactly working like 
when we give autowire attribute value as byType but only the differnce is in this case , it is performing constructor injection 


Student.java:
`````````````
package com.beans;

import java.util.List;
import java.util.Map;

public class Student {
	
	
	private Address address;
	
	//constructor

	public String toString()
	{
		return  " " + address;
	}
	
}

applicationcontext.xml:
````````````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

	<bean id="stu" class="com.beans.Student" autowire="constructor"/>
	
		<bean id="add" class="com.beans.Address">

			<property name="cityName" value="Hyderabad" />
		</bean>
</beans>
 
 autowiring will work for only referenced type data.
 
 
annotation based wiring:
`````````````````````````
So instead of using XML to describe a bean wiring, 
you can move the bean configuration into the component class
itself by using annotations on the relevant class, method, or field 
declaration.


in case of annotation based wiring autowire attribute is not required
for a bean element.

we have to add @autowired annotation in the java bean class.

we no need to maintain any setter,or constructor for a bean class.

note:
````
by default spring container could not recognize these annotations , 
to recognize
we have to add one xml element in spring configuration file
 <context:annotation-config/>
 
note:
````
to make it execute this , we have to add one more jar spring-aop 
 
 
Student.java:
`````````````
package com.beans;

import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;

public class Student {
	
	
	@Autowired
	private Address address;
	
	

	public String toString()
	{
		return  " " + address;
	}
	
}

applicationcontext.xml:
```````````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context ="http://www.springframework.org/schema/context"
	xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context-3.0.xsd">

   <context:annotation-config/>
	<bean id="stu" class="com.beans.Student"/>
	
		<bean id="add" class="com.beans.Address">

			<property name="cityName" value="Hyderabad" />
		</bean>
</beans>

 autodisovery:
``````````````
Autodiscovery feature frees us from writing all bean declarations
and bean autowirings.

Note:
`````
this feature can be enabled by adding one xml element i.e.

<context:component-scan base-package=""/>


@Component annotation:
``````````````````````
@Component is an annotation that allows Spring to automatically detect 
our custom beans. In other words, without having to write any explicit code,
Spring will: Scan our application for classes annotated with @Component.
 
 Instantiate them and inject any specified dependencies into them. 
 Inject them wherever needed.

Student.java:
```````````````
package com.beans;

import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class Student {
	
	
	@Autowired
	private Address address;
	
	

	public String toString()
	{
		return  " " + address;
	}
	
}

applicationcontext.xml:
`````````````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context ="http://www.springframework.org/schema/context"
	xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context-3.0.xsd">


<context:component-scan base-package="com.beans"/>
		<bean id="add" class="com.beans.Address">

			<property name="cityName" value="Hyderabad" />
		</bean>
</beans>


  explicit wiring 
  autowiring (byName,byType,constructor)
  annotationbased wiring
  autodiscovery
  
 
maven:
``````

maven 

gradle


  maven is a automatiion build tool 
  
  Maven is a popular open-source build tool developed by the Apache Group to build, publish, and deploy several projects at once for better project management. The tool provides allows developers to build and document the lifecycle framework. 
  
 
  build involves 
    compiling the source code 
	executing 
	compiling the test code
	executing 
	generating jar /war file 
	
	
Project Object Model (POM)
Maven is so useful thanks to the Project Object Model (POM), which is an XML file that has all the information regarding project and configuration details. The POM has the description of the project, details regarding the versioning, and configuration management of the project. 

The XML file is located in the project home directory. When you execute a task, Maven searches for the POM in the current directory.


steps to create maven project:

click on new
|
choose maven project
|
give the project name
|
group id: 
artifact id:
package name:

|
click on finish

once it gets created open pom.xml file 
  go to dependencies section add spring context jar 
  
  <!-- https://mvnrepository.com/artifact/org.springframework/spring-context -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>6.1.7</version>
</dependency>


and then save it so that all the required dependencies gets added to the maven libraries section 

Student.java:
``````````````
package com.techm;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class Student {
	
	@Autowired
	private Address address;
	
	public String toString()
	{
		return   " " +address;
	}

}

Address.java:
`````````````
package com.techm;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class Address {

	@Value("Bangalore")
	private String cityName;

	public String getCityName() {
		return cityName;
	}

	public void setCityName(String cityName) {
		this.cityName = cityName;
	}
	
	public Address()
	{
		
	}
	
	public String toString() {
		return cityName;
	}
}

App.java:
```````````
package com.techm;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
       ApplicationContext context = new ClassPathXmlApplicationContext("spring.xml");
       Student student = context.getBean(Student.class);
       System.out.println(student);
    }
}


spring.xml:
```````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context-3.0.xsd">


<context:component-scan base-package="com.techm"/>

</beans>

	
java based coniguration:
`````````````````````````
	if we configure the data by defining the java class, known as java based 
	configuration .
	

Student.java:
`````````````
package com.techm;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class Student {
	
	@Autowired
	private Address address;
	
	public String toString()
	{
		return   " " +address;
	}

}

Address.java:
````````````
package com.techm;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class Address {

	@Value("Bangalore")
	private String cityName;

	public String getCityName() {
		return cityName;
	}

	public void setCityName(String cityName) {
		this.cityName = cityName;
	}
	
	public Address()
	{
		
	}
	
	public String toString() {
		return cityName;
	}
}

App.java:
```````````
package com.techm;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

import com.techm.config.MyConfig;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
       ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class);
       Student student = context.getBean(Student.class);
       System.out.println(student);
    }
}

MyConfig.java:
````````````
package com.techm.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

import com.techm.Address;
import com.techm.Student;

@Configuration
@ComponentScan(basePackages = "com.techm")
public class MyConfig {

	/*
	 * @Bean public Student getStudent() { return new Student(); }
	 * 
	 * @Bean public Address getAddress() { return new Address(); }
	 */
}

pom.xml:
``````````
<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>

	<groupId>com.techm</groupId>
	<artifactId>springcore-maven-demo</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>jar</packaging>

	<name>springcore-maven-demo</name>
	<url>http://maven.apache.org</url>

	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
	</properties>

	<dependencies>
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>3.8.1</version>
			<scope>test</scope>
		</dependency>
		<!--
		https://mvnrepository.com/artifact/org.springframework/spring-context -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context</artifactId>
			<version>6.1.7</version>
		</dependency>


	</dependencies>
</project>


spring jdbc module:
``````````````````
purpose: to implement the persistence logic.
   
   permanently data will store into the db.
   
   jdbc vs spring jdbc.
   
   Spring JDBC is a lightweight abstraction layer on top of JDBC. 
   
   It simplifies database access by providing a higher-level API and 
   handling many common tasks, 
   such as connection management and exception handling.
   to work with spring jdbc module, we have to add two jars
   
   
    1.spring context 
	2.spring jdbc 
	3.odjbc6.jar
	
 package com.techm;

public class Student {
	
	private int stid;
	private String stname;
	
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	
	public Student()
	{
		
	}
	public Student(int stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}

	
}
StudentDao.java:
`````````````````
package com.techm;

import org.springframework.jdbc.core.JdbcTemplate;

public class StudentDao {

	
	private JdbcTemplate template;

	public JdbcTemplate getTemplate() {
		return template;
	}

	public void setTemplate(JdbcTemplate template) {
		this.template = template;
	}
	
	public int saveStudent(Student student)
	{
		String sql = "insert into student values(?,?)";
		return template.update(sql, student.getStid(),student.getStname());
	}
}

App.java:
``````````
package com.techm;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
      ApplicationContext context = new ClassPathXmlApplicationContext("spring.xml");
      
     StudentDao dao =  context.getBean(StudentDao.class);
     
      int x = dao.saveStudent(new Student(100,"Ram"));
      
      System.out.println(x + "row(s) inserted");
    }
}

spring.xml:
```````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context ="http://www.springframework.org/schema/context"
	xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context-3.0.xsd">
  
  <bean id="dao" class="com.techm.StudentDao">
  
      <property name="template" ref="temp"/>
  
  </bean>
  <bean id="temp" class="org.springframework.jdbc.core.JdbcTemplate">
  
       <property name="dataSource" ref="ds"/>
  
  </bean>
  
  <bean id="ds" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
  
  
        <property name="driverClassName" value="oracle.jdbc.driver.OracleDriver" />
		<property name="url" value="jdbc:oracle:thin:@localhost:1521:xe"/>
        <property name="username" value="system" />
		<property name="password" value="system" />
  </bean>
  
  
        
</beans>

 
 
 
 StudentDao.java:
 ````````````````````
 package com.techm;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

@Component
public class StudentDao {

	@Autowired
	private JdbcTemplate template;

	public JdbcTemplate getTemplate() {
		return template;
	}

	public void setTemplate(JdbcTemplate template) {
		this.template = template;
	}
	
	public int saveStudent(Student student)
	{
		String sql = "insert into student values(?,?)";
		return template.update(sql, student.getStid(),student.getStname());
	}
}

spring.xml:
```````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context ="http://www.springframework.org/schema/context"
	xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context-3.0.xsd">
  
  <context:component-scan base-package="com.techm"></context:component-scan>
  
  
  <bean id="temp" class="org.springframework.jdbc.core.JdbcTemplate">
  
       <property name="dataSource" ref="ds"/>
  
  </bean>
  
  <bean id="ds" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
  
  
        <property name="driverClassName" value="oracle.jdbc.driver.OracleDriver" />
		<property name="url" value="jdbc:oracle:thin:@localhost:1521:xe"/>
        <property name="username" value="system" />
		<property name="password" value="system" />
  </bean>
  
  
        
</beans>

do the same for update and delete operations 


assignment:
process select query using spring jdbc module


java based configuration:
```````````````````````````
Student.java:
``````````````
package com.techm;

public class Student {
	
	private int stid;
	private String stname;
	
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	
	public Student()
	{
		
	}
	public Student(int stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}

	
}

StudentDao.java:
````````````````
package com.techm;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

@Component
public class StudentDao {

	@Autowired
	private JdbcTemplate template;

	public JdbcTemplate getTemplate() {
		return template;
	}

	public void setTemplate(JdbcTemplate template) {
		this.template = template;
	}
	
	public int saveStudent(Student student)
	{
		String sql = "insert into student values(?,?)";
		return template.update(sql, student.getStid(),student.getStname());
	}
}


App.java:
``````````
package com.techm;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

import com.techm.config.MyConfig;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
      ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class);
      
     StudentDao dao =  context.getBean(StudentDao.class);
     
      int x = dao.saveStudent(new Student(102,"lakshmi"));
      
      System.out.println(x + "row(s) inserted");
    }
}

MyConfig.java:
````````````````
package com.techm.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DriverManagerDataSource;

@Configuration
@ComponentScan(basePackages = "com.techm")
public class MyConfig {
	
	
	@Bean
	public JdbcTemplate getJdbcTemplate()
	{
		return new JdbcTemplate(getDataSource());
	}
	
	@Bean
	public DriverManagerDataSource getDataSource()
	{
		
		
		DriverManagerDataSource  ds=  new DriverManagerDataSource();
		
		ds.setDriverClassName("oracle.jdbc.driver.OracleDriver");
		ds.setUrl("jdbc:oracle:thin:@localhost:1521:xe");
		ds.setUsername("system");
		ds.setPassword("system");
		
		return ds;
	}
	

}



how to process the select query in spring jdbc using 
ResultSetExtractor and RowMapper:
`````````````````````````````````````````````````````````

package com.techm;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Component;

@Component
public class StudentDao {

	@Autowired
	private JdbcTemplate template;

	public JdbcTemplate getTemplate() {
		return template;
	}

	public void setTemplate(JdbcTemplate template) {
		this.template = template;
	}

	public int saveStudent(Student student) {
		String sql = "insert into student values(?,?)";
		return template.update(sql, student.getStid(), student.getStname());
	}

	public List<Student> getAllStudents() {
		return template.query("select * from student", new ResultSetExtractorTest());
	}

	public List<Student> getAllEmployeesRowMapper() {
		
		return template.query("select * from student", new RowMapperTest());
		
	}

}


ResultSetExtractorTest.java:
`````````````````````````````
package com.techm;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.ResultSetExtractor;

public class ResultSetExtractorTest implements ResultSetExtractor<List<Student>> {

	public List<Student> extractData(ResultSet rs) throws SQLException, DataAccessException {
		
		List<Student> list = new ArrayList<Student>();
		
		while(rs.next())
		{
			Student st = new Student();
			st.setStid(rs.getInt(1));
			st.setStname(rs.getString(2));
			list.add(st);
		}
		return list;
		
	}

}

RowMapperTest.java:
```````````````````
package com.techm;

import java.sql.ResultSet;
import java.sql.SQLException;

import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.jdbc.core.RowMapper;

public class RowMapperTest implements  RowMapper<Student> {

	public Student mapRow(ResultSet rs, int rowNum) throws SQLException {

           Student st= new Student();
           st.setStid(rs.getInt(1));
           st.setStname(rs.getString(2));
           
           return st;
		
	}

	

}

App.java:
``````````
package com.techm;

import java.util.List;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

import com.techm.config.MyConfig;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
      ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class);
      
     StudentDao dao =  context.getBean(StudentDao.class);
     
      //int x = dao.saveStudent(new Student(102,"lakshmi"));
      
     // System.out.println(x + "row(s) inserted");
     
//     List<Student> allStudents = dao.getAllEmployeesRowMapper();
//     
//     for(Student st: allStudents)
//     {
//    	 System.out.println(st.getStid() + " " + st.getStname());
//     }
     
       List<Student> studentsList = dao.getAllStudents();
       
       
       for(Student st:studentsList)
       {
    	   System.out.println(st.getStid() + "" + st.getStname());
       }
       
       System.out.println("using rowmapper ");
       
       List<Student> students = dao.getAllEmployeesRowMapper();
       
       for(Student st:students)
       {
    	   System.out.println(st.getStid() + " " + st.getStname());
       }
       
       
       
       
       
       
    }
}


 
 ResultSetExtractor vs RowMapper:
 `````````````````````````````````
Key Differences
Abstraction Level:

RowMapper works on a single row at a time, making it simpler and more focused on converting individual rows to Java objects.
ResultSetExtractor works on the entire ResultSet, providing more flexibility for complex data extraction and processing.
Use Case Complexity:

Use RowMapper for straightforward mappings of each row to an object.
Use ResultSetExtractor for complex logic involving multiple rows or when additional processing across rows is needed.
Integration with JdbcTemplate:

RowMapper is often used with the query method that directly maps rows.
ResultSetExtractor is used with the query method for cases requiring custom result set processing.
In summary, choose RowMapper for simple row-to-object mappings and ResultSetExtractor for more complex result set processing needs


orm:

  object relational mapping
  
  
 many orm tools are available in the market 
 
 hibernate:
 `````````
 hibernate is a java framework that simplicfies the development of java application to interact with the database. 
 
 it is an open source,lightweight,orm tool.
 
 Hibernate implements the specifications of JPA(java persistence api) for 
 data persistence.
 
 what is jpa:
 java persistence api is a java specification taht provides certain 
 functionality and standard to orm tools. 
 
 The javax.persistence package contains the jpa classes and interfaces.
 
 
 
 advantages of hibernate f/w:
 
 open source and lightweigt
 
 fast performance
 
 database indpedent query
 
 
 HQL is the object oriented version of sql.
 It generates the database independent queries. so you don't need to write 
 database specific queries. 
 
 Before Hibernate, if database is changed for the project, we need to change
 the SQL query as well that leads to the maintainence problem.
 
 
 Automatic table creation:
 
 Hibernate framework provides the facility to create the tables of the 
 database automatically so there is no need to create tables in the 
 database manually.
 
 simplifies complex join
 
  fetching the data from multiple tables is easy in hibernate framework.
  
  
 hibernate architecture:
 
 
       ->java application layer 
	   
	   -> Hibernate framework layer
	   
	   ->Bakcend api layer 
	   
	   ->Database layer
	   
	   
App.java:
``````````
package com.techm;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.boot.Metadata;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistry;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;


/**
 * Hello world!
 *
 */
public class App 
{
	public static void main(String[] args) {
		
		StandardServiceRegistry ssr = new StandardServiceRegistryBuilder().configure("hibernate.cfg.xml").build();

		Metadata meta = new MetadataSources(ssr).getMetadataBuilder().build();

		SessionFactory factory = meta.getSessionFactoryBuilder().build();

		Session session = factory.openSession();
		
		Transaction t = session.beginTransaction();
		
		
		Student e = new Student();
		e.setStid(101);
		e.setStname("sailaja");
		
		
		session.save(e);
		
		t.commit();
		System.out.println("successfully saved");
		
		factory.close();
		session.close();
		
	}
}

Student.java:
`````````````
package com.techm;

import javax.persistence.Entity;
import javax.persistence.Id;

@Entity

public class Student {
	
	@Id
	private int stid;
	
	
	private String stname;
	
	
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	public Student(int stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	
	public Student()
	{
		
	}

}

hibernate.cfg.xml:
`````````````````
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE hibernate-configuration SYSTEM 
"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>


<session-factory>

       <!-- data base properties -->
		<property name="connection.driver_class">com.mysql.cj.jdbc.Driver</property>
		<property name="connection.url">jdbc:mysql://localhost:3306/sys</property>
		<property name="connection.username">root</property>
		<property name="connection.password">root</property>

		<!-- hibernate properties -->
		<property name="dialect">org.hibernate.dialect.MySQL8Dialect</property>
		<property name="show_sql">true</property>
		<property name="format_sql">true</property>
		<property name="hbm2ddl.auto">update</property>

		<!-- mapping file -->
		<mapping class="com.techm.Student" />
</session-factory>


</hibernate-configuration>

 
without hibernate.cfg.xml:
````````````````````````````
package com.techm;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.boot.Metadata;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistry;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;


/**
 * Hello world!
 *
 */
public class App 
{
	public static void main(String[] args) {
		
		

		Session session = HibernateUtil.getSessionFactory().openSession();
		
		Transaction t = session.beginTransaction();
		
		
		Student e = new Student();
		e.setStid(103);
		e.setStname("kushvanth");
		
		
		session.save(e);
		
		t.commit();
		System.out.println("successfully saved");
		
		//factory.close();
		session.close();
		
	}
}


HibernateUtil.java(alternative for hibernate.cfg.xml):
```````````````````` ``````````````````````````````````
package com.techm;

import org.hibernate.SessionFactory;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.cfg.Configuration;
import org.hibernate.service.ServiceRegistry;

public class HibernateUtil {
	
	private static SessionFactory sessionFactory;
	
	static
	{
		try {
			
			Configuration configuration = new Configuration();
			configuration.addAnnotatedClass(Student.class);
			//Database configuration 
			configuration.setProperty("hibernate.connection.driver_class", "com.mysql.cj.jdbc.Driver");
			configuration.setProperty("hibernate.connection.url", "jdbc:mysql://localhost:3306/sys");
			configuration.setProperty("hibernate.connection.username", "root");
			configuration.setProperty("hibernate.connection.password", "root");
			configuration.setProperty("hibernate.dialect", "org.hibernate.dialect.MySQL8Dialect");
			configuration.setProperty("hibernate.hbm2ddl.auto", "update");
			configuration.setProperty("hibernate.show_sql", "true");
			
			//Build session factory
			ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().applySettings(configuration.getProperties())
.build();
			sessionFactory = configuration.buildSessionFactory(serviceRegistry);
			
		}
		catch(Throwable ex) {
			throw new ExceptionInInitializerError(ex);
		}
	}
	
	public static SessionFactory getSessionFactory()
	{
		return sessionFactory;
	}

	public static void shutdown()
	{
		getSessionFactory().close();
	}
}

 
 how to fetch the data in hibernate:
 ````````````````````````````````````````
 package com.techm;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.boot.Metadata;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistry;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;


/**
 * Hello world!
 *
 */
public class App 
{
	public static void main(String[] args) {
		
		

		Session session = HibernateUtil.getSessionFactory().openSession();
		
		Transaction t = session.beginTransaction();
		
		
		/*
		 * Student e = new Student(); e.setStid(103); e.setStname("kushvanth");
		 * 
		 * 
		 * session.save(e);
		 * 
		 * t.commit(); System.out.println("successfully saved");
		 */
		//factory.close();
		Student student = session.get(Student.class, 103);
		
		System.out.println("retrieved student is : " + student.getStname());
		session.close();
		
	}
}


spring orm module:
`````````````````
  hibernate + spring 
  
  1.abstraction and simplification 
  2.integration with spring ecosystem 
  3.transaction management
  4.declarative configuration 
       supports configuration through xml or java annotations, 
	   which can simplify and centralize configuration management.
	   
  5.vendor independence
     
  6.resource management
  7.data access exception translation 
  8.support for advanced features
  
 
 Student.java:
 `````````````
 package com.techm;

import javax.persistence.Entity;
import javax.persistence.Id;

@Entity
public class Student {
	
	@Id
	private int stid;
	
	
	private String stname;


	public int getStid() {
		return stid;
	}


	public void setStid(int stid) {
		this.stid = stid;
	}


	public String getStname() {
		return stname;
	}


	public void setStname(String stname) {
		this.stname = stname;
	}


	public Student(int stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	public Student()
	{
		
	}

}

StudentDao.java:
````````````````
package com.techm;


import org.springframework.orm.hibernate5.HibernateTemplate;
import org.springframework.transaction.annotation.Transactional;

public class StudentDao {
	
	
	private HibernateTemplate hibernateTemplate;

	public HibernateTemplate getHibernateTemplate() {
		return hibernateTemplate;
	}

	public void setHibernateTemplate(HibernateTemplate hibernateTemplate) {
		this.hibernateTemplate = hibernateTemplate;
	}
	
	@Transactional
	public int saveStudent(Student student)
	{
		return (Integer) hibernateTemplate.save(student);
	}

}

App.java:
`````````
package com.techm;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
        
    	
    	ApplicationContext context = new ClassPathXmlApplicationContext("spring.xml");
    	
    	StudentDao dao  = context.getBean(StudentDao.class);
    	
    
    	Student obj = new Student();
    	obj.setStid(200);
    	obj.setStname("venkat");
    	
    	int x = dao.saveStudent(obj);
    	System.out.println(x + "row(s) inserted");
    	
    }
}

spring.xml:
```````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd  
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd">

    <context:component-scan base-package="com.techm"/>
    <tx:annotation-driven/>
	<bean id="dao" class="com.techm.StudentDao">

		<property name="hibernateTemplate" ref="template" />
	</bean>

	<bean id="template"
		class="org.springframework.orm.hibernate5.HibernateTemplate">

		<property name="sessionFactory" ref="factory" />

	</bean>

	<bean id="factory"
		class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">


		<property name="dataSource" ref="ds" />
		<property name="annotatedClasses">
			<list>
				<value>com.techm.Student</value>
			</list>
		</property>
		<property name="hibernateProperties">

			<props>
				<prop key="hibernate.dialect">org.hibernate.dialect.MySQL8Dialect</prop>
				<prop key="hibernate.hbm2ddl.auto">update</prop>
				<prop key="hibernate.show_sql">true</prop>
				<prop key="hibernate.format_sql">true</prop>

			</props>

		</property>

	</bean>
	<bean id="ds"
		class="org.springframework.jdbc.datasource.DriverManagerDataSource">


		<property name="driverClassName"
			value="com.mysql.cj.jdbc.Driver" />
		<property name="url" value="jdbc:mysql://localhost:3306/sys" />
		<property name="username" value="root" />
		<property name="password" value="root" />
	</bean>

	<bean
		class="org.springframework.orm.hibernate5.HibernateTransactionManager"
		name="transactionManager">

		<property name="sessionFactory" ref="factory" />

	</bean>

</beans>

assignment:
redefine the same appliction w.r.to java based configuration 


App.java:
``````````
package com.techm;

import java.util.List;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
        
    	
    	ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class);
    	
    	StudentDao dao  = context.getBean(StudentDao.class);
    	
    
    	Student obj = new Student();
    	obj.setStid(201);
    	obj.setStname("guru");
    	
    	//int x = dao.saveStudent(obj);
    	//System.out.println(x + "row(s) inserted");
    	
    	List<Student> students = dao.listStudents();
    	
    	for(Student s:students)
    	{
    		System.out.println(s.getStid() + " " + s.getStname());
    	}
   	
    	
    }
}

 
MyConfig.java:
```````````````
package com.techm;


import java.util.Properties;

import javax.sql.DataSource;

import org.hibernate.SessionFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.datasource.DriverManagerDataSource;
import org.springframework.orm.hibernate5.HibernateTemplate;
import org.springframework.orm.hibernate5.HibernateTransactionManager;
import org.springframework.orm.hibernate5.LocalSessionFactoryBean;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@Configuration
@EnableTransactionManagement
@ComponentScan(basePackages = "com.techm")
public class MyConfig {

	
	
	
	
	
    @Bean
    public DataSource dataSource() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://localhost:3306/sys");
        dataSource.setUsername("root");
        dataSource.setPassword("root");
        return dataSource;
    }

    @Bean
    public LocalSessionFactoryBean sessionFactory() {
        LocalSessionFactoryBean sessionFactory = new LocalSessionFactoryBean();
        sessionFactory.setDataSource(dataSource());
        sessionFactory.setPackagesToScan("com.techm");
        sessionFactory.setHibernateProperties(hibernateProperties());
        return sessionFactory;
    }

    private Properties hibernateProperties() {
        Properties properties = new Properties();
        properties.put("hibernate.dialect", "org.hibernate.dialect.MySQL5Dialect");
        properties.put("hibernate.show_sql", "true");
        properties.put("hibernate.hbm2ddl.auto", "update");
        return properties;
    }

    @Bean
    public HibernateTransactionManager transactionManager(SessionFactory sessionFactory) {
        HibernateTransactionManager transactionManager = new HibernateTransactionManager();
        transactionManager.setSessionFactory(sessionFactory);
        return transactionManager;
    }

    @Bean
    public HibernateTemplate hibernateTemplate(SessionFactory sessionFactory) {
        return new HibernateTemplate(sessionFactory);
    }
}

Student.java:
``````````````
package com.techm;

import javax.persistence.Entity;
import javax.persistence.Id;

@Entity
public class Student {
	
	@Id
	private int stid;
	
	
	private String stname;


	public int getStid() {
		return stid;
	}


	public void setStid(int stid) {
		this.stid = stid;
	}


	public String getStname() {
		return stname;
	}


	public void setStname(String stname) {
		this.stname = stname;
	}


	public Student(int stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	public Student()
	{
		
	}

}

StudentDao.java:
`````````````````
package com.techm;


import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.orm.hibernate5.HibernateTemplate;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

@Repository
public class StudentDao {
	
	@Autowired
	private HibernateTemplate hibernateTemplate;

	public HibernateTemplate getHibernateTemplate() {
		return hibernateTemplate;
	}

	public void setHibernateTemplate(HibernateTemplate hibernateTemplate) {
		this.hibernateTemplate = hibernateTemplate;
	}
	
	@Transactional
	public int saveStudent(Student student)
	{
		return (Integer) hibernateTemplate.save(student);
	}

	 @Transactional
	    public List<Student> listStudents() {
	        return hibernateTemplate.loadAll(Student.class);
	    }
}


 
spring mvc module:
``````````````````
using spring mvc module -> web applications 

   mvc 
     model view controller 
	 
	 
 
 spring-servlet.xml:
 ```````````````````
 <?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:mvc="http://www.springframework.org/schema/mvc"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans     
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc 
        http://www.springframework.org/schema/mvc/spring-mvc.xsd
        http://www.springframework.org/schema/context 
        http://www.springframework.org/schema/context/spring-context.xsd">
        
  
  <context:component-scan base-package="com.techm.controller" />
  <bean class=
      "org.springframework.web.servlet.view.InternalResourceViewResolver">
    <property name="prefix" value="/WEB-INF/views/" />
    <property name="suffix" value=".jsp" />
  </bean>
</beans>


<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>5.3.19</version>
</dependency>
    
  </dependencies>
  <build>
    <finalName>springmvcdemo1</finalName>
    <plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-war-plugin</artifactId>
				<version>3.3.1</version>
			</plugin>
		</plugins>
  </build>
 
 
WelcomeController.java:
``````````````````````
package com.techm.controller;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

@Controller
public class WelcomeController {

	@RequestMapping("/display")
	public ModelAndView welcome()
	{
		ModelAndView mv = new ModelAndView();
		mv.setViewName("welcome");
		return mv;
	}
}

pom.xml:
````````
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>5.3.19</version>
</dependency>

  </dependencies>
  <build>
    <finalName>springmvc-demo</finalName>
    <plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-war-plugin</artifactId>
				<version>3.3.1</version>
			</plugin>
		</plugins>
  </build>
  </project>
  
  
 web.xml:
``````````
<!DOCTYPE web-app PUBLIC
 "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
 "http://java.sun.com/dtd/web-app_2_3.dtd" >

<web-app>
	<display-name>Archetype Created Web Application</display-name>

	<servlet>
		<servlet-name>spring</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>

	</servlet>

	<servlet-mapping>

		<servlet-name>spring</servlet-name>
		<url-pattern>/</url-pattern>
	</servlet-mapping>
</web-app>

 welcome.jsp:
 ```````````
 <%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
<h1>welcome to spring-mvc module</h1>
</body>
</html>

  
how to add the model data and make it displayed in view:
`````````````````````````````````````````````````````````
package com.techm.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

import com.techm.model.Student;

@Controller
public class StudentController {

	@RequestMapping("/student")
	public ModelAndView getStudentData()
	{
		ModelAndView mv = new ModelAndView();
		Student obj = new Student();
		obj.setStid(100);
		obj.setStname("Kushvanth");
		
		mv.addObject("x", obj);
		mv.setViewName("welcome");
		
		return mv;
		
	}
}

Student.java:
`````````````
package com.techm.model;

public class Student {
	
	private int stid;
	private String stname;
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	
	public Student()
	{
		
	}
	
	public String toString()
	{
		return stid + " " + stname;
		
	}

}

welcome.jsp:
````````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"
    import="com.techm.model.Student"
    isELIgnored="false"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
<h1>welcome to spring-mvc module</h1>
<br/>
<%-- 
<%
Student student = (Student)request.getAttribute("x");
out.println(student);
%>
--%>

${x}
</body>
</html>

 
 how to send the control from controller to view and viceversa:
 ````````````````````````````````````````````````````````````````
 RegistrationController.java:
 ````````````````````````````
 package com.techm.controller;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.servlet.ModelAndView;

import com.techm.model.Student;

@Controller
public class RegistrationController {

	@RequestMapping(method = RequestMethod.GET,value="/showpage")
	public ModelAndView showPage()
	{
		ModelAndView mv = new ModelAndView();
		mv.setViewName("showreg");
		
		return mv;
	}
	
	@RequestMapping(method=RequestMethod.POST,value="/registration")
	public ModelAndView getRegistration(HttpServletRequest req, HttpServletResponse res)
	{
		
		int stid = Integer.parseInt(reqshow.getParameter("stid"));
		String stname = req.getParameter("stname");
		
		Student student = new Student();
		student.setStid(stid);
		student.setStname(stname);
		
		ModelAndView mv = new ModelAndView();
		mv.addObject("stu", student);
		
		mv.setViewName("success");
		
		return mv;
		
		
		
	}
	
}

showreg.jsp:
`````````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>


<form action="registration" method="post">

Enter student id: <input type="text" name="stid"/><br/>
Enter student name: <input type="text" name="stname"/><br/>
<input type="submit" value="register"/>


</form>

</body>
</html>

success.jsp:
```````````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"
    isELIgnored="false"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
Student Records are: <br/>
${stu}

</body>
</html>
 
 
using @RequestParam annotation:
`````````````````````````````````
@RequestMapping(method=RequestMethod.POST,value="/registration")
	public ModelAndView getRegistration(@RequestParam("stid") Integer stid, @RequestParam("stname") String stname)
	{

		Student student = new Student();
		student.setStid(stid);
		student.setStname(stname);
		
		ModelAndView mv = new ModelAndView();
		mv.addObject("stu", student);
		
		mv.setViewName("success");
		
		return mv;
		
		
		
	}
 
using @ModelAttribute:
`````````````````````
@RequestMapping(method=RequestMethod.POST,value="/registration")
	public ModelAndView getRegistration(@ModelAttribute("student") Student student)
	{
		ModelAndView mv = new ModelAndView();
		mv.addObject("stu", student);
		
		mv.setViewName("success");
		
		return mv;
	
	}
	


@GetMapping("/showpage")
	
	
@RequestMapping(method = RequestMethod.GET,value="/showpage")

@PostMapping("/registration")

@PutMapping

@DeleteMapping


spring mvc + orm(hibernate):
``````````````````````````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>

<h1>Student Registration Application</h1>
<form action="registration" method="post">


Enter student name: <input type="text" name="stname"/><br/>
<input type="submit" value="register"/>


</form>

</body>
</html>

StudentController.java:
`````````````````````````
package com.techm.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.servlet.ModelAndView;

import com.techm.entity.Student;
import com.techm.service.StudentService;

@Controller
public class StudentController {

	@Autowired
	private StudentService studentService;
	
	@GetMapping("/showpage")
	
	@RequestMapping(method = RequestMethod.GET,value="/showpage")
	public ModelAndView getForm()
	{
		ModelAndView mv = new ModelAndView();
		mv.setViewName("showreg");
		return mv;
	}
	
	
	
	@PostMapping("/registration")
	public ModelAndView addStudent(@ModelAttribute("student") Student student)
	{
		int x = studentService.saveStudent(student);
		ModelAndView mv = new ModelAndView();
		mv.addObject("student", x);
		mv.setViewName("success");
		return mv;
	}
	
}

MyConfig.java:
```````````````
package com.techm.config;




import java.util.Properties;

import javax.sql.DataSource;

import org.hibernate.SessionFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.datasource.DriverManagerDataSource;
import org.springframework.orm.hibernate5.HibernateTemplate;
import org.springframework.orm.hibernate5.HibernateTransactionManager;
import org.springframework.orm.hibernate5.LocalSessionFactoryBean;
import org.springframework.transaction.annotation.EnableTransactionManagement;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.view.InternalResourceViewResolver;

@Configuration
@EnableTransactionManagement
@EnableWebMvc
@ComponentScan(basePackages = "com.techm")
public class MyConfig {


	
	
    @Bean
    public DataSource dataSource() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://localhost:3306/sys");
        dataSource.setUsername("root");
        dataSource.setPassword("root");
        return dataSource;
    }

    @Bean
    public LocalSessionFactoryBean sessionFactory() {
        LocalSessionFactoryBean sessionFactory = new LocalSessionFactoryBean();
        sessionFactory.setDataSource(dataSource());
        sessionFactory.setPackagesToScan("com.techm");
        sessionFactory.setHibernateProperties(hibernateProperties());
        return sessionFactory;
    }

    private Properties hibernateProperties() {
        Properties properties = new Properties();
        properties.put("hibernate.dialect", "org.hibernate.dialect.MySQL5Dialect");
        properties.put("hibernate.show_sql", "true");
        properties.put("hibernate.hbm2ddl.auto", "update");
        return properties;
    }

    @Bean
    public HibernateTransactionManager transactionManager(SessionFactory sessionFactory) {
        HibernateTransactionManager transactionManager = new HibernateTransactionManager();
        transactionManager.setSessionFactory(sessionFactory);
        return transactionManager;
    }

    @Bean
    public HibernateTemplate hibernateTemplate(SessionFactory sessionFactory) {
        return new HibernateTemplate(sessionFactory);
    }
}


Student.java:
`````````````
package com.techm.entity;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class Student {
	
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private Integer stid;
	
	private String stname;

	public Integer getStid() {
		return stid;
	}

	public void setStid(Integer stid) {
		this.stid = stid;
	}

	public String getStname() {
		return stname;
	}

	public void setStname(String stname) {
		this.stname = stname;
	}
	

}

StudentDao.java:
`````````````
package com.techm.repository;

import com.techm.entity.Student;

public interface StudentDao {
	
	int saveStudent(Student student);

}

StudentDaoImpl.java:
`````````````````````
package com.techm.repository;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.orm.hibernate5.HibernateTemplate;
import org.springframework.stereotype.Repository;

import com.techm.entity.Student;

@Repository
public class StudentDaoImpl implements StudentDao {

	@Autowired
	private HibernateTemplate template;
	
	@Override
	public int saveStudent(Student student) {
		
         return (int) template.save(student);
	}

}

StudentService.java:
````````````````````
package com.techm.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.techm.entity.Student;
import com.techm.repository.StudentDao;

@Service
public class StudentService {
	
	@Autowired
	private StudentDao studentDao;
	
	@Transactional
	public int saveStudent(Student student)
	{
		return studentDao.saveStudent(student);
	}

}

success.jsp:
````````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"
    isELIgnored="false"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
${x}
<br/>
Successfully inserted 

</body>
</html>

spring-servlet.xml:
`````````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:mvc="http://www.springframework.org/schema/mvc"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="
        http://www.springframework.org/schema/beans     
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc 
        http://www.springframework.org/schema/mvc/spring-mvc.xsd
        http://www.springframework.org/schema/context 
        http://www.springframework.org/schema/context/spring-context.xsd">

<context:component-scan base-package="com.techm"></context:component-scan>
<bean id="iv" class="org.springframework.web.servlet.view.InternalResourceViewResolver">

<property name="prefix" value="/WEB-INF/views/"></property>
<property name="suffix" value=".jsp"></property>

</bean>


</beans>

web.xml:
```````````
<!DOCTYPE web-app PUBLIC
 "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
 "http://java.sun.com/dtd/web-app_2_3.dtd" >


<web-app>
	<display-name>Archetype Created Web Application</display-name>

	<servlet>
		<servlet-name>spring</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>

	</servlet>

	<servlet-mapping>

		<servlet-name>spring</servlet-name>
		<url-pattern>/</url-pattern>
	</servlet-mapping>
</web-app>


the same application without web.xml and spring coniguration file, we can 
reimplement like below

WebInitializer.java:
`````````````````````
package com.techm.config;

import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;

public class WebInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

	@Override
	protected Class<?>[] getRootConfigClasses() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	protected Class<?>[] getServletConfigClasses() {
		// TODO Auto-generated method stub
		return new Class[] {MyConfig.class};
	}

	@Override
	protected String[] getServletMappings() {
		// TODO Auto-generated method stub
		return new String[] {"/"};
	}

}

MyConfig.java:
````````````````
package com.techm.config;




import java.util.Properties;

import javax.sql.DataSource;

import org.hibernate.SessionFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.datasource.DriverManagerDataSource;
import org.springframework.orm.hibernate5.HibernateTemplate;
import org.springframework.orm.hibernate5.HibernateTransactionManager;
import org.springframework.orm.hibernate5.LocalSessionFactoryBean;
import org.springframework.transaction.annotation.EnableTransactionManagement;
import org.springframework.web.servlet.ViewResolver;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import org.springframework.web.servlet.view.InternalResourceViewResolver;

@Configuration
@EnableTransactionManagement
@EnableWebMvc
@ComponentScan(basePackages = "com.techm")
public class MyConfig implements WebMvcConfigurer{

	@Bean
	public ViewResolver view()
	{
		InternalResourceViewResolver ivr = new InternalResourceViewResolver();
		ivr.setPrefix("/WEB-INF/views/");
		ivr.setSuffix(".jsp");
		return ivr;
	}
	
	
    @Bean
    public DataSource dataSource() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://localhost:3306/sys");
        dataSource.setUsername("root");
        dataSource.setPassword("root");
        return dataSource;
    }

    @Bean
    public LocalSessionFactoryBean sessionFactory() {
        LocalSessionFactoryBean sessionFactory = new LocalSessionFactoryBean();
        sessionFactory.setDataSource(dataSource());
        sessionFactory.setPackagesToScan("com.techm");
        sessionFactory.setHibernateProperties(hibernateProperties());
        return sessionFactory;
    }

    private Properties hibernateProperties() {
        Properties properties = new Properties();
        properties.put("hibernate.dialect", "org.hibernate.dialect.MySQL5Dialect");
        properties.put("hibernate.show_sql", "true");
        properties.put("hibernate.hbm2ddl.auto", "update");
        return properties;
    }

    @Bean
    public HibernateTransactionManager transactionManager(SessionFactory sessionFactory) {
        HibernateTransactionManager transactionManager = new HibernateTransactionManager();
        transactionManager.setSessionFactory(sessionFactory);
        return transactionManager;
    }

    @Bean
    public HibernateTemplate hibernateTemplate(SessionFactory sessionFactory) {
        return new HibernateTemplate(sessionFactory);
    }
}


Hibernate relations:

one to one:
`````````````
package com.techm.entity;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class Student {

	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private int stid;
	private String stname;
	private String grp;
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	public String getGrp() {
		return grp;
	}
	public void setGrp(String grp) {
		this.grp = grp;
	}
	
}

Address.java:
````````````````
package com.techm.entity;

import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToOne;

@Entity
public class Address {

	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private int addid;
	private String place;
	
	@OneToOne(targetEntity = Student.class,cascade = CascadeType.ALL)
	@JoinColumn(name = "student_id",referencedColumnName = "stid")
	private Student parent;
	
	

	public int getAddid() {
		return addid;
	}

	public void setAddid(int addid) {
		this.addid = addid;
	}

	public String getPlace() {
		return place;
	}

	public void setPlace(String place) {
		this.place = place;
	}

	public Student getParent() {
		return parent;
	}

	public void setParent(Student parent) {
		this.parent = parent;
	}
	
	
}

App.java:
````````
package com.techm;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.boot.Metadata;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistry;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;

import com.techm.entity.Address;
import com.techm.entity.Student;

/**
 * Hello world!
 *
 */
public class App 
{
	 public static void main( String[] args )
	    {
	       
	    	StandardServiceRegistry ssr = new StandardServiceRegistryBuilder().configure("hibernate.cfg.xml").build();

			Metadata meta = new MetadataSources(ssr).getMetadataBuilder().build();

			SessionFactory factory = meta.getSessionFactoryBuilder().build();

			Session session = factory.openSession();
			
			Transaction t = session.beginTransaction();
			
			
			Student stu = new Student();
			//stu.setStid(100);
			stu.setStname("rk");
			stu.setGrp("A");
			
			Address address = new Address();
			//address.setAddid(10);
			address.setPlace("hyd");
			address.setParent(stu);
			
			session.save(address);
			
			t.commit();
			System.out.println("successfully saved");
			
			factory.close();
			session.close();
}
}




one to many:
``````````````
 one student many addresses.
 
 1   *
 
 one vendor many customers
 
 
package com.techm.entity;

import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToMany;

@Entity
public class Student {

	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private int stid;
	private String stname;

	@OneToMany(cascade = CascadeType.ALL)
	@JoinColumn(name = "st_id")
	private Set<Address> address;

	public int getStid() {
		return stid;
	}

	public void setStid(int stid) {
		this.stid = stid;
	}

	public String getStname() {
		return stname;
	}

	public void setStname(String stname) {
		this.stname = stname;
	}

	public Set<Address> getAddress() {
		return address;
	}

	public void setAddress(Set<Address> address) {
		this.address = address;
	}

}

Address.java
```````````````
package com.techm.entity;

import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToOne;

@Entity
public class Address {

	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private int addid;
	private String place;
	
	

	public int getAddid() {
		return addid;
	}

	public void setAddid(int addid) {
		this.addid = addid;
	}

	public String getPlace() {
		return place;
	}

	public void setPlace(String place) {
		this.place = place;
	}

	
	
}


App.java:
``````````````
package com.techm;

import java.util.HashSet;
import java.util.Set;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.boot.Metadata;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistry;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;

import com.techm.entity.Address;
import com.techm.entity.Student;

/**
 * Hello world!
 *
 */
public class App 
{
	 public static void main( String[] args )
	    {
	       
	    	StandardServiceRegistry ssr = new StandardServiceRegistryBuilder().configure("hibernate.cfg.xml").build();

			Metadata meta = new MetadataSources(ssr).getMetadataBuilder().build();

			SessionFactory factory = meta.getSessionFactoryBuilder().build();

			Session session = factory.openSession();
			
			Transaction t = session.beginTransaction();
			
			Set<Address> address = new HashSet<Address>();
			
			Address add1 = new Address();
			add1.setPlace("hyd");
			

			Address add2 = new Address();
			add2.setPlace("bnglr");
			
			address.add(add1);
			address.add(add2);
			
			
			Student stu = new Student();
			stu.setStname("rk");
			stu.setAddress(address);
			
			
			
			session.save(stu);
			
			t.commit();
			System.out.println("successfully saved");
			
			factory.close();
			session.close();
}
}

assignments:

you do on same entities and apply 
many to one 
and many to many 

hibernate query language:
Hibernate Query language is an object-orinted query language similar to 
sql but works with hibernate's data objects. 

package com.techm;

import java.util.List;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.boot.Metadata;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistry;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.query.NativeQuery;
import org.hibernate.query.Query;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
       
    	StandardServiceRegistry ssr = new StandardServiceRegistryBuilder().configure("hibernate.cfg.xml").build();

		Metadata meta = new MetadataSources(ssr).getMetadataBuilder().build();

		SessionFactory factory = meta.getSessionFactoryBuilder().build();

		Session session = factory.openSession();
		
		Transaction t = session.beginTransaction();
		
		
		/*
		 * Student stu = new Student(); //stu.setStid(100); stu.setStname("lakshmi");
		 * stu.setGrp("C");
		 * 
		 * Address address = new Address(); //address.setAddid(10);
		 * address.setPlace("Pune"); address.setParent(stu);
		 * 
		 * session.save(address);
		 */
		
		/*
		 *selecting all records
		 * List<Student> lists = session.createQuery("from Student").getResultList();
		 * 
		 * for(Student s:lists) { System.out.println(s.getStid() + " " + s.getStname() +
		 * " " + s.getGrp()); }
		 */
		
		//selecting specific columns
		
		/*
		 * Query query = session.createQuery("select s.stid,s.stname from Student s");
		 * 
		 * List<Object[]> list = query.list();
		 * 
		 * for(Object[] row:list) { Integer stid = (Integer) row[0]; String stname=
		 * (String)row[1];
		 * 
		 * 
		 * System.out.println(stid + " " + stname ); }
		 */
		
		//using where clause
		/*
		 * String hql = "FROM Student s WHERE s.stid=:x"; Query query =
		 * session.createQuery(hql); query.setParameter("x", 10); List<Student> students
		 * = query.list(); for(Student s: students) { System.out.println(s.getStid() +
		 * " " + s.getStname() + " " + s.getGrp()); }
		 */
		
		
		//deleting records
		
		/*
		 * String hql = "DELETE FROM Student s WHERE s.stid=:x"; Query query =
		 * session.createQuery(hql); query.setParameter("x", 8); int result =
		 * query.executeUpdate(); System.out.println(result + "row(s) deleted");
		 * t.commit();
		 */
		//System.out.println("successfully saved");
		
		
		String sql = "select * from student";
		NativeQuery query = session.createSQLQuery(sql);
		query.addEntity(Student.class);
		
		List<Student> students = query.list();
		
		for(Student st: students)
		{
			System.out.println(st.getStid() + " " + st.getStname() + " " + st.getGrp());
		}
		factory.close();
		session.close();
    	
    }
}


springboot:
````````````

spring boot is a framework from the spring ecosystem 
that simplifies the ,configurtion and deployment of spring applications.

It provides a range of tools and featues to streamline the development process, 
enabling developers to create production-ready applications quickly.

key features of springboot:

1.auto configuration 

   automatically configures your application based on the dependencies 
   you have added to the project.
   

2.standalone application: 
  spring boot can create standalone applications that can be run with the 
  java -jar command. 
  
3.embeded servers: comes with embeded server like tomcat,jetty, or undertow 
servers, so you don't need to deploy war files to an external server. 

4.production-ready: includes features such as health checks, metrics, and 
externalized configuration.

5.opinionated defaults: provides a set of default configurations to help you 
get started quickly.

note:
you can create a springboot project using spring initializer.
(https://start.spring.io)


basic application:
```````````````````
package com.techm;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SpringbootDemoApplication implements CommandLineRunner {

	public static void main(String[] args) {
		SpringApplication.run(SpringbootDemoApplication.class, args);
	}

	@Override
	public void run(String... args) throws Exception {
	
		System.out.println("welcome to springboot");
		
	}

}


@SpringBootApplication:
``````````````````````
This annotation indicates a spring boot application. 
It combines @Configuration, @EnableAutoConfiguation and @ComponentScan 
annotations with their default attributes.

package com.techm.controller;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.ModelAndView;

@RestController
@RequestMapping("/api")
public class WelcomeController {
	
	//@GetMapping("/welcome")
	
	/*
	 * @RequestMapping(method = RequestMethod.GET,value="/welcome") public String
	 * welcome() { return "welcome to springboot"; }
	 */
	
	@RequestMapping(method = RequestMethod.GET,value="/display")
	public ModelAndView welcome1()
	{
		ModelAndView mv = new ModelAndView();
		mv.setViewName("display");
		
		return mv;
	}

}

application.properties:
`````````````````````````
spring.application.name=springboot-demo
server.port=9090
spring.mvc.view.prefix=/META-INF/views/
spring.mvc.view.suffix=.jsp


 note: 
    while you are running you should give following url format
	
	 http://localhost:portnumber/requestedurlpattern 
	 
	 http://localhost:9090/welcome 
	 
	 
	 spring jdbc

springboot + jdbc 
```````````````````
package com.techm;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;

import com.techm.model.Student;
import com.techm.repository.StudentDao;

@SpringBootApplication
public class SpringbootJdbcDemoApplication {

	public static void main(String[] args) {
		ApplicationContext context = SpringApplication.run(SpringbootJdbcDemoApplication.class, args);
		
		StudentDao dao = context.getBean(StudentDao.class);
	
		
	    
	    int x = dao.saveStudent();
	    System.out.println(x + "row(s) inserted");
	}

}


Student.java:
``````````````
package com.techm.model;

public class Student {
	
	private int stid;
	private String stname;
	
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	
	public String toString()
	{
		return stid + " " + stname;
	}

}

StudentDao.java:
`````````````````
package com.techm.repository;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import com.techm.model.Student;

@Repository("dao")
public class StudentDao {

	@Autowired
	private JdbcTemplate template;
	
	public int saveStudent() {
		
	return template.update("insert into student values(101,'philip')");
	
		
	}

	
	
}

application.properties:
```````````````````````
spring.datasource.url=jdbc:mysql://localhost:3306/sys
spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver
spring.datasource.username=root
spring.datasource.password=root



springboot+jdbc

springboot+hibernate(assignment)

webservice:

 interoperable communication between two different application(s).
 

 types of webservices:
 
  soap webservices(xml based webservice)
  restful webservices(annotation based webservice)
  
  
  
  
spring rest module 


using springboot how can we  develop restful webservices?

 
StudentController.java:
```````````````````````````
package com.techm.controller;

import java.util.ArrayList;
import java.util.List;

import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.techm.model.Student;

@RestController
@RequestMapping("/api")
public class StudentController {

	@GetMapping("/student")
	public String welcome() {
		return "welcome to springboot restfull webservice";
	}

	@PostMapping("/createstudent")
	public Student createStudent(@RequestBody Student student) {

		return student;
	}
	
	@GetMapping("/student/{stid}/{stname}")
	public Student getStudentByIdAndName(@PathVariable("stid") Integer x,@PathVariable("stname") String y)	
	{
		return new Student(x,y);
	}

	@PutMapping("/student/{stid}")
	public Student updateStudentById(@RequestBody Student student, @PathVariable("stid") Integer x)
	{
		
		return new Student(x, student.getStname());
	}
	
	@DeleteMapping("/student/{stid}")
	public String deleteStudentById(@PathVariable("stid") Integer x)
	{
		return x + "th record deleted ";
	}
	
	@GetMapping("/students")
	public List<Student> getListOfStudents()
	{
		List<Student> lists = new ArrayList<>();
		Student s1 = new Student(100,"philip");
		Student s2 = new Student(101,"kushvanth");
		
		lists.add(s1);
		lists.add(s2);
		
		return lists;
	}
	
}

Student.java:
````````````
package com.techm.model;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data @AllArgsConstructor
public class Student {
	
	private Integer stid;
	private String stname;

}


  
springboot-restfull-mysql-crud application:
``````````````````````````````````````````
StudentController.java:
````````````````````
package com.techm.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.techm.entity.Student;
import com.techm.repository.StudentRepository;
import com.techm.service.StudentService;

@RestController
@RequestMapping("/api")
public class StudentController {

	@Autowired
    private StudentService service;
	
	
	
	@PostMapping("/student")
	public Student createStudent(@RequestBody Student student)
	{
		return service.saveStudent(student);
	}
	
	@GetMapping("/students")
	public List<Student> getAllStudents()
	{
		return service.getStudents();
	}
	
	@GetMapping("/student/{stid}")
	public Student getStudentById(@PathVariable("stid") Integer id)
	{
		return service.getStudentById(id);
	}
	
	@PutMapping("/student/{stid}")
	public Student updateStudentById(@RequestBody Student student,@PathVariable("stid") Integer id)
	{
	
		
		Student updatedStudent = new Student();
		updatedStudent.setStname(student.getStname());
		
		updatedStudent.setStid(id);
		return service.saveStudent(updatedStudent);
		
	}
	
	@DeleteMapping("/student/{stid}")
	public String deleteStudent(@PathVariable("stid") Integer id)
	{
		service.deleteStudentById(id);
		return "record deleted successfully";
	}
	
}

Student.java:
`````````````
package com.techm.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data @AllArgsConstructor @NoArgsConstructor
@Entity
public class Student {
	
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private Integer stid;
	private String stname;

}

StudentService.java:
``````````````````````
package com.techm.service;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.techm.entity.Student;
import com.techm.repository.StudentRepository;

@Service
public class StudentService {
	
	@Autowired
	private StudentRepository repository;
	
	public Student saveStudent(Student student)
	{
		return repository.save(student);
	}

	public List<Student> getStudents() {
		return (List<Student>) repository.findAll();
	}

	public Student getStudentById(Integer id) {
		// TODO Auto-generated method stub
		return repository.findById(id).get();
	}

	public void deleteStudentById(Integer id) {
		repository.deleteById(id);
	}

}

StudentRepository.java:
```````````````````````
package com.techm.repository;

import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import com.techm.entity.Student;

@Repository
public interface StudentRepository extends CrudRepository<Student, Integer>{

}

application.properties:
``````````````````````````
spring.application.name=springboot-restful-mysql-demo
server.port=9090

spring.datasource.url=jdbc:mysql://localhost:3306/sys
spring.datasource.username=root
spring.datasource.password=root
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true


pom.xml:
``````````
  springweb
  springdatajpa
  mysql driver
  springboot dev tools
  lombok
  
  
spring boot validation along with exception handling:
```````````````````````````````````````````````````````

spring boot provides a powerful and flexible way to perform validation using 
java bean validation(jsr 380).

depedencies:
   spring-web
   spring boot starter validation 
   
   

org.springframework.web.bind.MethodArgumentNotValidException


UserController.java:
```````````````````````
package com.techm.controller;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.techm.model.User;

import jakarta.validation.Valid;

@RequestMapping("/api")
@RestController
public class UserController {

	@PostMapping("/user")
	public ResponseEntity<String> createUser(@RequestBody @Valid   User user)
	{
		return new ResponseEntity<String>("User is valid", HttpStatus.CREATED);
	}
	
	
}

ValidationHandler.java:
``````````````````````````
package com.techm.exceptions;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class ValidationHandler {

	
	@ExceptionHandler(MethodArgumentNotValidException.class)
	public ResponseEntity<Map<String,String>> handleValidationExceptions(MethodArgumentNotValidException me)
	{
		
		Map<String,String> errors = new HashMap<>();
		
		List<FieldError> fieldErrors = me.getBindingResult().getFieldErrors();
		
		for(FieldError error: fieldErrors)
		{
			String fieldName= error.getField();
			String errorMessage = error.getDefaultMessage();
			errors.put(fieldName, errorMessage);
		}
		
		return new ResponseEntity<Map<String,String>>(errors,HttpStatus.BAD_REQUEST);
		
	}
	
	
}

User.java:
````````````
package com.techm.model;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data @NoArgsConstructor @AllArgsConstructor
public class User {

	@NotBlank(message = "name is mandatory")
	private String name;
	
	@Email(message = "Email should be valid")
	@NotBlank(message="Email is mandatory")
	private String email;
	
	@Size(min = 8,message = "Password should have atleast 8 characters")
	private String password;
	
}

link to refer on validations:
```````````````````````````````

  https://medium.com/@himani.prasad016/validations-in-spring-boot-e9948aa6286b
  
  
  dependencies:
  
   springboot-web
   springboot-starter-validation
   springboot-dev-tools
   lombok 
   
GlobalExceptionHandler.java:
````````````````````````````
package com.techm.exceptions;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.context.request.WebRequest;

@RestControllerAdvice
public class GlobalExceptionHandler {

	@ExceptionHandler(MethodArgumentNotValidException.class)
	public ResponseEntity<Map<String, String>> handleExceptions(MethodArgumentNotValidException me) {
		Map<String, String> errors = new HashMap<>();

		List<FieldError> fieldErrors = me.getBindingResult().getFieldErrors();

		for (FieldError error : fieldErrors) {
			String fieldName = error.getField();
			String errorMessage = error.getDefaultMessage();
			errors.put(fieldName, errorMessage);
		}

		return new ResponseEntity<Map<String, String>>(errors, HttpStatus.BAD_REQUEST);
	}

	@ExceptionHandler(StudentIdNotFoundException.class)
	public ResponseEntity<?> handleStudentNotFoundException(StudentIdNotFoundException sn, WebRequest req) {
		ErrorDetails errorDetails = new ErrorDetails(HttpStatus.NOT_FOUND.value(), sn.getMessage(),
				req.getDescription(false));
		return new ResponseEntity<>(errorDetails, HttpStatus.NOT_FOUND);

	}
	
	

}


ErrorDetails.java:
````````````````````
package com.techm.exceptions;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data @NoArgsConstructor @AllArgsConstructor
public class ErrorDetails {

	private int statusCode;
    private String message;
    private String details;

}

StudentIdNotFoundException.java:
``````````````````````````````````
package com.techm.exceptions;

public class StudentIdNotFoundException extends Exception {

	
	public StudentIdNotFoundException(String message) {
		super(message);
		
	}
	
	
}


StudentService.java:
``````````````````````
//Student Service application
package com.techm.service;

import java.util.List;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.techm.entity.Student;
import com.techm.exceptions.StudentIdNotFoundException;
import com.techm.repository.StudentRepository;

@Service
public class StudentService {
	
	@Autowired
	private StudentRepository repository;
	
	public Student saveStudent(Student student)
	{
		return repository.save(student);
	}

	public List<Student> getStudents() {
		return (List<Student>) repository.findAll();
	}

	public Student getStudentById(Integer id) throws StudentIdNotFoundException {
		// TODO Auto-generated method stub
		
		Optional<Student> student =  repository.findById(id);
		if(student.isEmpty()) {
			throw new StudentIdNotFoundException("student id not found with : " + id);
		}
		return student.get();
	}

	public void deleteStudentById(Integer id) {
		repository.deleteById(id);
	}

}


 
GIT:
`````

Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.


https://git-scm.com/download/win

intialize your project with git 

  git init
  
  git add .
  
  git commit -m "commited"
  
  git remote add origin https://github.com/somanapalli/git-practice.git
  
  git push -u origin master
  
  
how to work with eclipse and git:
`````````````````````````````````

 GIT:
```
Git is a distributed version control system 
commonly used in software development.

on a project ,how many developer are usually working?



Git is a version control system that allows developers to track changes in 
their code. 


GitHub is a web-based hosting service for git repositories. 
In simple terms, you can use git without Github, but you cannot use 
GitHub without Git.

The git init command creates a new Git repository

The git add command adds a change in the working directory to the 
staging area

task:
i have one project 
i want to upload into my github remote repository?



            single project
			
              teamleader
			  
10 developers are working 


It tracks changes in soure code during software development and allows
multiple developers to collaborate on a project.

Git helps manage and merge different versions of the code 
efficiently.

create one folder and maintain some files in any of your working 
directory 


1.we have to initialize with git

  e:/git-demo/ git init
  
  into your working directory , .git folder will be created
  
2.optional: git status 

   untracked files 
   
3.git add . 
  all files will be moved to staging area
  
 optional: 4.git status
     
5.git commit -m "first-commit"

  all files of your current working directory will be moved to 
  local git repository.
  
  we should maintain github account and login into that using 
  your credentials
  
  create your repository 
  
  you will get one url for your repository
  
6.git remote add origin <repositoryurl>

7.git push -u origin master

just double click on your remote repository , so that you are able to see all the files 
of your current working directory.


  how to configure your git into eclipse:
  
  1.create local repository
  2.right click on the project -> team ->share project
    under repository->select the repository -> finish
    make sure repository should be created 
	
  3.right click on the project -> team 
  ->addto index ->all the files are available in staged changes 
   if not drag the files from unstaged changes to staged changes
   |
    give the commit message
	|
	commit 
	
  4.right click on the project -> remote -> click on push
    it will ask for git hub remote repository url 
	
	give that repository url
	
	click on under source ref 
	
	master branch 
	
	click on addspec
	
	click on next
	it will ask for username and password of your github account 
	
	username: somanapalli 
	password: token value 
	
	instead of giving the password of github account generate token 
	in your github account and use this token instead of password 
	
	 under settings ->developer settings -> generate token 
	 
	 
    click on finish 
	
	
	pushed to remote repository  


java 1.8 features:
``````````````````
1.lambda expressions

2.functional interface

3.str111eam api

4.default methods

5.date and time api

6.optional class


lambda expressions allows you to write anonymous methods.

it provides a clear and concise way to represent a function interface 
using functional programming and they can be used primarily to define the 
inline implementation of a functional interface.

functional interface:

   it contains only single abstract method 
   
   
   Runnable (java.lang)
   
   @FunctionalInterface
   interface Runnable
   {
     public void run();
   }
   

syntax:

  ->it doesn't have any name
  ->it doesn't return any value
  ->it doesn't have any access modifiers
  
  
  ([parameters]) -> body
  
  
  if the body contains more than one statement 
  
  
  ([parameters]) -> {
  
     body
	 
	 }
	 
void sum(int x, int y);



(int x, int y) -> System.out.println(x+y);


(x,y)->System.out.println(x+y);


i1.java:
````````````
package com.techm.java8;

@FunctionalInterface
public interface i1 {
	
	void sum(int x, int y);
	
}

Test1.java:
`````````
package com.techm.java8;

//execution logic class
public class Test1 {

	public static void main(String[] args) {
		
		//runtime polymorphism
		i1 obj = (x,y)->System.out.println("sum is: " + (x+y));
		obj.sum(4, 6);
		
		
	}
}

i1.java:
````````
package com.techm.java8;

@FunctionalInterface
public interface i1 {
	
	int sum(int x, int y);
	
}

Test1.java:
````````````

package com.techm.java8;

//execution logic class
public class Test1 {

	public static void main(String[] args) {
		
		//runtime polymorphism
		i1 obj = (x,y)->x+y;
		System.out.println("sum is: " + obj.sum(4, 6));
		
		
	}
}


lambda expression for Runnable interface:
``````````````````````````````````````````
package com.techm.java8;

public class Test2 {
	
	
	
	public static void main(String[] args) {
		
		Runnable r = ()-> 
		{
			for(int i=1;i<=10;i++)
			{
				System.out.println(i);
				try {
					Thread.sleep(1000);
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		};
		
		Thread t = new Thread(r);
		t.start();
		
	}

}


lambda expression on collection:
````````````````````````````````
package com.techm.java8;

import java.util.TreeSet;

public class Test3 {
	//int compare(T o1, T o2);
	public static void main(String[] args) {
		
		TreeSet<Integer> ts = new TreeSet<>((x,y)->y.compareTo(x));
		
		ts.add(9);
		ts.add(89);
		ts.add(4);
		ts.add(876);
		
		System.out.println(ts);
		
	}

}


note:
if we observe the above program, we passed lambda expression as an arugment 
to the TreeSet constructor 

because TreeSet constructor is expecting Comparator object, where Comparator 
is predefined fucntional interface that's why i am able to replace with lambdaexpression.


package com.techm.java8;

import java.util.TreeSet;

public class Test3 {
	//int compare(T o1, T o2);
	public static void main(String[] args) {
		
		TreeSet<Student> ts = new TreeSet<>((x,y)->x.getStid().compareTo(y.getStid()));
		
		Student st1 = new Student(100,"rama");
		Student st2 = new Student(7,"philip");
		
		ts.add(st1);
		ts.add(st2);
		
		System.out.println(ts);
		
		
	}

}

Student.java:
``````````````
package com.techm.java8;

public class Student {

	private Integer stid;
	private String stname;
	public Integer getStid() {
		return stid;
	}
	public void setStid(Integer stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	public Student(int stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	
	public Student()
	{
		
	}
	public String toString()
	{
		return stid + " " +stname;
	}
}

Predicate with implementation class:
```````````````````````````````````````
all functional interfaces were introduced in java1.8 are available in 
java.util.function 

package com.techm.java8;

import java.util.function.Predicate;

public class Test4 implements Predicate<Integer>{

	@Override
	public boolean test(Integer t) {
		if(t%2==0)
			return true;
		else
			return false;
	}
	
	public static void main(String[] args) {
		
		Test4 obj = new Test4();
		System.out.println(obj.test(44));
	}

}


without implementation class:
`````````````````````````````````
package com.techm.java8;

import java.util.function.Predicate;

public class Test4 {

	//boolean	test(T t)
	
	public static void main(String[] args) {
		
	   Predicate<Integer> p = (x)->x%2==0;
	   
	   System.out.println(p.test(41));
	}

}


requirement:
 hello java8 features
 HELLO JAVA8 FEATURES
 input -string
 output -string
 
 
package com.techm.java8;

import java.util.Scanner;
import java.util.function.Function;

public class Test5  {

	//R apply(T t)
	public static void main(String[] args) {
		
		
		Function<String,Integer> f = (x)->x.length();
		
		Scanner s = new Scanner(System.in);
		System.out.println("enter the input string");
		
		String y = s.next();
		Integer result = f.apply(y);
		System.out.println("length of the given string is: " + result);
		
	}
}


Supplier,
```````````
package com.techm.java8;

import java.util.function.Supplier;

public class Test6 {

	// T get()
	public static void main(String[] args) {
		
		Supplier<Double> randomNumbers = ()->Math.random();
		
		System.out.println("random number is: " +randomNumbers.get());
	}
}

Consumer:
`````````
package com.techm.java8;

import java.util.function.Consumer;

public class Test7 {

	//void accept(T t);
	public static void main(String[] args) {
		
		Consumer<Integer> c = x -> System.out.println(x);
		
		
		for(int i=1;i<=10;i++)
		{
			c.accept(i);
		}
		
		
	}
}



Predicate -> test(T t) returntype: boolean 

Function ->  R apply(T t) returntype: anytype

Supplier -> T get()  returntype: anytype 

Consumer -> void accept(T t) returntype: nothing 


stream api :
```````````
The stream API in java provides more declarative way to work with collections 
of objects. 

It allows you to perform aggregate operations on collections such as 
filtering 
mapping
sorting 
....

Streams are designed to work with lambdas and functional style operations, 
making code more concise and readable.


creating streams:

  collections 
  arrays
  Stream interface methods 
  
  
we can perform mainly two operations on stream api 

1.intermediate operations 
   transform the stream into another stream.
   
   filter
   map
   flatMap
   distinct
   sorted
   
   
   

2.terminal operations 

   produce a result 
   
   collect
   reduce
   min
   max
   count
   etc..
   
once a terminal operation is invoked, the stream is consumed and cannot 
be reused.


   
  without stream api one basic example:
  ``````````````````````````````````````
 package com.techm.streamapi;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Test1 {
	
	public static void main(String[] args) {
		
		List<String> names = Arrays.asList("Philip","Sameera","Kushvanth","Lakshmi","Ibrahim","Srk");
	
		List<String> filteredNames = new ArrayList<>();
		
	    for(String name: names)
	    {
	    	if(name.startsWith("S")) {
	    		filteredNames.add(name);
	    	}
	    }
	    //print the filtered names
	    
	    for(String fn:filteredNames)
	    {
	    	System.out.println(fn);
	    }
		
	}

}



same example with stream api:
`````````````````````````````
package com.techm.streamapi;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class Test2 {
public static void main(String[] args) {
		
		List<String> names = Arrays.asList("Philip","Sameera","Kushvanth","Lakshmi","Ibrahim","Srk");
		
		List<String> filterdNames = names.stream().filter(x->x.startsWith("S")).collect(Collectors.toList());
        System.out.println(filterdNames);
}
}

map():
``````
map() method in the  Stream api is used to transform each element of the stream 
into another element by applying a function. 

sorted():
count()
distinct()
reduce()
flatMap()
etc..


example:
`````````
package com.techm.streamapi;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
//R	apply(T t)
public class Test2 {
public static void main(String[] args) {
		
		List<String> names = Arrays.asList("philip","sameera","kushvanth","lakshmi","ibrahim","srk");
		
		//List<String> filterdNames = names.stream().filter(x->x.startsWith("S")).collect(Collectors.toList());
        //System.out.println(filterdNames);

          /*List<String> upperCaseNames = names.stream().map(x->x.toUpperCase())
          .collect(Collectors.toList());
          
          System.out.println(upperCaseNames);*/
		
		/*Map<String,Integer> ageMap = new HashMap<>();
		
		ageMap.put("philip", 37);
		ageMap.put("rk", 35);
		ageMap.put("sameera", 25);
		ageMap.put("kushvanth", 65);
		
		List<Integer> doubledValues = ageMap.values().stream().map(value -> value*2).collect(Collectors.toList());
      System.out.println(doubledValues);
      
     List<String> keys=  ageMap.keySet().stream().map(p->p.toUpperCase()).collect(Collectors.toList());
     System.out.println(keys);*/
		
		
		/*List<String> sortedNames = names.stream().sorted().collect(Collectors.toList());
     System.out.println(sortedNames);*/
		
		List<String> sortedNames = names.stream().sorted((x,y)->y.compareTo(x)).collect(Collectors.toList());
     System.out.println(sortedNames);
     
     
}
}


default and static methods:

default methods:
default methods are methods in an interface with a default implementation 

interface i1{
   default m1(){
   //common implemenatin 
   }
}

they allow adding new methods to interfaces without breaking existing 
implementations.

interface Vehicle
{
   void start();
   default void stop()
   {
    System.out.println("Vehicle stopped");
	}
}

class Car implements Vehicle
{
  public void start()
  {
    System.out.println("Car started");
	}
}



static methods:

static methods in interfaces are similar to startic methods in classes. 

They are defined with the static keyword and can be called using the 
interface name. 



Vehicle.java:
```````````````
package com.techm.default_static;

public interface Vehicle {
	

	void start();
	default void stop()
	{
		System.out.println("vehicle stopped");
		
	}
	static void welcome()
	{
		System.out.println("welcome to static methods inside an interface");
	}
}

Car.java:
`````````
package com.techm.default_static;

public class Car implements Vehicle{

	@Override
	public void start() {
		System.out.println("car started");
		
	}

}

Test1.java:
``````````
package com.techm.default_static;

public class Test1 {

	public static void main(String[] args) {
		
		Vehicle v = new Car();
		v.start();
		v.stop();
		Vehicle.welcome();
	}
}

i1.java:
`````````
package com.techm.default_static;

public interface i1 {
	
	public static void main(String[] args) {
		
		System.out.println("welcome");
	}

}


method reference example:
``````````````````````````
package com.techm.methodreference;

import java.util.Arrays;
import java.util.List;

public class ForEachExample {
	
	public static void main(String[] args) {
		
		List<String> names = Arrays.asList("John","Jane","Doe","Alice");
		
		//without method reference
		System.out.println("using lambda expression ");
		names.forEach(name -> System.out.println(name));
		
		//with method reference
		
		System.out.println("using method reference");
		names.forEach(System.out::println);
		
	}

}

spring security:
````````````````


localhost:9090/api/welcome 

   username:
   password: 
   
   

  -response
  

->we should add one extra dependency for our application 


dependency:
`````````````
 <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
	
	
default credentials:

  user: user
  password: 
  
  it will be generated that we can take it from console when you execute 
  your application 
  
to configure our own user credentials like username and password 
open  application.properties file and give like below 

spring.security.user.name=rk
spring.security.user.password=Techm@143



--------------------------------------------------------------------------------------------------
Front end:
`````````
1)HTML: Hyper text mark up language
purpose: To design/create web pages/websites

webpage: A web page is a single document which contains information in differnt formats(websites(urls),images,videos,audios etc..)
website: A website is a collection of webpages.

Hyper text: Info regarding our current website (Hyperlinks)
mark up language: It is a web language to design/create web pages.

programming --> syntax
mark up language---> format of tags.

--> 1) with the extension .htm or .html
--> 2) we need a browser to execute our html pages (Chrome/edge/safari..etc)

Structure of a html document:
````````````````````````````
first.html
``````````
Syntax: <element_name attributes(optional)>Content</element_name>

Attributes: which gives extra info regrading that particular tag

Note: contents can be some text / tags

Eg:  <body> <h1>Head1</h1> </body>
1)<html> </html>--> root tag
   2)<head> --> contains information about our html document
   3)<body> --> body represents the actual contents of our html document.
   
heading tags:
`````````````
<h1></h1>
<h2></h2>
<h3></h3>
<h4></h4>
<h5></h5>
<h6></h6>
<p></p> -->insert more than 1 line(s) of text (it will be in the new line)
<b>--> bolded text
<i> -->Italic tag
<a> --> Anchor tag is used to create hyperlinks ( href-attribute)
<sub> --> To insert subscripted text
 <sup> --> To insert superscripted text 
 <br> or </br> --> break tag used to insert text in new line
 <hr> or </hr> tag --> creates a horizontal solid line 
 <marquee>--> text scrolling purpose
 <img> --> inserting an image to my web page
 <div>contents</div> --> used to create seperate portion(container) in the web page
 

First.html
``````````
<html>
    <head>

    </head>
    <body>
         
        <h2> Intro..!</h2>
        <p> <b>Lorem ipsum</b>dolor sit amet, <mark> consectetur</mark> adipisicing elit. Similique, consequuntur, earum atque voluptate rerum corporis unde enim reprehenderit est possimus eos sed, ratione numquam neque deserunt adipisci libero autem modi?</p>
        </hr>
        <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Voluptates deserunt odit ad cupiditate provident nulla voluptas sunt, explicabo totam illo quidem reiciendis, quibusdam nostrum commodi obcaecati, ab doloremque aliquam odio!</p>
        <b>Bolded text</b>
        </br>
        <i>Italic text</i></br>
        <u>Underlined tag</u>
        <mark>Highlighted text</mark>
        <a href="https://www.google.com" target="_blank">Google</a>
        <p> H <sub> 2 </sub> O <sub>2 </sub></p>
        <p>X <sup> 4 </sup> Y <sup> 2 </sup> </p>

    </body>
</html>


 Based up on display property elements are classified into two types:
 1)Inline elements : side by side
 ex: b,i,strong,small,mark etcc..
 2)Block level elements: line by line(new line)
 Ex: All heading tags(h1 to h6) and <p>
 
 
 Tables in html:
 ```````````````
 <table></table> --> creates a structure of table (root tag)
<th></th> --> table header --> create heading in our table
<tr>Contents</tr> -->	table row --> create a row inside a table
Note: tr--> <td></td>

<td>contents</td>   --> table data	 
Note: contents are actual text

table.html
``````````
<html>
    <head>
       <style>
        table,th,td{
          border: 1px solid black; 
          border-collapse: collapse;
          text-align: center; 
        }
       </style>
    </head>
    <body>
        <table>
            <tr>
                <th>Roll No</th>
                <th>Name</th>
                <th>Age</th>
            </tr>
            <tr>
                <td>1</td>
                <td>Alex</td>
                <td>21</td>
            </tr>
            <tr>
                <td>2</td>
                <td>Vinay</td>
                <td>24</td>
            </tr>
            <tr>
                <td>3</td>
                <td>Sujata</td>
                <td>21</td>
            </tr>
        </table>
    </body>
</html>

Table attributes:
`````````````````````
1)rowspan=used to merge the cells(<td></td>) vertically.
2)colspan=used to merge the cells(<td></td>) horizontally.

Example:
````````
<html>
    <head>
       <style>
        table,th,td{
            border: 1px solid black; 
          border-collapse: collapse;
          text-align: center; 
        }
       </style>
    </head>
    <body>
        <table>
            <tr>
                <th>Roll No</th>
                <th>Name</th>
                <th>Age</th>
                <th>Maths</th>
                <th>Science</th>
            </tr>
            <tr>
                <td>1</td>
                <td>Alex</td>
                <td>21</td>
                <td rowspan="3">95</td>
                <td>98</td>
            </tr>
            <tr>
                <td>2</td>
                <td>Vinay</td>
                <td>24</td>
                <td>96</td>
            </tr>
            <tr>
                <td>3</td>
                <td>Sujata</td>
                <td>21</td>
                <td>97</td>
            </tr>
            <tr>
                <td>4</td>
                <td>Ibrahim</td>
                <td>23</td>
                <td colspan="2">99</td>
            </tr>
        </table>
    </body>
</html>

Image tag:

<img> -- src(attribute)

CSS:
````
Cascading style sheets: It is a styling language used for html pages.
``````````````````````
CSS syntax:
``````````
  properties
  
  prop1: value1,
  prop2: value2,
  prop3: value3,
  .
  .
  .
  .
  propN:valueN
  
we are having totally 3 ways to apply css for our html document.

1)Inline styling  --> with the help of "style" attribute

second.html:
````````````
<html>
    <head></head>
    <body>
        <h1 style="background-color:lightgray ;
                   color: brown;
                   text-align: center;
                   font-family: Georgia, 'Times New Roman', Times, serif;
                   font-size: xx-large;">Intro</h1>
        <P>Lorem ipsum, dolor sit amet consectetur adipisicing elit. Architecto laborum, non dolorem quasi modi eaque facilis eveniet ullam necessitatibus quae, quod consequatur exercitationem illo nulla odit provident, optio vel natus.</P>
    </body>
</html>

2)Internal styling :<style>Contents</style> tag --> inside the <head> tag
Note: Contents are selectors
Selector: A selector is a pattern to identify html elements uniquely and apply css accordingly.
`````````
selector{
  prop1: value1,
  prop2: value2,
  prop3: value3,
  .
  .
  .
  .
  propN:valueN
}

Basic selector:

1) Element selector: directly we can choose with the help of tag name


Element_name{
  prop1: value1,
  prop2: value2,
  prop3: value3,
  .
  .
  .
  .
  propN:valueN
}

2) Grouping selector: (,) we can apply same styles for differnt elements using grouping selector

Element_name1,Element_name2,Element_name3.....Element_nameN{
  prop1: value1,
  prop2: value2,
  prop3: value3,
  .
  .
  .
  .
  propN:valueN
}

Second.html
````````````
html>
    <head>
        <style>
          p{
            background-color: aqua;
            font-family: 'Courier New', Courier, monospace;
          }
          h2,h3{
            color: black;
            background-color: antiquewhite;
            text-align: center;
          }
        </style>
    </head>
    <body>
        <h1 style="background-color:lightgray ;
                   color: brown;
                   text-align: center;
                   font-family: Georgia, 'Times New Roman', Times, serif;
                   font-size: xx-large;">Intro</h1>
        <h2>Header2</h2>
        <h3>Header3</h3>
        <p>Lorem ipsum, dolor sit amet consectetur adipisicing elit. Architecto laborum, non dolorem quasi modi eaque facilis eveniet ullam necessitatibus quae, quod consequatur exercitationem illo nulla odit provident, optio vel natus.</P>
    </body>
</html>

3) Id selector: (#) and an attribute called 'id'

#id_value{
  prop1: value1,
  prop2: value2,
  prop3: value3,
  .
  .
  .
  .
  propN:valueN
}

4) Class selector: (.) with an attribute called 'class'

.class_value{
  prop1: value1,
  prop2: value2,
  prop3: value3,
  .
  .
  .
  .
  propN:valueN
}

5)Universal selector: (*)
*
{
 prop1: value1,
  prop2: value2,
  prop3: value3,
  .
  .
  .
  .
  propN:valueN
}
Example:

<html>
    <head>
        <style>
            *
            {
                background-color: lightgrey;
                color: greenyellow;
            }
        </style>
    </head>
    <body>
        <h1>Header1</h1>
        <h2>Header2</h2>
        <h3>Header3</h3>
        <h4>Header4</h4>
        Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tenetur illum a vero. Impedit, iste quo quasi tenetur iusto libero, ex sapiente cupiditate adipisci similique eos perferendis veniam amet! Suscipit, porro.
    </body>
</html>



Third.html:
``````````
Box Model(contents,padding,border,margin):

<html>
    <head>
        <style>
            div
            {
                border: 1px solid black;
                text-align: center;
                margin:20px;
                padding: 50px;
            }
            h1{
                border: 1px solid black;
                text-align: center; 
            }
        </style>
    </head>
    <body>
       <div>
        <img src="C:\Users\abc\OneDrive\Desktop\Collection-Framework-1.png" height="300px" width="300px">
        <img src="C:\Users\abc\OneDrive\Desktop\Map.jpg"  height="300px" width="300px">
       </div>
       <h1>Header1</h1>
    </body>
</html>

table.html
``````````

<html>
    <head>
       <style>
        table,th,td{
            border: 1px solid black; 
          border-collapse: collapse;
          text-align: center; 
        }
       </style>
    </head>
    <body>
        <marquee>This is a scrolling text</marquee>
        <table>
            <tr>
                <th>Roll No</th>
                <th>Name</th>
                <th>Age</th>
                <th>Maths</th>
                <th>Science</th>
            </tr>
            <tr>
                <td>1</td>
                <td>Alex</td>
                <td>21</td>
                <td rowspan="3">95</td>
                <td>98</td>
            </tr>
            <tr>
                <td>2</td>
                <td>Vinay</td>
                <td>24</td>
                <td>96</td>
            </tr>
            <tr>
                <td>3</td>
                <td>Sujata</td>
                <td>21</td>
                <td>97</td>
            </tr>
            <tr>
                <td>4</td>
                <td>Ibrahim</td>
                <td>23</td>
                <td colspan="2">99</td>
            </tr>
        </table>
        <a href="./first.html">First Page</a><br>
        <a href="./second.html">Second Page</a></br>
        <img src="https://images.pexels.com/photos/56866/garden-rose-red-pink-56866.jpeg" height="300px" width="500px">
    </body>
</html>



   
  3)external styling:
``````````````````
Here we will create a seperate css file and attach with our html document.
extension of the file is .css

<link> tag --> rel and href

Priority:
````````
Inline , Internal & external if <link> tag is before <style> tag

forms:
``````
It is used to collect inputs/info from the end user

<form> -- root tag

forms.html
``````````
<!DOCTYPE html>
<html>
    <head></head>
    <body>
        <div>
            <form>
                <label for="fname">Enter FirstName:</label>
                <input type="text" name="fname"><br>

                <label for="lname">Enter LastName:</label>
                <input type="text" name="lname"><br>

                <label for="age">Enter Age:</label>
                <input type="number" name="age"><br>

                <label for="age">Choose Age:</label>
                <input type="date" name="age"><br>

                <label for="email">Enter email:</label>
                <input type="email" name="email"><br>

                <label for="gender">Choose Gender</label>
                <input type="radio" name="gender"><label>Male</label>
                <input type="radio" name="gender"><label>Female</label><br>

                <label for="city">Choose preferable city:</label>
                <select name="city">
                    <option value="hyd">Hyderabad</option>
                    <option selected value="Vijayawada">Vijayawada</option>
                    <option value="Nellore">Nellore</option>
                    <option value="ongole">Ongole</option>
                </select><br>

                <label for="courses">Choose courses(More than one):</label>
                <input type="checkbox" value="c-programming"><label>c-programming</label>
                <input type="checkbox" value="Java-programming"><label>Java-programming</label>
                <input type="checkbox" value="Python-programming"><label>Python-programming</label>
                <br>

                <label for="file">Upload a file</label>
                <input type="file" name="file" accept="png/jpeg/jpg/pdf"></br>

                <label for="pwd">Enter password:</label>
                <input type="password" name="pwd"><br>

                <input type="submit">
                <input type="reset">
            </form>
        </div>
    </body>
</html>

Task: Build login/registration pages using html css

Using HTML and CSS we can build static web pages(fixed page(content))-->Display purpose
Ex:Wiki websites on internet

Dynamic web pages:
``````````````````
opposite to static pages(Content can be changed at runtime)
Ex: facebook,youtube,etc...many more

Java Script:
```````````

Java script is a scripting language (Client side(end user) programming language).
--> To create dynamic webpages
-->Client side validations
--> Establish a communication b/w user and our web site.

we can embedd js code in our html page directly with the help of <script></script> tag
we can create seperate js file.

variables in js:
```````````````
1) var keyword --> globally
2) let keyword --> local scope(function scope)
3) const keyword --> Constants 

print statements:
`````````````````
1)  console.log()  --> console window
2)  window.alert() or alert()  --> in web page seperate will be created 
3)  document.write() --> in the web page itself


<script>
            var a=5;
            var b=6;
            var c=a+b;
            console.log("Addition of two inputs is "+c);
            alert("Addition of two inputs is "+c);
            document.write("Addition of two inputs is "+c);
</script>

 <script>
           var name= window.prompt("Enter your name");
           alert("Welcome "+name);
</script>

--->Operators

Functions in js:
````````````````
It is a set of statements, purpose is to reuse the block of code(reusability)
1)Function declaration
2)Function defintion
3) Function call(execution)


Event Handling:
```````````````































topics left:

html,css,javascript 
angular concepts 
springboot angular integration 
jenkins











	