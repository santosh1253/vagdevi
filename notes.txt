java

class is a collection of 
variables
methods

variables : purpose to store the data 

 in taht process while we are declarting the variables, 
 we are using datatypes.
 4 categories
 
  8 datatypes (primitive)
  
  byte,
  short,
  int,
  long,
  float,
  double,
  char,
  boolean,
  String -to store series of characters 
  
  
method:
````````
defintion: 
method is the place where we are writing the logic , to perform 
some operation based on the requirement.

syntax:
````````
[accessmodifier] <retuntype> <methodname>([parameters ifany])
{
   //logic 

}


accessmodifier - optional
parameters - optional 


define a method which displays helloworld?

void - java reserved keyword

if a method is not returning any value we should specify the return type 
as 'void'.


void display()
{
  //logic 
  System.out.println("helloword");
}

define a method which returns your gender?

String getGender()
{
return "male";
}

return value is String
return type is also string

both are maatched

note:
if a method retruning something based on that we have to specify return 
keyword in the body of the method. 

return type and return value must be matched or compatible with each other 
otherwise it gives you compiletime error. 


define a method which accepts two integers and display their sum?

void getSum(int x, int y)
{
  System.out.println("sum is: " +(x+y));

}
 
define a method which accepts firstname and lastname as two parameters 
and returns your fullname? 
 
 
 String getFullName(String firstname,String lastname)
 {
   return firstname+lastname;
 }
 
 
define a method which returns you the grade of the student?

 
 char getGrade()
 {
  return 'A';
 }
 
 character value always must be enclosed with in the single quotes.
 
how to declare the variables 

how to define the methods 

class is a colletion of variables and methods into a single unit. 

 
 eclipse 
   -ide integrated development environment 
   -writing the code inside ide is very easy and more flexible 
   -we will have so many benefits 
   -auto compiled 
   
 benefits of writing the code in eclipse ide:

allows setting breakpoints;
automatically validates syntax;
offers a robust debugger;
provides you readymade code template;
robust Java editor;
supports code refactoring;
supports syntax coloring. 
  
  
define a class with the name of Student and try to display student 
information?
 
 
 class Student
 {
    //variables 
	int stid = 100;
	String stname= "ram";
	float stmarks = 99.5f;
	String staddress = "hyd";
	char stgrade = 'A';
	
	//method to display the student information 
	
	public void getStudentInformation()
	{
	 System.out.println("student id is: " + stid);
	 System.out.println("student name is: " + stname);
	 System.out.println("student  marks are : " + stmarks);
	 System.out.println("student address is:" + staddress);
	 System.out.println("student grade is: " + stgrade);
	}

 }
 
 
 execution of the java program starts from main() 
 
 package corejava;

  public class Student {

	   //variables 
		int stid = 100;
		String stname= "ram";
		float stmarks = 99.5f;
		String staddress = "hyd";
		char stgrade = 'A';
		
		//method to display the student information 
		public void getStudentInformation()
		{
		 System.out.println("student id is: " + stid);
		 System.out.println("student name is: " + stname);
		 System.out.println("student  marks are : " + stmarks);
		 System.out.println("student address is:" + staddress);
		 System.out.println("student grade is: " + stgrade);
		}
		
		//defining this main method
		public static void main(String[] args) {
			
			//create the object for Student class 
			
			Student obj = new Student();
			
			//using this object, calling my method getStudentInformation()
			
			obj.getStudentInformation();
			
		}
		
}

 
java is oopl 
  -oops principles

    -inheritance,polymorphism,abstraction,encapsulation 
    -omg(object management group)-canadian organization 

class 
object

object:
````````
object means instance of the class. 
instance means 
allocating sufficient amount of memory space for the non-static /instance variables which 
we declared inside the class. 

	
 for a single class, how many objects we can create?
 
 as many as we want based on the requirement. 
 
Student ramya = new Student();

Student rk = new Student();


 whenever we create the object, memory locations will be created newly.
 object creation is nothing but memory creation only.
 
 stid
 stname
 staddress
 collegename-memory should be created once or 1000 times 
 
 
 1000 students
 
 note:
 to create the memory for static properties object creation is required 
 or not?
 
 not required. 
 
 when memory will be created for the static properties?
 
 at the time of loading class into jvm before object creation 
 
 whenever we create the object, memory will be created for non-static 
 properties.
 
 
 instance vs static:
 
 int a;//instance variables
 static int a;//static variables
 
 void m1()//instance method or non-static method
 {
   //instance area 
 }
 
 static void m1()//static method
 {
   //static area
 }
 
 
 in java, we have two areas are there 
 
 1.instance area is one which belongs to instance method  
 2.static area is one which belongs to static method
 
 
 class Test1{
 static int x = 100;
 
  void m1(){
    //instance area
	System.out.println(Test1.x);
  }
  
}
 
 
 from any area either it is static area or non-static area 
 we can access the static properties in following three possible ways.
 
  1.direct access
  2.using class name 
  3.using object name(not recommended)
  
 from static area, if we want access non-static properties 
 how can we access?
   using object name 
   
 from instance area, if we want access instance properties 
 how can we access?
    direct access is possible.
	
	
example:
```````````

public class Test1 {
	
	static int x = 100;
	//instance variable
	int y = 200;
	
	//non-static method
	public void display()
	{
		//instance area
		//System.out.println(Test1.x);
		//System.out.println(this.x);
		System.out.println(x);
		System.out.println(y);
	}
	
	public static void main(String[] args) {
		
		//static area 
		Test1 obj  = new Test1();
	   obj.display();
		
		System.out.println(obj.y);
		
		
	}

}




constructor:
````````````
<classname> <objectname> = new <classname>();
Student obj = new Student();

definition: 
constructor is a special member method which is used for initializing 
the object 

initializing the object: 
assigning the values to variables 

it is highly recommended to keep initializion logic inside the 
constructor 
rules:
constructor name and class name must be similar.
constructor should not return anything even void also.
constructor should not be inherited
constructor should not be static.



public class Employee {
	
	int empid;
	String empname;
	
	
	//setting the values
	public void setValues() {
		
		empid=100;
		empname="rk";
	}
	
	//display the values
	
	public void displayEmployeeInfo() {
		System.out.println("employee id is:" + empid);
		System.out.println("employee name is:" + empname);
	}
	public static void main(String[] args) {
		
		Employee obj = new Employee();
		
		obj.setValues();
		
		obj.displayEmployeeInfo();
	}

}

using constructor:


public class Employee {
	
	int empid;
	String empname;
	
	//define the constructor 
	public Employee()
	{
		//initialization logic 
		empid=100;
		empname="rama";
	}
	
	
	//display the values
	
	public void displayEmployeeInfo() {
		System.out.println("employee id is:" + empid);
		System.out.println("employee name is:" + empname);
	}
	public static void main(String[] args) {
		
		
		
		Employee obj = new Employee();
		obj.displayEmployeeInfo();
	}

}

		
		
note:
for every java program, one default constructor will be generated by 
the java compiler if we didn't define any constructor inside our java 
program. 

that system defined generated default constructor assigns default values 
based on the datatype of the variables. 



parameterized constructor -constructor which takes parameters
default constructor -> constructor which doeesn't takes any paramters



public class Employee {
	
	int empid;
	String empname;
	
	public Employee(int x, String y)
	{
		empid=x;
		empname=y;
	}
	
	
	//display the values
	
	public void displayEmployeeInfo() {
		System.out.println("employee id is:" + empid);
		System.out.println("employee name is:" + empname);
	}
	public static void main(String[] args) {
		
		Employee obj = new Employee(100,"chandu");
		obj.displayEmployeeInfo();
	}

}

multiple constructors example:
`````````````````````````````````

public class Employee {
	
	int empid;
	String empname;
	
	public Employee(int x, String y)
	{
		empid=x;
		empname=y;
	}
	
	//user defined default constructor
	public Employee()
	{
		empid=200;
		empname="pavan";
	}
	
	
	//display the values
	
	public void displayEmployeeInfo() {
		System.out.println("employee id is:" + empid);
		System.out.println("employee name is:" + empname);
	}
	public static void main(String[] args) {
		
		Employee obj = new Employee(100,"chandu");
		obj.displayEmployeeInfo();
		System.out.println("=============================");
		
		Employee obj1 = new Employee();
		obj1.displayEmployeeInfo();
		
	}

}


note:
constructor calling is from top to bottom but execution starts from 
bottom to top.

note:
we should end the constructor calling chain end somewhere otherwise 
recursive constructor error will get at compiletime.


example of constructor chaining:
```````````````````````````````````

public class Employee {
	
	int empid;
	String empname;
	
	//parameterized constructor
	public Employee(int x, String y)
	{
		
		empid=x;
		empname=y;
		displayEmployeeInfo();
	}
	
	//user defined default constructor
	public Employee()
	{
	  //call the parameterized constructor of current class
		this(100,"rk");
		empid=200;
		empname="pavan";
	}
	
	
	//display the values
	
	public void displayEmployeeInfo() {
		System.out.println("employee id is:" + empid);
		System.out.println("employee name is:" + empname);
	}
	
	public static void main(String[] args) {
		
		Employee obj = new Employee();
		obj.displayEmployeeInfo();
		System.out.println("=============================");
	
	}

}


one more example on this keyword:
``````````````````````````````````

public class Employee {
	//class level variables
	int empid;
	String empname;
	
	//parameterized constructor
	public Employee(int empid, String empname)
	{
		
		this.empid=empid;
		this.empname=empname;
		displayEmployeeInfo();
	}
	
	//user defined default constructor
	public Employee()
	{
		//call the parameterized constructor of current class
		this(100,"rk");
		empid=200;
		empname="pavan";
	}
	
	
	//display the values
	
	public void displayEmployeeInfo() {
		System.out.println("employee id is:" + empid);
		System.out.println("employee name is:" + empname);
	}
	
	public static void main(String[] args) {
		
		Employee obj = new Employee();
		obj.displayEmployeeInfo();
		System.out.println("=============================");
		
	}

}

this keyword:

this is the java reserved keyword, we are using for following two 
purposes. 

1.to differentiate class level variables and method/constructor level paramters
when both are same. 
2.to invoke one constructor from another consturctor(constructor chaining)


note:
constructor call must be the first statement inside the constructor 
otherwise it gives you compiletime error. 

 
 in java, we have one concept 
 control statements :
 control statements are used to manage the flow of execution of the 
 java program .
 
 if
 ifelse
 ifelseif ladder
 switch case
 
 for 
 while 
 dowhile 
 foreach 
 
 break
 continue
 
 
public class Test2 {

	public static void main(String[] args) {

		int x = 101;
		// static area
		if (x%2==0) {
			System.out.println(x + " is even number");
		} else {
			System.out.println(x + " is odd number");
		}

	}
}

example of how can we supply input values to the main method 
and example on parser method:


public class Test2 {

	public static void main(String[] args) {

		int x = Integer.parseInt(args[0]);
		
		// static area
		if (x%2==0) {
			System.out.println(x + " is even number");
		} else {
			System.out.println(x + " is odd number");
		}

	}
}

one more example:
``````````````````

public class Test2 {

	public static void main(String[] args) {

		int x = Integer.parseInt(args[0]);
		int y = Integer.parseInt(args[1]);
		
		
		System.out.println("sum of given two no's is: " +(x+y));
		 

	}
}

example on ifelseif ladder:
``````````````````````````
single if block 
single else block 
multiple else if block(s) are there to check multiple conditions. 
example:
````````

public class Test2 {

	public static void main(String[] args) {

		int score = Integer.parseInt(args[0]);
		
		if(score>=90)
		{
			System.out.println("GRADE A");
		}
		else if(score >=80) {
			System.out.println("Grade B");
		}
		else if(score >= 70) {
			System.out.println("Grade C");
		}
		else if(score >= 60) {
			System.out.println("Grade D");
		}
		else {
			System.out.println("failed");
		}

	}
}


example on switchcase:


public class Test2 {

	public static void main(String[] args) {

		int dayOfWeek = Integer.parseInt(args[0]);
		
		String dayName;
		switch(dayOfWeek) {
		
		case 1:
			dayName="sunday";
			break;
		case 2:
			dayName="Monday";
			break;
		case 3:
			dayName="Tuesday";
			break;
		case 4:
			dayName="Wednesday";
			break;
		case 5:
			dayName="Thirsday";
			break;
		case 6:
			dayName="Friday";
			break;
		case 7:
			dayName="Saturday";
			break;
		default:
			dayName="invalid day";
		
		
		}
		System.out.println("day of the week: " + dayName);
	}
}


looping statements in java:
these are allowed you to repeatedly execute a bloc of code 
executes a bloc of code a specified no.of times


public class Test2 {

	public static void main(String[] args) {

	  for(int i=1;i<=10;i++) {
		
		  if(i%2!=0) {
			  System.out.println(i);
		  }
	  }
	
	}
}

in reverse order using for loop:


public class Test2 {

	public static void main(String[] args) {

	  for(int i=10;i>=1;i--)
	  {
		  System.out.println(i);
	  }
	
	}
}

example on increment & decrement operators:
//demo on post increment&decrement and pre increment and decrement operators
public class Test2 {

	public static void main(String[] args) {

	  int x = 100;
	  System.out.println(x++);//post increment operator
	  System.out.println(x);//101
	  System.out.println(++x);//pre-increment operator-102
	  System.out.println(x--);//post decrement operator-102
	  System.out.println(x);//101
	  System.out.println(--x);//100-pre decrement operator
	  
	}
}



assignment:

display the first 10 numbers in reverse order using while loop 
display the first 10 even numbers using do-while loop

int x=100;
int y=200;
requirement is to store 1crore values 
how many variables we have to declare?
1 crore variables 
readability of the code gets decreased

arrays:
```````
using arrays we can store multiple values of same type.

int x[] ={10,20,30,40};//it is valid 


it supports only homogenious data. 




note:
we can apply this foreach loop on top of two properteis 
1.on array property 
2.on collection property


example on array variable with for and foreach loop:

//demo on post increment&decrement and pre increment and decrement operators
public class Test2 {

	public static void main(String[] args) {

		int x[]= {10,20,30,40};
		System.out.println(x[0]);
		System.out.println(x[1]);
		System.out.println(x[2]);
		System.out.println(x[3]);
		
		System.out.println("using for loop");
		
		for(int i=0;i<=x.length-1;i++)
		{
			System.out.println(x[i]);
		}
		System.out.println("using foreach loop");
		
		for(int y:x)
		{
			System.out.println(y);
		}
		
	}
}



note:
array size is fixed, we can't increase or decrease the size of an array 
at runtime 

example:

//demo on post increment&decrement and pre increment and decrement operators
public class Test2 {

	public static void main(String[] args) {

		int x[]= {10,20,30,40};//array size is 4 only 
		
		x[4]=50;
		
		for(int y:x) {
			System.out.println(y);
		}
		
		
	}
}

->java.lang.ArrayIndexOutOfBoundsException 


another way of declaring the array and then memory creation and 
then assigning the values and then iterating it using foreach loop:

//demo on post increment&decrement and pre increment and decrement operators
public class Test2 {

	public static void main(String[] args) {

		int x[];//array variable declaration 
		
		x= new int[5];//memory creation - 5 elements
		
		x[4]=50;
		
		for(int y:x) {
			System.out.println(y);
		}
		
		
	}
}

note:
we can add our own objects also to the array variable.

break 
continue
 -jump statements 
 
 example on break and continue:
 
 //demo on post increment&decrement and pre increment and decrement operators
public class Test2 {

	public static void main(String[] args) {

		int x[]= {10,20,30,40,50};
		
		for(int y: x)
		{
			if(y==30)
				//break;
				continue;
			System.out.println(y);
		}
		
		
	}
}

widening casting/narrowing casting:

  object level 
  primitive level 
  
casting ->converting from one type data to another type data.

converting lower datatype to higher datatype is known as widening type casting. 
converting higher datatype to lower datatype is known as narrowing type casting. 
widening type casting is automatically happend by the java compiler 
whereas narrowing type casting can be done by the java programmer. 

//demo on post increment&decrement and pre increment and decrement operators
public class Test2 {

	public static void main(String[] args) {

		//implicit casting done by the java compiler automatically -widening type casting
		int x=200;
		double y = x;
		System.out.println("double value is: " + y);
		
		//explicit casting done by programmer -narrowing type casting
		int z = (int)y;
		System.out.println("integer value is: "  + z);
		
	}
}
//for implicit type casting 
//byte->short->char->int ->long->float->double



do one example on narrowing type casting with different types .



down casting -> lower to higher 
up casting -> higher to lower 


java is object oriented programming language?

why java is oopl?
it follows oops princples?

   inheritance
   polymorphism
   abstraction 
   encapsulation 
   
inheritance:
````````````
inheritance is the process of taking the properties from one class to 
another class. 


the class which is giving the properties is known as 
parent class 


the class which is taking the properties is known as child class. 


parent class <-> child class

//parent class
class Test1{
  void sum(int x, int y){
     System.out.println(x+y);
  }
}
class Test2 extends Test1{
   void sub(int x, int y)
   {
   System.out.println(x-y);
   }
}

can't we reuse instead of redefining the code again and again?
->redundancy will be decreased
->memory usage also will be decreased,
->peformance of the application will be improved. 

using extends keyword we can achieve this inheritance concept.


whenever we apply the inheritance, it is highly recommended to create 
the object for child class only.

when we create the object for child class, memory locations will be 
created for both parent class and child class properties. 

are we able to create the object for parent class?

yes , we can but if we create the object for parent class only for 
parent class properties memory locations will be created. 

that's why using parent class object, we can access only parent class 
properties 

but using child class object, we can access both parent class properties 
and child class properties too. 

Parent.java:
``````````````

//parent class cum business logic class 
public class Parent {
	
	public void sum(int x, int y){
		System.out.println("sum is: " +(x+y));
	}

}

Child.java:
`````````````
//child class cum business logic class 
public class Child extends Parent{
	
	public void sub(int x, int y)
	{
		System.out.println("sub is: " +(x-y));
	}

}

Test4.java:
```````````

//execution logic class 
public class Test4 {
	
	public static void main(String[] args) {
		
		//create the object for child class 
		
		Child obj = new Child();
		
		obj.sum(2, 3);
		obj.sub(6, 5);
	}

}

constructor should not be inherited.


when super is mandatory we should use from the context of child class?

  to refer parent class default constructor , using the super() is optional 
  eventhough we are not writing that will be added by the java compiler. 
  
  because default constructor is available in  only one form .
  where as parameterized constructor is available in many forms. 
  
  to refer parent class parameterized constructor(s) from child class 
  constructor(s) for sure we have to use super(...) 
  
 example:
```````````
Parent.java:
```````````

//parent class cum business logic class 
public class Parent {
	
	
	public Parent()
	{
		int x=100;
		System.out.println("x value is: " + x);
	}
}

Child.java:
``````````
//child class cum business logic class 
public class Child extends Parent{
	
	//child class default constructor
	public Child()
	{
		//call parent class default constructor
		
		//super();->optional to use
		int y=200;
		System.out.println("y value is: " + y);
	}
	
}
Test4.java:
`````````````

//execution logic class 
public class Test4 {
	
	public static void main(String[] args) {
		
		//create the object for child class 
		
		Child obj = new Child();
		
		
	}

}

super(..) is mandatory to refer parent class parameterized constructor:
```````````````````````````````````````````````````````````````````````````

//parent class cum business logic class 
public class Parent {
	
	
	//parameterized constructor
	public Parent(int x, int y)
	{
		x=100;
		y=200;
		System.out.println("sum is: " +(x+y));
	}

}

Child.java:
```````````
//child class cum business logic class 
public class Child extends Parent{
	
	//child class default constructor
	public Child()
	{
		//calling parent class parameterized constructor 
		super(2,2);//mandatory
		int y=200;
		System.out.println("y value is: " + y);
	}
	
}

Test4.java:
```````````

//execution logic class 
public class Test4 {
	
	public static void main(String[] args) {
		
		//create the object for child class 
		
		Child obj = new Child();
	
	}

}

super:
``````
super is the java reserved keyword we are using this at following levels

1.at variable level 
2.at method level 
3.at constructor level (constructors are not inherited)

why constructors are not inherited?


class Test1{
   public Test1(){
   }

}
class Test2 extends Test1{
   public Test1()
   {
   }
}

super at vairable level:
whenever parent class and child class variables are same , by default 
using child class object it will give you child class values means parent 
class variables are overriden with child class varaible values. 

but if we want parent class variable value also, from child class we can 
use super keyword at variable level using following syntax. 
   super.<variablename>;
   
example:
`````````

//parent class cum business logic class 
public class Parent {
	
	
	int x =100;

}

Child.java:
``````````
//child class cum business logic class 
public class Child extends Parent{
	
	int x = 200;
	public void display()
	{
		System.out.println("parent class x vlaue is: " + super.x);
		System.out.println("x value is: " +x);
	}
}


Test4.java:
`````````````

//execution logic class 
public class Test4 {
	
	public static void main(String[] args) {
		
		//create the object for child class 
		
		Child obj = new Child();
		obj.display();
		
	}

}



you try super with method level?

hint: syntax: super.parentclassmethod();


inheritance is nothing but is-a relation in between two classes. 

The "is-a" relationship implies that an object of the child class 
also an object of the parent class. 

parent class ->Vehicle
Child class -> Car

 Car "is-a" Vehicle
 
has-a relationship is typically reprsented through composition, 

where one class contains an object of another class. 


Unlike Inheritance, which is an "is-a" relationship, the "has-a" relationship
implies that a class has another class as a part of component. 

Car ->class
Engine -> Class

Car "has-a" Engine.

class Car{
   Engine carEngine;
 }


->to achieve code reuse
->modular design 



public class Car {
	
	 String model;
	 Engine carEngine;//Car has-an Engine

	 public Car(String model,Engine carEngine)
	 {
		 this.model=model;
		 this.carEngine=carEngine;
		 
	 }
}


Engine.java:
````````````

public class Engine {

	 String type;
	
	 public Engine(String type) {
		 this.type=type;
	 }
}

Test5.java:
````````````

//execution logic class
public class Test5 {

	public static void main(String[] args) {
		
		//creating an Engine for a Car
		Engine v6Engine = new Engine("V6");
		
		//creating a Car with the Engine 
		Car myCar = new Car("Sedan",v6Engine);
		
		//accessing car properties
		System.out.println("Model -->" + myCar.model);
	    System.out.println("Engine Type -->" + myCar.carEngine.type);
	}
}



class A {
sum(){}
}
class B extends A{
sub(){}

}
class C extends B {
   mul(){}
}

C obj = new C();
obj.sum();

Object is the predefined class avaialble in java.lang package , it is the 
root class for every class whether it is predefined or userdefined class. 


if a method is not there inside your class, but when you try to invoke 
immediatly it will not give you any error, firstly it will check for those 
methods inside their parent classe(s) still if it didn't find any then it 
gives you compile time error. 

am i able to access Object class methods from any class?


yes, because Object is the parent class for every class in java 
whehter it is predefined or userdefined.

clone()
finalize()
getClass()
hashCode()
toString()
equals()
notify()
notifyAll()
wait()



public class Test6 {
	
	public static void main(String[] args) {
		
		Test6 obj = new Test6();
		System.out.println(obj.hashCode());
		System.out.println(obj.toString());
		System.out.println(obj);
		System.out.println(obj.getClass());
	}

}


polymorphism:
is one of the oop principle

definition: 
is a concept in oop where  a single method 
can be used with different types of objects. 


compile time polymorphism
runtime polymorphism

to achieve this polymorphism principle, we required two concepts 
in java

1.method overloading->compile time polymorphism
2.method overriding -> runtime polymorphism


method overloading:

 method name is same 
 but parameters (type,no,order)are different
 
 ->readability of the code 
 for everytask we don't need to remember a specific method 
 for every operation, we need only one method but input parameters are 
 different.
 
 
example on method overloading/compile time polymorphism:


public class Test6 {
	
	public void sum(int x, int y)
	{
		System.out.println("integer sum is: " +(x+y));
	}
	public void sum(double x, double y)
	{
		System.out.println("double sum is: " +(x+y));
	}
	
	public static void main(String[] args) {
		
		Test6 obj;//object declaration available at compile time to the java compiler
		obj= new Test6();//referencing the object at runtime 
		obj.sum(6, 7);
		obj.sum(8.9,4.5);
		
	}

}

note:
to perform method overloading, how many classes we require?

one class is enough


method overriding:
```````````````````
method name is same but logic/body is different from parent class 
to child class. 


why should i go for method overriding:
sir already logic was there in parent class, but i don't require that 
parent class logic, 
i want my own logic, then what we have to do?
take the same method and provide new logic .
class Parent{
   marriage()
   {
     //arranged marriage - logic was there by parents 
   }
}

class Child extends Parent{
   marriage()
   {
     //love marriage - logic was defined by child 
   }

}

method overriding:
``````````````````

//parent class cum business logic class 
public class Parent {
	
	
	public void sum(int x, int y)
	{
		System.out.println("sum is: " +(x+y));
	}

}

Child.java:
````````````
//child class cum business logic class 
public class Child extends Parent{
	
	public void sum(int x, int y)
	{
		System.out.println("substraction is: " + (x-y));
	}
}



Test4.java:
````````````

//execution logic class 
public class Test4 {
	
	public static void main(String[] args) {
		
		//create the object for child class
		
		//Child obj = new Child();
		//obj.sum(4, 3);
		
		//Parent obj = new Parent();
		//obj.sum(4, 3);
		
		//converting child class object type to parent class object type- upcasting
		Parent obj;
		obj= new Child();
		obj.sum(4, 3);
		
	
		
	}

}










encapsulation:
`````````````
encapsulation is the process of wrapping up of variables and methods 
into a single unit. 

to make any normal java class as an encapsulated class we have to follow 
few rules. 

1.for every variables of the class, we should maintain public setters and 
getter methods 

2.variables must be of private.


setter methods: to set the values 

getter method: to get the values



->data hiding


Product.java:
``````````````
//encapsulated class
public class Product {

	//private variables
	private int pid;
	private String pname;
	
	public int getPid() {
		return pid;
	}
	public void setPid(int pid) {
	this.pid = pid;
	}
	public String getPname() {
		return pname;
	}
	public void setPname(String pname) {
		this.pname = pname;
	}
	}
	

 Test7.java:
`````````````
//execution logic class 
public class Test7 {

	public static void main(String[] args) {
		
		Product product = new Product();
		
		product.setPid(100);
		product.setPname("laptop");
		
		System.out.println("product id is: " + product.getPid());
		System.out.println("product name is: " + product.getPname());
		
		
	}
}

abstraction:
`````````````
it is the process of hiding the implementation details and 
retrieveing required details only.

 whatsapp -> as an end user -> message is delivered 
  
	focusing on services not on implementation details.    
	
	security
	
  to achieve this abstraction we have two concepts 
  
  abstract class (0 to 100%)
  interface(100%)
  
abstract class:
``````````````
it is also a class which may contains atleast one abstract method 
or undefined method or specification or method declaration .

defined methods/implemented methods/concrete methods 

  it has both method heading + method body 

public void sum()
{
} 

abstract method/ unimplemented / undefined methods
 
  it has only method declaration (heading only no body)

 public abstract void sum();
 
 note: using abstract keyword, we can represent abstract methods.
 
 
abstract class Test1{
  abstract void sub();
}
	
at design leve we have one thumb rule. 
we can't instantiate the abstract class. 
we can not create the object for an abstract class. 


what kind of methods we are making as an abstract methods?
    common methods 
	//parent class
	abstract class Bank{
	  abstract double rateOfInterest();
	}
    //child class or implementation class 
    class Icici extends Bank{
	
	   double rateOfInterst(){
	      return 5.5;
	   }
	}
	class Sbi extends Bank
	{
	   double rateOfInterst(){
	      return 4.5;
	   }
	}
	
	class PNB extends Bank 
	{
	  double rateOfInterst(){
	      return 4.5;
	   }
	}
	//runtime polymorphism
	Bank obj = new Icici();
	obj.rateOfInterest();
	

creating the object for an abstract class is nothing but 
creating an object of it's implementation class. 

for single abstract class, how many implementation classes we can define?

 as many as we want based on the requirement. 
 
 
Bank.java:
``````````

public abstract class Bank {
	
	public abstract double rateOfInterest();
	

}


Icici.java:
`````````````

public class Icici extends Bank {

	@Override
	public double rateOfInterest() {
		// TODO Auto-generated method stub
		return 4.5;
	}

}

SBI.java:
```````````

public class SBI extends Bank {

	@Override
	public double rateOfInterest() {
		// TODO Auto-generated method stub
		return 7.5;
	}

}

Test8.java:
``````````````

public class Test8 {
	
	public static void main(String[] args) {
		
		Bank obj = new Icici();
		System.out.println("icici bank rate of interst is :" + obj.rateOfInterest());
		
		Bank obj1 = new SBI();
		System.out.println("SBI rate of interst is : "  + obj1.rateOfInterest());
	}

}


interface:
```````````

interface is a collection of only abstract methods and constants (ifany)

syntax:

  interface <interfacename>
  {
     //constants
	 //abstract methods 
  }

class -is the keyword we are using to define the class
interface - is the keyword we are using to define the interface.

ex:

  interface i1
  {
    //abstract method
    void sum(int x, int y);
	PI = 3.14;
  }

by default interface methods are public abstract in the same way 
by default interface variables are public static final 



for a single interface, we can define multiple implementation classes 
it is depending upon our requirement.

i1.java:
`````````

public interface i1 {
	
	 void sum(int x, int y);
     void sub(int x, int y);
}


Test9.java:
````````````

//implementation class for i1 interface 
public class Test9 implements i1{

	@Override
	public void sum(int x, int y) {
		System.out.println("sum is: " +(x+y));
		
	}

	@Override
	public void sub(int x, int y) {
		System.out.println("sub is: " + (x-y));
	}

}

Test10.java:
```````````

public class Test10 {
	
	public static void main(String[] args) {
		
		//create the object for i1
		//runtime polymorphism
		i1 obj = new Test9();
		obj.sum(3, 4);
		obj.sub(5, 4);
		
	}

}

extends keyword we are using to bring the properties from class to class 
or interface to interface (homogenious)

implements keyword we are using to bring the properties from interface to 
class not from class to interface because we are not making defined things 
as undefined .

note:

using interface we can achieve multiple inheritance.


class A{
  sum(){};
}
class B{
  sum(){}
}
class C extends A,B{
  sum(){} sum(){}
}
single child class 

multiple parent classe
 possible or not possible ?
 
C obj = new C();
obj.sum();

using extends keyword, we can extend from single class to single class only.
not from more than one parent class. 

 but using interface, we can achieve this mutliple inheritance.
 
 using implements keyword, we can define the class implements from 
 more than one interface.
 
 ex:
  
   class Test implements i1,i2,i3...
   {
   
   }
 
package:
`````````
package is a collection of classes and interfaces and sub packages. 

types of pacakges:
 
  predefined pacakges ->
  userdefined packages ->
 
 purpose:
 why should i keep my classes/interface inside the package
 answer: to achieve the concept of reusability
       : to avoid naming conflicts
	   
	   
	   class/interface with the same name inside the same package 
	   it is not possible 
	   
	   by differentiating package name it is possible. 
	   
	   com.techm
	       -Test1
	      
	   com.hexaware
	       -Test1
		   
	   
 
 
   method(s) -> class/interface
   variables -> class/interface/methods/blocks...
   
   class/interfaces -> packages
   
   
 
 String -java.lang 
 Runnable -> java.lang 
 FileInputStream -> java.io 
 ArrayList -> java.util 
 Connection -> java.sql 
 
 
java.applet
java.awt
java.awt.color
java.awt.datatransfer
java.awt.dnd
java.awt.event
java.awt.font
java.awt.geom
java.awt.im
java.awt.im.spi
java.awt.image
java.awt.image.renderable
java.awt.print
java.beans
java.beans.beancontext
java.io
java.lang
java.lang.annotation
java.lang.instrument
java.lang.invoke
java.lang.management
java.lang.ref
java.lang.reflect
java.math
java.net
java.nio
java.nio.channels
java.nio.channels.spi
java.nio.charset
java.nio.charset.spi
java.nio.file
java.nio.file.attribute
java.nio.file.spi
java.rmi
java.rmi.activation
java.rmi.dgc
java.rmi.registry
java.rmi.server
java.security
java.security.acl
java.security.cert
java.security.interfaces
java.security.spec
java.sql
java.text
java.text.spi
java.time
java.time.chrono
java.time.format
java.time.temporal
java.time.zone
java.util
java.util.concurrent
java.util.concurrent.atomic
java.util.concurrent.locks
java.util.function
java.util.jar
java.util.logging
java.util.prefs
java.util.regex
java.util.spi
java.util.stream
java.util.zip
 
 
 package statement must be always first statement otherwise it gives 
 you compile time error.
 
 
 how can i import the pacakges
    import <pacakgename>.<classname>/<interfacename>;
	
Test1.java:
```````````

package com.techm;
public class Test1 {

	 public void sum(int x, int y)
	 {
		 System.out.println("sum is: " + (x+y));
	 }
}

Test2.java:
`````````````
package com.wipro;
import com.techm.Test1;
public class Test2 {

	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(4, 5);
	}
}

when import is required?

  if both the classes/interfaces belongs to differnt pacakges 
  
when import is not required?

   if both the classes/interfaces belongs to same pacakge 
   
  

we have so many predefined packages are there 
but java.lang is the default imported package to every java application 

whether you import explicitly or not, it is automatically imported 

  
  package com.techm;

import java.util.ArrayList;
public class Test4 {

	public static void main(String[] args) {
		
		String s = new String("rama");
		
		ArrayList al = new ArrayList();
		
	}
}



refer the subpackages concept
how can i define the subpackage 
how can i import the subpackage 
and observe the difference between main pacakge and sub pacakge? 

note:
by importing the main package we are allowed to import only main package 
properties 

by importing the sub package we are allowed to import only sub package 
properties 

by importing the main package, we can't get sub pacakge properties .

package com.techm.subpackage;

public class Test6 {

	 public void mul(int x, int y)
	 {
		 System.out.println(x*y);
	 }
}

package com.wipro;
import com.techm.subpackage.Test6;
public class Test7 {

	public static void main(String[] args) {
		
		Test6 obj = new Test6();
		obj.mul(4, 5);
	}
}

access modifiers:
````````````````````
access modifiers are used to restrict the visibility of the data 
over the packages. 

in java, how many access modifiers we have 

 4 
 
 what are those?
 
  private 
  default (is not a keyword)
  protected 
  public 
  
  
    int x;
  

Test1.java:
```````````
package com.techm.accessmodifiers;

public class Test1 {
	//private variable
	private int x=100;
	
    public static void main(String[] args) {
		
    	System.out.println( new Test1().x);
	}
}

Test2.java:
````````````
package com.techm.accessmodifiers;

public class Test2 {

	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		//System.out.println(obj.x);
	}
}

note:
private properties we are allowed to access only inside the class 
we are not allowed to access from other classe(s) even though it belongs 
to same package.

note:
`````
default properties observation 
same pacakge same class -accessed 
same package other class -accessed
other package other class - not accessed 


observation about protected properties:
````````````````````````````````````````
same package same class - accessed
same package other class - accessed 
other package independent class -not accessed
other package sub class - accessed 

public:
there is no restriction for this access modifiers
->universal access modifier 

exception handling:
``````````````````
  when you wrote any java program, we will get errors. 
   
     errors are of two types 
	 
	  1.compile time errors - compiler 
	     why?
		 reason : because if we make any syntactical mistakes 
		 .java -> .class 
		 
		 
	  2.runtime errors -> jvm -> exception 
	  
	     why?
		 reason: when we wrong at logic in the program
		 enter frist number: 100
		 enter second number: abc
		 
		 when we are passing invalid input, jvm could not process ur 
		 input.
		 in return what we will get? 
		 exceptions
exception is a runtime error. 

if we get the exception , what happend? 
any drawback


1.abnormal termination(we are not able to maintain execute in a normal 
  flow)
2.end user gets system error messages which are not understandable by 
end user. 

who are the endusers?
  who are using your product in the market. 
  
we have to handle the exceptions 

exception handling:
```````````````````
even though if we get exceptions, we can avoid the drawbacks when 
we handle the exceptions.

how can we handle the exceptions: 
to handle the exceptions in java, we have 5 java reserved keywords
are there 

1.try block 
2.catch block 
3.finally block 
4.throws
5.throw

block:
``````
block means code which is inside {  }


package com.techm.exceptions;

public class Test2 {
	
	//instance block
	{
		System.out.println("instance block");
	}
	//static block
	static
	{
		System.out.println("static block");
	}
	public Test2()
	{
		System.out.println("constructor");
	}
	
	public static void main(String[] args) {
		Test2 obj = new Test2();
		
		
	}

}
/*output order
 * 
 * static block
   instance block
   constructor
 */


try block:
```````````
syntax:

try
{
  //problematic statements 
}

why try block: 
reason: to keep the problematic statements, the statements which causes 
problems at runtime. 

catch block:
`````````````
syntax:

  catch(<exceptionclassname> <refvarname>)
  {
   //provide the user friendly message
  }
  


note:
practically every exception is a class only.


example
``````````
package com.techm.exceptions;

import java.util.Scanner;

public class Test1 {

public static void main(String[] args) {
	try {
		//problematic statements
	Scanner s = new Scanner(System.in);
	System.out.println("enter first number");
    int fno = s.nextInt();
    System.out.println("enter second number");
    int sno = s.nextInt();
    
    int division = fno/sno;
    System.out.println("division of given two nos is : " + division); 
	}
	catch(ArithmeticException ae)
	{
		System.out.println("don't enter zero as denominator");
	}
	catch(InputMismatchException im) {
		
		System.out.println("please pass only numeric values");
	}
	
	System.out.println("rest statements also executed");
}

}

/*
 * 
 * Exception in thread "main" java.lang.ArithmeticException: / by zero at
 * com.techm.exceptions.Test1.main(Test1.java:16)
 * 
 */

for a single try block, how many catch blocks we can define?
answer: based on the requrement as many as we want. 

example:
````````
package com.techm.exceptions;

import java.util.InputMismatchException;
import java.util.Scanner;

public class Test1 {

public static void main(String[] args) {
	try {
		//problematic statements
	Scanner s = new Scanner(System.in);
	System.out.println("enter first number");
    int fno = s.nextInt();
    System.out.println("enter second number");
    int sno = s.nextInt();
    
    int division = fno/sno;
    System.out.println("division of given two nos is : " + division); 
	}
	
	catch(RuntimeException re)
	{
		if(re instanceof ArithmeticException)
			System.out.println("don't enter zero as denominator");
		if(re instanceof InputMismatchException)
			System.out.println("please pass only numeric values");
	}
	
	 
	
	System.out.println("rest statements also executed");
}

}

/*
 * 
 * Exception in thread "main" java.lang.ArithmeticException: / by zero at
 * com.techm.exceptions.Test1.main(Test1.java:16)
 * 
 */


finally block:
why? 
 reason: to keep the resource closing releated logic.
  
  ex: database connection closing logic, 
      file closing logic etc.. 
	  
 DataLeakage exceptions, to avoid that for sure we have to close 
 those resources. 
 
   opened the file 
   read the data 
   didn't close the data.. 
    some other unauthorized people also. 
	
	close the resource. 
	
file opened ---
--
--
--  int x = 100/0;
---
--
--
finally{
  close the file logic ----
}

note:
irrespective of whether we got the exceptions or not, everytime finally 
block gets executed. 


package com.techm.exceptions;

import java.util.InputMismatchException;
import java.util.Scanner;

public class Test1 {

	public static void main(String[] args) {
		try {
			// problematic statements
			Scanner s = new Scanner(System.in);
			System.out.println("enter first number");
			int fno = s.nextInt();
			System.out.println("enter second number");
			int sno = s.nextInt();

			int division = fno / sno;
			System.out.println("division of given two nos is : " + division);
		}

		catch (RuntimeException re) {
			if (re instanceof ArithmeticException)
				System.out.println("don't enter zero as denominator");
			if (re instanceof InputMismatchException)
				System.out.println("please pass only numeric values");
		}

		finally {
			System.out.println("finally block executed always");
		}

		System.out.println("rest statements also executed");
	}

}

/*
 * 
 * Exception in thread "main" java.lang.ArithmeticException: / by zero at
 * com.techm.exceptions.Test1.main(Test1.java:16)
 * 
 */


throws:
```````
throws is a java reserved keyword which gives an indication to the 
calling function to keep the called function under try and catch 
block.


Test3.java:
``````````
package com.techm.exceptions;

import java.util.InputMismatchException;

public class Test3 {
	
	//called method or function 
	
	public void division(int x, int y) throws ArithmeticException,InputMismatchException
	{
		int z = x/y;
		System.out.println("division of given two no's is: " + (x/y));
	}

}

Test4.java:
``````````
package com.techm.exceptions;

import java.util.InputMismatchException;
import java.util.Scanner;

public class Test4 {
	
	//calling function or method 
	public static void main(String[] args) {
		try {
		Scanner s = new Scanner(System.in);
		System.out.println("enter first number:");
		int fno = s.nextInt();
		System.out.println("enter second number:");
		int sno = s.nextInt();
		
		Test3 obj  = new Test3();
		
		
		obj.division(fno, sno);
		}
		catch(RuntimeException re) {
			if(re instanceof ArithmeticException)
				System.out.println("dont enter zero as denominator");
			if(re instanceof InputMismatchException)
				System.out.println("please pass only numeric values");
		}
	}

}


throw:
``````
throw is a java reserved keyword 

purpose: to throw an exception explicitly.


throwing the exception -> creating the object of that class. 

100
0
  ArithmeticException can be thrown by jvm
100
abc 
  InputMismatchException can be thrown by jvm. 
  
all the predefined exceptions can be thrown by jvm when it met some 
condition .

q)can we throw any predefined exception using throw keyword explicitly?
yes

condition: 
if my string starts with r 
i want to throw ArithmeticException explicitly. 

syntax:

  throw new <exceptionclassname>();
  throw new ArithmeticException();
  throw new InputMismatchException();
  ...
  
 example:
```````````
package com.techm.exceptions;

import java.util.Scanner;

//ctrl+shift+o-short cut for organizing the import statements
public class Test5 {
	
	public static void main(String[] args) {
		
		Scanner s = new Scanner(System.in);
		System.out.println("enter string ");
		String word = s.next();
		
		if(word.startsWith("r")) {
			try {
			throw new ArithmeticException();
			}
		catch(ArithmeticException ae)
		{
			System.out.println("string should not start with r");
		}
		}
		else
		{
			System.out.println(word + " is valid");
		}
		
	}

}

note:
usually we are using or we are throwing userdefined exceptions 
using throw keyword. 

these exceptions objects can be created by programmer 
or these exceptions can be thrown by programmer. 

Test6.java:
```````````````
package com.techm.exceptions;
//business logic class 

public class Test6 {
	
	
	public void checkProduct(int weight)
	{
		if(weight>100)
			System.out.println("product is valid");
		else
			try {
			throw new InvalidProductException("product weight should be greater than 100");
			}
		catch(InvalidProductException ip)
		{
			System.out.println(ip);
		}
	
	}
	

}
Test7.java:
```````````
package com.techm.exceptions;

import java.util.Scanner;

public class Test7 {
	
	public static void main(String[] args) {
		
		Test6 obj = new Test6();
		Scanner s = new Scanner(System.in);
		System.out.println("enter product weight");
		int productWeight = s.nextInt();
		obj.checkProduct(productWeight);
		
	}

}

InvalidProductException.java:
```````````````````````````````
package com.techm.exceptions;

public class InvalidProductException extends Exception  {

	public InvalidProductException(String message) {
		super(message);
		// TODO Auto-generated constructor stub
	}

	
}


	
FileHandling in java/iostreams in java:
```````````````````````````````````````
why are using this filehandling 

using files -> we can store the data 

 
on top of files, we can perform two operations 

 1. write operation (output operation)
 2. read operation (input operation )
 
 

to work with this filehandling we need some predefined classes 
which are available inside java.io pacakge 

  
stream:
 it is a flow of data in between primary memory to secondary memory .
 
 writing the data into file -> saving the data into a file 
  -> secondary memory (harddisk,pendriver,...)
  primary memory(ram) -> the data will flow from primary memory to 
  secondary memory.
  
 reading the data from the file ->
    the data will flow from secondary memory to primary memory 
	
	
how to create the file in java?

package com.techm.filehandling;

import java.io.File;
import java.io.IOException;

public class Test1 {
	
	public static void main(String[] args) {
		
		//create the File class object 
		
		File f = new File("rk.txt");
		try {
		f.createNewFile();
		}
		catch(IOException ioe) {
			System.out.println(ioe);
		}
		
		System.out.println(f.exists());
		
	}

}


how to write the data into a file?

 to insert the data we are using one pre-defined class 
 PrintWriter 

 PrintWriter is the pre-defined class avaialble in java.io pacakge 
 for the purpose of writing the data into a file. 
 
how to write the data into a file using PrintWriter:

package com.techm.filehandling;

import java.io.FileNotFoundException;
import java.io.PrintWriter;

public class Test2 {

	public static void main(String[] args) {
		try {
			// create the object of PrintWriter

			PrintWriter pw = new PrintWriter("rk.txt");

			pw.println("rama");
			pw.println(23.45);
			pw.println(true);
			pw.println('r');

			pw.flush();

			System.out.println("data written successfully");

		} catch (FileNotFoundException fn) {
			System.out.println(fn);
		}

	}

}

how to read the data from the file:
```````````````````````````````````
to read the data from the file we have one predefined class 

   BufferedReader(java.io)
   
   
package com.techm.filehandling;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class Test3 {
	
	public static void main(String[] args) {
		try {
		//create the object for BufferedReader
		
		BufferedReader br = new BufferedReader(new FileReader("rk.txt"));
		String word = br.readLine();
		
		while(word!=null)
		{
			System.out.println(word);
			word = br.readLine();
		}
		}
		catch(FileNotFoundException fnf) {
			System.out.println(fnf);
		}
		catch(IOException ioe) {
			System.out.println(ioe);
		}
	
	}


}
   
collection framework in java:
``````````````````````````````
using arrays, we can store the multiple values of same type 
in a single variable. 
   
ex: int a[]={10,20,30}

->using this, we can't store multiple values of different types
->size is fixe in nature , we can't increase or decrease the size of the array
->arrays are not following proper datastructures internally
->for every operation in arrays, we have to write the logic manually 
  there are no readymade methdos are available. 
  
  to avoid these drawbacks, we should go for one concept i.e 
  collection framework.
  
  collection framework is the standardized mechanism of grouping 
  similar type of objects and dissimilar type of objects into a single 
  variable. that single variable is known as collection object. 
  
  in case of collections, 
  
  1.it allows both same type of data and diffrent type of data 
  2.size is not fixed it is growable in nature 
  3.collectoins are following very good datastructures internally 
  4.it has so many ready made methods 
  
  note: collections are allowing only object type data not 
  primitive type data. 
  
  to work with this cfw, we have some predefined interfaces are there 
  and some predefined classes are also there which are given by sun 
  and provided in one package i.e java.util package. 
  
  


                         Collection 
   List
                              Set
                                                        Queue     
                              SortedSet
   


interface Collection{
   
}
  ->we don't have any diret implementation class for this Collection interface

interface List extends Collection{
}

   ->ArrayList
   ->LinkedList
   ->Vector
   ->Stack ....
   
  class ArrayList implements List extends Collection 
  {
  }  
  class LinkedList implements List extends Collection 
  {
  }
  ...
    List l = new ArrayList();//valid 
	
	
 

interface Set extends Collection{
}

   HashSet
   LinkedHashSet
   
 class HashSet implements Set extends Collection 
 {
 } 

   Set s = new HashSet();
   Set s1 = new LinkedHashSet();
   
   
interface Queue extends Colleciton 
{
}
 
  ArrayDeque
  PriorityQueue
  
 class ArrayDeque implements Queue extends Collection 
 {
 }
 
   Queue q  = new ArrayDeque();
   Queue q1 = new PriorityQueue();
   
interface SortedSet extends Set extends Collection 
{
}

   TreeSet
   
 class TreeSet implements SortedSet extends Set extends Collection 
 {
 }

   SortedSet s = new TreeSet();
   

List:
List is the predefined interface avaialble in java.util packge 

->it allows both homogenious data and heterogenious data 

->insertion order is preserved 

->null insertion is possible 

->duplicate objects are allowed. 


choosing the List interface is nothing but choosing it's implementation 
classes either LinkedList or ArrayList 



package com.techm.cfw;

import java.util.ArrayList;
import java.util.List;

public class Test1 {

	
	public static void main(String[] args) {
		
		//create the object for List interface 
		
		List l = new ArrayList();
		
		System.out.println(l.size());//0
		
		//add the element 
		l.add(Integer.valueOf(100));
		l.add(null);
		l.add(Boolean.valueOf(true));
		l.add(Integer.valueOf(100));
		l.add(new String("rama"));
		
		System.out.println(l);//[100, null, true, 100, rama]
		
        boolean b = l.remove("rama");
        
        System.out.println(l);//[100, null, true, 100]
        
        
        l.remove(Integer.valueOf(100));
       
        System.out.println(l);//[null, true, 100]
        System.out.println(l.remove(2));//100
        
        System.out.println(l);//[null, true]
        
        
        System.out.println(l.isEmpty());
       
        System.out.println(l.contains(null));//true
        
        l.clear();
        
        System.out.println(l);//[]
        
        l.add("ram");
        l.add(Integer.valueOf(100));
        l.add(true);
        
        System.out.println(l);
        
        l.add(1, Double.valueOf(2.3));
        
        System.out.println(l);
        
        //foreach method on this list object 
        
        for(Object o:l) {
        	System.out.println(o);
        }
        
	
	}
}


once you done this, observe the difference between 
ArrayList and LinkedList


ArrayList -> 
LinkedList -> node wise data will be stored

if my frequent operation is insertion/deletion/updation then 
we can opt for LinkedList


if our frequent operation is selection, then  ArrayList is preferable 
RandomAccess interface. 

Vector and Stack (do two programs) on top of this?

Set:
````
Set is the pre-defined interface avaialble in java.util package 
 ->HashSet
 ->LinkedHashSet
 
1.it allows both homogenious and heterogenious objects
2.insertion order is not preserved(we can't predict the order)
3.duplicate elements are not allowed
4.null insertion is possible but only for one time. 


package com.techm.cfw;

import java.util.HashSet;
import java.util.Set;

public class Test2 {
	
	public static void main(String[] args) {
		
		//create the object for Set
		
		Set s = new HashSet();
		
		s.add("rama");
		s.add(98);
		s.add(true);
		s.add(9.8);
		
		s.add(98);
		s.add(null);
		s.add(null);
		
		System.out.println(s);//[null, 98, rama, 9.8, true]
		
		for(Object o:s) {
			System.out.println(o);
		}
		
	}

}
what is the differnce between HashSet and LinkedHashSet?

 in case of HashSet , insertion order is not preserved 
 but in case of LinkedHashSet, insertion order is preserved. 
 

Iterator:
`````````
Iterator is one of the predefined interface avilable in java.util 
package


in each and every collection class, we have one method i.e. iteartor(), 
if we invoke this it will give you Iterator object. 

example:
``````````
package com.techm.cfw;

import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.Set;

public class Test2 {
	
	public static void main(String[] args) {
		
		//create the object for Set
		
		Set s = new LinkedHashSet();
		
		s.add("rama");
		s.add(98);
		s.add(true);
		s.add(9.8);
		
		s.add(98);
		s.add(null);
		s.add(null);
		
		System.out.println(s);//[null, 98, rama, 9.8, true]
		
		for(Object o:s) {
			System.out.println(o);
		}
		System.out.println("===========================");
		
		Iterator itr = s.iterator();
		
		while(itr.hasNext())
		{
			Object obj = itr.next();
			
			if(obj instanceof Integer) {
				//from parent to child type (downcasting)
				Integer i = (Integer)obj;
				if(i==98)
				itr.remove();
			}
			
		}
		System.out.println(s);
	}

}


Queue:
`````
    LASTINFIRSTOUT 
	FIFO
	pop()
	push()
	peek()
	
	
ListIterator is the predefined interface and it is also known 
as Bidirectional cursor

Unidirectional/universal cursor is Iterator

package com.techm.cfw;

import java.util.ArrayList;
import java.util.ListIterator;

public class Test3 {
	
	public static void main(String[] args) {
		
		
		ArrayList al = new ArrayList();
		al.add(100);
		al.add(304);
		al.add(89);
		al.add(76);
		al.add(987);
		
		
		ListIterator ltr = al.listIterator();
		
		while(ltr.hasNext())
		{
			System.out.println(ltr.next());
		}
		
		System.out.println("=======================");
		while(ltr.hasPrevious())
		{
			System.out.println(ltr.previous());
		}
	
		
	}

}

example without generics:
````````````````````````
package com.techm.cfw;

import java.util.ArrayList;
import java.util.ListIterator;

public class Test3 {
	
	public static void main(String[] args) {
		
		
		ArrayList al = new ArrayList();
		al.add(100);
		al.add(304);
		al.add(89);
		al.add(76);
		al.add(987);
		
		
		ListIterator ltr = al.listIterator();
		
		while(ltr.hasNext())
		{
			Object obj = ltr.next();
			//convert Object type -> Integer type
			//downcasting(parent type to child type)
			Integer i = (Integer)obj;
			
			if(i%2==0)
				System.out.println(i);
		}
	
	}

}

example with generics:
`````````````````````
package com.techm.cfw;

import java.util.ArrayList;
import java.util.ListIterator;

public class Test3 {
	
	public static void main(String[] args) {
		
		
		ArrayList<Integer> al = new ArrayList<Integer>();
		al.add(100);
		al.add(304);
		al.add(89);
		al.add(76);
		al.add(987);
		
		
		ListIterator<Integer> ltr = al.listIterator();
		
		
		while(ltr.hasNext())
		{
			Integer i = ltr.next();
			
			
			if(i%2==0)
				System.out.println(i);
		}
	
	}

}

with generics what are the benefits we are getting?

1.when we try to add any other type of data, immediatly we will get compile 
time errors which are far better than runtime errors. 

2.we no need to perform typecasting 


i want to add userdefined object(s) to any collection class?

Test4.java:
`````````````
package com.techm.cfw;

import java.util.ArrayList;

public class Test4 {

	
	public static void main(String[] args) {
		
		ArrayList<Student> al = new ArrayList<Student>();
		
		Student st1 = new Student(100,"swaroop");
		Student st2 = new Student(101,"Chanda");
		Student st3 = new Student(102,"jahnavi");
		
		al.add(st1);
		al.add(st2);
		al.add(st3);
		System.out.println(al);
		
	}
}

Student.java
````````````
package com.techm.cfw;

public class Student {

	private int stid;
	private String stname;
	
	public Student(int stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	
	public Student() {
		super();
	}
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	public String toString()
	{
		return stid + " " +stname;
	}
	
}

w.r.to.HashSet:
`````````````
package com.techm.cfw;

import java.util.HashSet;

public class Test4 {

	
	public static void main(String[] args) {
		
		HashSet<Student> al = new HashSet<Student>();
		
		Student st1 = new Student(100,"swaroop");
		Student st2 = new Student(101,"Chanda");
		Student st3 = new Student(100,"swaroop");
		
		al.add(st1);
		al.add(st2);
		al.add(st3);
		System.out.println(al);
		
	}
}

Student.java:
```````````````
package com.techm.cfw;

import java.util.Objects;

public class Student {

	@Override
	public int hashCode() {
		return Objects.hash(stid, stname);
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Student other = (Student) obj;
		return stid == other.stid && Objects.equals(stname, other.stname);
	}
	private int stid;
	private String stname;
	
	public Student(int stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	
	public Student() {
		super();
	}
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	public String toString()
	{
		return stid + " " +stname;
	}
	
}

SortedSet:
`````````````
SortedSet is the predefined interface availble in java.util package 

implementation class: TreeSet

properties:
``````````
   1.it allows only homogenious objects.
   2.insertion order is sorted(natural sorting order is ascending)
   3.null insertion is not possible. 
   4.duplicate objects are not allowed. 
   
 note:
to the SortedSet, if we try to add any heterogenious objects it won't give 
you any compile time error, but it gives you runtime error saying that 
java.lang.ClassCastException 

in case of adding null values, it gives you java.lang.NullPointerException 

package com.techm.cfw;

import java.util.TreeSet;

public class Test5 {

	
	public static void main(String[] args) {
		
		TreeSet ts = new TreeSet();
		
		ts.add(100);
		ts.add(9);
		ts.add(81);
		ts.add(91);
		ts.add(07);
		ts.add(12);
		ts.add(18);
		ts.add(100);
		
		System.out.println(ts);//[7, 9, 12, 18, 81, 91, 100]
		
		System.out.println(ts.first());
		System.out.println(ts.last());
		System.out.println(ts.headSet(12));
		System.out.println(ts.tailSet(81));
		System.out.println(ts.subSet(12, 100));
	}
}

 
->how can i add user defined object to arraylist
->how can i add user defined object to HashSet
->i observed the even two objects are identical it is accepting, to avoid
  this how can we override equls() and hashCode() of Object class 
->how can i add normal objects to TreeSet and observe the output and look 
for special methods of TreeSet




class Contact {
    private String name;
    private String phoneNumber;
    private String emailAddress;

    public Contact(String name, String phoneNumber, String emailAddress) {
        this.name = name;
        this.phoneNumber = phoneNumber;
        this.emailAddress = emailAddress;
    }

    public String getName() {
        return name;
    }

    public String getPhoneNumber() {
        return phoneNumber;
    }

    public String getEmailAddress() {
        return emailAddress;
    }

    @Override
    public String toString() {
        return "Name: " + name + ", Phone: " + phoneNumber + ", Email: " + emailAddress;
    }
}




public class AddressBook {
    private ArrayList<Contact> contacts;

    public AddressBook() {
        contacts = new ArrayList<>();
    }

    public void addContact(Contact contact) {
        contacts.add(contact);
    }

    public Contact getContactByName(String name) {
        for (Contact contact : contacts) {
            if (contact.getName().equalsIgnoreCase(name)) {
                return contact;
            }
        }
        return null;
    }

    public void displayAddressBook() {
        System.out.println("Address Book:");
        for (Contact contact : contacts) {
            System.out.println(contact);
        }
    }

    public static void main(String[] args) {
        AddressBook addressBook = new AddressBook();
        Scanner scanner = new Scanner(System.in);

        // Adding contacts to the address book
        addressBook.addContact(new Contact("John Doe", "123-456-7890", "john.doe@email.com"));
        addressBook.addContact(new Contact("Jane Smith", "987-654-3210", "jane.smith@email.com"));

        // Displaying the address book
        addressBook.displayAddressBook();

        // Searching for a contact by name
        System.out.print("Enter a name to search: ");
        String searchName = scanner.nextLine();
        Contact searchedContact = addressBook.getContactByName(searchName);

        if (searchedContact != null) {
            System.out.println("Contact found: " + searchedContact);
        } else {
            System.out.println("Contact not found.");
        }

        scanner.close();
    }
}


if we want to add any object to the SortedSet , that should be 
 -homogenious and comparable objects
 

Student.java:
`````````````````
package com.techm.cfw;

import java.util.Objects;

public class Student implements Comparable<Student>{

	@Override
	public int hashCode() {
		return Objects.hash(stid, stname);
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Student other = (Student) obj;
		return stid == other.stid && Objects.equals(stname, other.stname);
	}
	private Integer stid;
	private String stname;
	
	public Student(int stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	
	public Student() {
		super();
	}
	public Integer getStid() {
		return stid;
	}
	public void setStid(Integer stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	public String toString()
	{
		return stid + " " +stname;
	}

	@Override
	public int compareTo(Student o) {
		//return this.getStname().compareTo(o.getStname());
		
	    // return this.getStid().compareTo(o.getStid());
		
		if(this.getStid()>o.getStid()) {
			return +9;
		}
		else if(this.getStid()<o.getStid())
		{
			return -9;
		}
		else
		{
			return 0;
		}
	}
}

Test5.java:
````````````
package com.techm.cfw;

import java.util.TreeSet;

public class Test5 {

	
	public static void main(String[] args) {
		
		TreeSet<Student> ts = new TreeSet<Student>();
		
		
		Student st2 = new Student(10,"girija");
		Student st3 = new Student(102,"swaroop");
		Student st1 = new Student(76,"chanda");
		
		ts.add(st1);
		ts.add(st2);
		ts.add(st3);
		
		System.out.println(ts);
		
		
	}
}


my requirement is i want to retrieve the student data based on the 
student name in descending order?

Comparator

 ->it is a predefined interface 
 ->java.util 
 ->compare()
 
Test5.java:
````````````
package com.techm.cfw;

import java.util.TreeSet;

public class Test5 {

	
	public static void main(String[] args) {
		
		TreeSet<Student> ts = new TreeSet<Student>(new MyComparator());
		
		
		Student st2 = new Student(10,"girija");
		Student st3 = new Student(102,"swaroop");
		Student st1 = new Student(76,"chanda");
		
		ts.add(st1);
		ts.add(st2);
		ts.add(st3);
		
		System.out.println(ts);
		
		
	}
}

MyComparator.java:
```````````````````
package com.techm.cfw;

import java.util.Comparator;

public class MyComparator implements Comparator<Student> {

	@Override
	public int compare(Student o1, Student o2) {
		
		return o2.getStname().compareTo(o1.getStname());
		
	}

}


task:
reimplement the same program but i want the data based on the student id
in descending order for this try to create one separate comparator class 
and pass this to the TreeSet constructor and observe the output?


Seralization & Deserialization:

Serialization is the process of writing the object data into a network 
supported file format is known as serialziation 

to achieve this we should use ObjectOuputStream and writeObject()

Deserialization
it is the process of reading the object data from network supported 
file is known as Deserialization.

to achieve this we should use one predefined class 
which is available in java.io package 

 i.e ObjectInputStream 
     readObject()
	 
note: 
to achieve this serialzition, corresponding class must be implements 
from Serializable interface (marker interface) otherwise we will get 
exception saying that java.io.NotSerializableException.


Student.java:
````````````
package com.techm.filehandling;

import java.io.Serializable;

public class Student implements Serializable {
	
	private transient int stid;
	private String stname;
	
	@Override
	public String toString() {
		return "Student [stid=" + stid + ", stname=" + stname + "]";
	}
	public Student() {
		super();
	}
	public Student(int stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	
	
	

}

Test4.java:
```````````
package com.techm.filehandling;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;

public class Test4 {
	
	public static void main(String[] args) throws FileNotFoundException, IOException {
		
		
		ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("ser.txt"));
	
		Student st1 = new Student(100,"safia");
		
	    oos.writeObject(st1);
	    
	    System.out.println("serialization process has done");
	
	}

}

Test5.java:
`````````````
package com.techm.filehandling;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.ObjectInputStream;

public class Test5 {
	
	public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException {
		
		ObjectInputStream ois = new 
				ObjectInputStream(new FileInputStream("ser.txt"));
		
		Student stu =(Student) ois.readObject();
		
		System.out.println("student id is: " + stu.getStid());
		System.out.println("student name is: " + stu.getStname());
		
	}

}

note:
transient is the java reserved keyword which is used to 
restrict the specific property  in 


Map:
````
Map is the predefined interface available in java.util pacakge 

 purpose: to organize the data in the form (key,value) pairs
 
 key -Object 
 value -Object 
 
 
 add() 
 put(.,.)
 


Map m = new Map();//invalid 

   HashMap 
   LinkedHashMap 
   
   
 properties:
 ````````````
 1.insertion order is not preserved
 2.null insertion is possible 
 3.duplicate key objects are not allowed where as duplicate value
   objects are allowed
 4.it allows both homogenious and heterogenious objects
 
 

HashMap in case of HashMap, insertion order is not preserved
in case of LinkedHashMap, insertion order is preserved means in which 
order we inserte in the same order we will get it.

package com.techm.cfw;

import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

public class Test6 {
	
	public static void main(String[] args) {
		
		//create the obejct for Map 
		Map<Integer,String> m= new LinkedHashMap<Integer,String>();
		
		//add the pair(key,value) 
		
		m.put(100, "chanda");
		m.put(78, "anushka");
		m.put(65, "swaroop");
		m.put(567, "rk");
		m.put(null, null);
		m.put(100, "safia");
		m.put(230, "safia");
		
		System.out.println(m);
		
		m.replace(230, "jahnavi");
		
		System.out.println(m);
		
		m.remove(null);
		System.out.println(m);
		
		System.out.println(m.get(567));
		
		Set<Entry<Integer,String>> s = m.entrySet();
		System.out.println(s);
		
		Iterator<Entry<Integer,String>> itr = s.iterator();
		
		while(itr.hasNext())
		{
			System.out.println(itr.next());
		}
		
		System.out.println("===================");
		for(Map.Entry<Integer,String> me:m.entrySet())
		{
			System.out.println(me.getKey() +  " " + me.getValue());
		}
		
	}

}




SortedMap:
```````````

interface SortedMap extends Map{
}
  ->TreeMap
  
  class TreeMap implements SortedMap extends Map{
  }
  
properties:
it allows only homogenious objects 
duplicate key objects  are not allowed 
null insertion is not possible
sorted the data based on key objects 


Test7.java:
```````````
package com.techm.cfw;

import java.util.TreeMap;

public class Test7 {
	
	public static void main(String[] args) {
		
		TreeMap<Student,String> tm = new TreeMap<Student,String>(new MyComparator());
		
		Student st1 = new Student(100,"Rama");
		Student st2 = new Student(89,"Techm");
		
		tm.put(st1, "anushka");
		tm.put(st2, "ankush");
		
		
		System.out.println(tm);
	}

}

Student.java:
``````````````
package com.techm.cfw;

import java.util.Objects;

public class Student {

	@Override
	public int hashCode() {
		return Objects.hash(stid, stname);
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Student other = (Student) obj;
		return stid == other.stid && Objects.equals(stname, other.stname);
	}
	private Integer stid;
	private String stname;
	
	public Student(int stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	
	public Student() {
		super();
	}
	public Integer getStid() {
		return stid;
	}
	public void setStid(Integer stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	public String toString()
	{
		return stid + " " +stname;
	}	
}

MyComparator.java:
```````````````````
package com.techm.cfw;

import java.util.Comparator;

public class MyComparator implements Comparator<Student> {

	@Override
	public int compare(Student o1, Student o2) {
		
		return o1.getStname().compareTo(o2.getStname());
		
	}

}



java 8 features:
`````````````````
lambda expression:


it is a concise way to express an anonymous function 


(a function without a name)


1.it doesn't have name
2.it doesn't have any returntype
3.it doesn't have any access modifier


  public void sum()
  {
  System.out.println("sum method");
  }
  
  () -> { System.out.println("sum method");}
  
    () ->  System.out.println("sum method");

  public void sum(int x, int y)
  {
  System.out.println(x+y);
  }


   (int x, int y) -> System.out.println(x+y);
   
   (x,y)->System.out.println(x+y);
   

  public int sum(int x, int y)
  {
    return x+y;
  }

  (x,y)->x+y;


  public String getName(String name)
  {
    return name;
  }

  (x)->x;
  
  x ->x;

functional interface:

it is an interface which contains only single abstract method 
and it may contains several default and static methods(introducted 
java8 onwards only)

@FunctionalInterface
interface i1{
void m1();
}


note:
lambda expressions are often used with functional interfaces, 
which are interfaces with a single abstract method.

The lambda expression provides a more concise way to implement 
the method of the functional interface.

package com.techm.java8;

@FunctionalInterface
public interface i1 {
	
	void m1();
	

}

Test1.java:
`````````````
package com.techm.java8;
//execution logic class 
public class Test1 {
//void m1();
public static void main(String[] args) {
		
		i1 obj = ()->System.out.println("welcome");
		obj.m1();
	}
}


package com.techm.java8;

@FunctionalInterface
public interface i1 {
	
	int sqare(int x);
	

}

package com.techm.java8;
//execution logic class 
public class Test1 {
//	int sqare(int x)
public static void main(String[] args) {
		
		i1 obj = r->r*r;
	
		System.out.println("square of given no is: " + obj.sqare(4));
		
	}
}


------
package com.techm.java8;

import java.util.Objects;

public class Student {

	@Override
	public int hashCode() {
		return Objects.hash(stid, stname);
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Student other = (Student) obj;
		return stid == other.stid && Objects.equals(stname, other.stname);
	}
	private Integer stid;
	private String stname;
	
	public Student(int stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	
	public Student() {
		super();
	}
	public Integer getStid() {
		return stid;
	}
	public void setStid(Integer stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	public String toString()
	{
		return stid + " " +stname;
	}

	
	
}
Test2.java:
```````````
package com.techm.java8;

import java.util.TreeSet;

public class Test2 {
//int compare(T o1, T o2);
	public static void main(String[] args) {
		
		TreeSet<Student> ts = new TreeSet<Student>(
				(o1,o2)->o2.getStname().compareTo(o1.getStname())
				
				);
		Student st1 = new Student(10,"rk");
		Student st2 = new Student(67,"safia");
		Student st3 = new Student(82,"ankush");
		Student st4 = new Student(87,"girija");
		
		ts.add(st1);
		ts.add(st2);
		ts.add(st3);
		ts.add(st4);
		
		System.out.println(ts);
	}
}



Consumer Functional Interface
``````````````````````````````
Consumer<T> is an in-built functional interface introduced in Java 8.
Consumer can be used in all contexts where an object needs to be consumed
i.e taken as input, and some operation is to be performed on the object
without returning any result

*Performs this operation on the given argument.
 *@param t the input argument
 *
void accept(T t);


-----------
Predicate Functional Interface:

This functional interface used for conditioanl check 

where you think, we can use these true/false returning functions 
in day to day programming we should choose predicate

/*
evaluates this predicate on the given argument 
@param the input argument 
*/
boolean test(T t)
-----------------------------

Supplier Functional Interface
Supplier can be used in all contexts where there is no input 
but an output is expected.

/**
Gets a result
@return a result
*/
T get()

-----------------------------------

import java.util. function. Consumer;
public class ConsumerDemo implements Consumer(Integer>
     @Override
     public void accept(Integer t) {
         System.out.printin("Printing + " + t);
     )
         I
     public static void main(String() args) {

}
}

------------
import java.util.function.Consumer;
 public class ConsumerDemo {
     public static void main(String[] args) {
        Consumer<Integer> consumer - (t) -> {
            System.out.println("Printing : + t);
         );
        consumer.accept(10);
		
		List<Integer> list1 = Arrays.asList(1,2,3,4,5);
		list1.stream().forEach(consumer);
		
}}

-----------------
import java.util. function. Predicate;
public class PredicateDemo implements Predicate<Integer> (

@override
public boolean test(Integer t){
  if(t%2==0){
  return true;}
  else{
  return false;
  }
}
public static void main(String[] args){

   Predicate<Integer> predicate = new PredicateDemo();
   System.out.println(predicate.test(5));
}
}
 
----
public class PredicateDemo{
  public static void main(String[] args){
     Predicate<Integer> predicate = (t)->t%2==0;
	 System.out.println(predicate.test(5));
	 
	    List<Integer> list1 = Arrays.asList(1,2,3,4,5);
		list1.stream().filter(t->t%2==0).forEach(t->System.out.println("Print Even: " + t));
		}
}
 

------------------
public class SupplierDemo implements Supplier<String>
{
   @Override
   public String get()
   {
     return "Hi Techm";
   }
   public static void main(String[] args)
   {
      Supplier<String> supplier = new SupplierDemo();
	  System.out.println(supplier.get());
   }



}

---------------------------

public class SupplierDemo 
{
   
   public static void main(String[] args)
   {
      Supplier<String> supplier = ()-> "welcome techm";
	  System.out.println(supplier.get());
	  
	  List<String> list1 = Arrays.asList("a","b");
	  System.out.println(list1.stream().findAny().orElseGet(supplier));
	  
   }



}
 

Function:
Function is the predefined functional interface which contains one functional 
method is apply(Object o);

apply method is taking one object and returning one object. 

package com.techm.java8;

import java.util.function.Function;

public class FunctionDemo implements Function<String, String> {

	@Override
	public String apply(String t) {
		return t.toUpperCase();
	}
	
	public static void main(String[] args) {
		
		Function<String,String> function = new FunctionDemo();
		System.out.println("uppercase string value is: " + function.apply("techm"));
		
	}

}


using lambda expression:
package com.techm.java8;

import java.util.function.Function;

public class FunctionDemo {


	
	public static void main(String[] args) {
		
		Function<String,String> function =t->t.toUpperCase();
		System.out.println("uppercase string value is: " + function.apply("techm-pune"));
		
		List<String> list1 = Arrays.asList("rk","chanda","jahnavi","twinkle","swaroop");
		list1.stream().map(t->t.toUpperCase()).forEach(t->System.out.println(t));
	}

}


Stream API In Java

Stream API is used to process collection of objects.

A stream is a sequence of objects that supports various methods
which can be pipelined together to produce the desired result.

A stream is not a data structure instead it takes input from the
Collections, Arrays or I/O channels.

Streams dont change the original data structure, they only
provide the result as per the pipelined methods.


why we need stream?
  Functional Programming 
  Code Reduce
  Bulk operation
  
  
  
filter - for conditional check 
foreach - for iteration 




forEach and filter():

 class Test1{
  public static void main(String[] args)
  {
   List<String> list = new ArrayList<String>();
   list.add("Murthy");
   list.add("jagan");
   list.add("pavan");
   list.add("mohan");
   list.add("madhu");
   
   for(String s:list)
   {
      //System.out.println(s);
	  if(s.startsWith("m")){
	    System.out.println(s);
	  }
   }
   list.stream().filter(t->t.startsWith("m")).forEach(t->System.out.println(t));
   
   Map<Integer,String> map = new HashMap<>();
   map.put(1,"a");
   map.put(2,"b");
   map.put(3,"c");
   map.put(4,"d");
   map.forEach((key,value)->System.out.println(key+ ": " +value));
   map.entrySet().stream().forEach(obj->System.out.println(obj));
   map.entrySet().stream().filter(t->t.getKey()%2==0).forEach(t->System.out.println(t));
  }
  }


Employee.java:
```````````````
public class Employee {

	private int id;
	private String name;
	private String dept;
	private long salary;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getDept() {
		return dept;
	}

	public void setDept(String dept) {
		this.dept = dept;
	}

	public long getSalary() {
		return salary;
	}

	public void setSalary(long salary) {
		this.salary = salary;
	}

	public Employee(int id, String name, String dept, long salary) {
		super();
		this.id = id;
		this.name = name;
		this.dept = dept;
		this.salary = salary;
	}

	public Employee() {
		super();
		// TODO Auto-generated constructor stub
	}

	@Override
	public String toString() {
		return "Employee [id=" + id + ", name=" + name + ", dept=" + dept + ", salary=" + salary + "]";
	}

}

DataBase.java:
````````````````
import java.util.ArrayList;
import java.util.List;
//DAO layer
public class DataBase {

	public static List<Employee> getEmployees() {
		List<Employee> list = new ArrayList<>();
		list.add(new Employee(176, "Roshan", "IT", 600000));
		list.add(new Employee(388, "Bikash", "CIVIL", 900000));
		list.add(new Employee(470, "Bimal", "DEFENCE", 500000));
		list.add(new Employee(624, "Sourav", "CORE", 400000));
		list.add(new Employee(176, "Prakash", "SOCIAL", 1200000));
		return list;
	}

}

TaxService.java:

import java.util.List;
import java.util.stream.Collectors;

public class TaxService {

	public static List<Employee> evaluateTaxUsers(String input) {
		return (input.equalsIgnoreCase("tax"))
				? DataBase.getEmployees().stream().filter(emp -> emp.getSalary() > 500000).collect(Collectors.toList())
				: DataBase.getEmployees().stream().filter(emp -> emp.getSalary() <= 500000)
						.collect(Collectors.toList());

	}

	public static void main(String[] args) {
		System.out.println(evaluateTaxUsers("tax"));
	}
}


-----------------------------
package com.techm.java8;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class Sorting_Demo {
	
	public static void main(String[] args) {
		
		List<Integer> list = new ArrayList<>();
		list.add(8);
		list.add(3);
		list.add(12);
		list.add(4);
		
		/*
		 * Collections.sort(list); 
		 * System.out.println(list); 
		 * Collections.reverse(list);
		 * System.out.println(list);
		 */
		
		//list.stream().sorted().forEach(obj->System.out.println(obj));
		
		//list.stream().sorted((o1,o2)->o2.compareTo(o1)).forEach(obj->System.out.println(obj));
		//list.stream().sorted(Comparator.reverseOrder()).forEach(obj->System.out.println(obj));
		
		List<Employee> list_employees = DataBase.getEmployees();
		list_employees.stream().sorted((o1,o2)->o2.getSalary().compareTo(o1.getSalary())).forEach(obj->System.out.println(obj));
	}

}

How to Sort a map using lambda:
`````````````````````````````````
package com.techm.java8;

import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;

public class Map_Demo {
	
	public static void main(String[] args) {
		
		Map<String,Integer> map = new HashMap<String,Integer>();
		map.put("eight", 8);
		map.put("four", 4);
		map.put("ten", 10);
		map.put("two", 2);
		
		//map.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(obj->System.out.println(obj));
		//map.entrySet().stream().sorted(Map.Entry.comparingByValue()).forEach(obj->System.out.println(obj));
	
		
		Map<Employee,Integer> map1 = new HashMap<>();
		map1.put(new Employee(176, "Roshan", "IT", 600000), 60);
		map1.put(new Employee(388, "Bikash", "CIVIL", 900000), 90);
		map1.put(new Employee(470, "Bimal", "DEFENCE", 500000), 50);
		map1.put(new Employee(624, "Sourav", "CORE", 400000), 40);
		map1.put(new Employee(176, "Prakash", "SOCIAL", 1200000), 120);
		
		
		map1.entrySet().stream().sorted(Map.Entry.comparingByKey((o1,o2)->o2.getName().compareTo(o1.getName()))).forEach(obj->System.out.println(obj));
		
	}

}
======================================================================
		
		

map() & flatMap()
```````````````````

* Java 8 stream API provides map() and flatMap() method. Both
these methods are intermediate methods and returns another
stream as part of the output.

* map() method used for transformation

* flatMap() used for transformation & flattening


  flatMap()->map()+flattening


Customer.java:
`````````````
public class Customer {

    private int id;
    private String name;
    private String email;
    private List<String> phoneNumbers;

    public Customer() {
    }

    public Customer(int id, String name, String email, List<String> phoneNumbers) {
        this.id = id;
        this.name = name;
        this.email = email;
        this.phoneNumbers = phoneNumbers;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public List<String> getPhoneNumbers() {
        return phoneNumbers;
    }

    public void setPhoneNumbers(List<String> phoneNumbers) {
        this.phoneNumbers = phoneNumbers;
    }
}
------------------------
import java.util.List;
import java.util.stream.Collectors;

public class MapVsFlatMap {
    public static void main(String[] args) {

        List<Customer> customers = EkartDataBase.getAll();

        //List<Customer>  convert List<String> -> Data Transformation
        //mapping : customer -> customer.getEmail()
        //customer -> customer.getEmail()  one to one mapping
        List<String> emails = customers.stream()
                .map(customer -> customer.getEmail())
                .collect(Collectors.toList());
        System.out.println(emails);

//customer -> customer.getPhoneNumbers()  ->> one to many mapping
        //customer -> customer.getPhoneNumbers()  ->> one to many mapping
        List<List<String>> phoneNumbers = customers.
                stream().map(customer -> customer.getPhoneNumbers())
                .collect(Collectors.toList());
        System.out.println(phoneNumbers);

        //List<Customer>  convert List<String> -> Data Transformation
        //mapping : customer -> phone Numbers
        //customer -> customer.getPhoneNumbers()  ->> one to many mapping
        List<String> phones = customers.stream()
                .flatMap(customer -> customer.getPhoneNumbers().stream())
                .collect(Collectors.toList());
        System.out.println(phones);
    }
}
--------------

EkartDataBase.java:
`````````````````````
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class EkartDataBase {


    public static List<Customer> getAll() {
        return Stream.of(
                new Customer(101, "john", "john@gmail.com", Arrays.asList("397937955", "21654725")),
                new Customer(102, "smith", "smith@gmail.com", Arrays.asList("89563865", "2487238947")),
                new Customer(103, "peter", "peter@gmail.com", Arrays.asList("38946328654", "3286487236")),
                new Customer(104, "kely", "kely@gmail.com", Arrays.asList("389246829364", "948609467"))
        ).collect(Collectors.toList());
    }


}

jdbc:
java database connectivity

jdbc is a technology given by sunmicrosystem 

 it means they are providng only specifications 
 
 how can we declare the specifications? 
  in the form of interfaces
  
  java.sql 
  
  
     Connection 
	 Statement 
	 PreparedStatement
	 ResultSet
	 ResultSetMetaData.....
	 CallableStatement...
	 

who will providing the implementation classes for this jdbc technology?

  oracle
  mysql
  sybase
  ingress
  redhat
  postgresql ... 
  
     in the form of jar files 
	 
	 
Statement -> 


if we really want to write any jdbc program corresponding jar file 
we need to add to the project. 

ClassNotFoundException 

oracle -> ojdbc6.jar

mysql -> mysqlconnector.jar 

 





how can we add the jar file to the java project:

right click 

build path 

configure buildpath

libraries

select classpath 

add external jars 

specify the location 

add it 


steps to follow to write the jdbc program:
``````````````````````````````````````````
1.load the driver class .

   Class.forName("driverclassname");
   mysql:
   Class.forName("com.mysql.cj.jdbc.Driver");

2.obtain the connection from the db.

3.we have to send the queries by creating the object for Statement

4.process the queries  by invoking corresponding method(s) like executeUpdate()...


5.close the connection 
  

example:
`````````
package com.techm.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;

public class Test1 {
	
	public static void main(String[] args) throws ClassNotFoundException, SQLException {
		
		//load the driver class 
		Class.forName("com.mysql.cj.jdbc.Driver");
		System.out.println("driver class loaded");
		
		//obtain the connection from the db
		Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/techm", "root", "root");
		System.out.println("i got the connection from the db");
		
		//to send the sql queries from java to db
		Statement st = con.createStatement();
		
		//process the queries
		
		int x = st.executeUpdate("insert into student values(101,'chanda')");
		System.out.println(x + "row(s) inserted");
		
		//close the connection 
		con.close();
		
		
	}

}

executeUpdate() is avaialble in Statement interface for the purpose of
processing nonselect queries. and the return type is int.

insert 
update 
delete 
  -non select queries
  
  select * from student;
  

how to process the select queries:

package com.techm.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class Test1 {
	
	public static void main(String[] args) throws ClassNotFoundException, SQLException {
		
		//load the driver class 
		Class.forName("com.mysql.cj.jdbc.Driver");
		System.out.println("driver class loaded");
		
		//obtain the connection from the db
		Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/techm", "root", "root");
		System.out.println("i got the connection from the db");
		
		//to send the sql queries from java to db
		Statement st = con.createStatement();
		
		//process the queries
		
		//int x = st.executeUpdate("insert into student values(102,'ankush')");
		
		//int x = st.executeUpdate("update student set stname='rk' where stid=100");
		
		ResultSet rs = st.executeQuery("select * from student");
		
		
		while(rs.next())
		{
			System.out.println(rs.getInt(1) + " " + rs.getString(2)); 
		}
		//close the connection 
		con.close();
		
		
	}

}

how to process non select queries 
how to process select queries 


static query and dynamic query:

  insert into student values(100,'rama');
  

how can i process dynamic queries?

   insert into student values(?,?);
   
by using which object it is possible to process dynamic queries?

  note:
  by using which object we are able to process static queries?
  
     Statement object 
	 
   note:
   by using which object we are able to process dynamic queries?
   
     PreparedStatement object 
	    
		  PreparedStatement ps = con.prepareStatement();


package com.techm.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Scanner;

public class Test1 {
	
	public static void main(String[] args) throws ClassNotFoundException, SQLException {
		
		//load the driver class 
		Class.forName("com.mysql.cj.jdbc.Driver");
		System.out.println("driver class loaded");
		
		//obtain the connection from the db
		Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/techm", "root", "root");
		System.out.println("i got the connection from the db");
		
		//create the object for PreparedStatement 
		PreparedStatement ps = con.prepareStatement("insert into student values(?,?)");
		
		
		Scanner s = new Scanner(System.in);
		System.out.println("enter student id:");
		int x= s.nextInt();
		ps.setInt(1, x);
		System.out.println("enter student name:");
		String y = s.next();
		ps.setString(2, y);
		
		int p= ps.executeUpdate();
		
		System.out.println(p+ "row(s) inserted");
		//close the connection 
		con.close();
		
		
	}

}

how to fetch metadata in jdbc using ResultSetMetaData:
``````````````````````````````````````````````````````````
package com.techm.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;

public class Test1 {
	
	public static void main(String[] args) throws ClassNotFoundException, SQLException {
		
		//load the driver class 
		Class.forName("com.mysql.cj.jdbc.Driver");
		System.out.println("driver class loaded");
		
		//obtain the connection from the db
		Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/techm", "root", "root");
		System.out.println("i got the connection from the db");
		
		Statement st = con.createStatement();
		
		ResultSet rs = st.executeQuery("select * from student");
		
		ResultSetMetaData rsmd = rs.getMetaData();
		
		
		System.out.println("no.of columns :  " + rsmd.getColumnCount());
		
		for(int i=1;i<=rsmd.getColumnCount();i++)
		{
			System.out.println(rsmd.getColumnName(i) + " " + rsmd.getColumnTypeName(i) + " " + rsmd.getPrecision(i));
		}
		
		
		
		//close the connection 
		con.close();
		
		
	}

}



Test1.java
````````````
package com.techm.jdbc;

import java.io.FileInputStream;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

public class Test1 {
	
	public static void main(String[] args) throws ClassNotFoundException, SQLException, IOException {
		
		FileInputStream  fis = new FileInputStream("E:\\techm-dec-8-2023\\corejava\\src\\db1.properties");
		
		Properties properties = new Properties();
		
		
		properties.load(fis);
		
		String driver= properties.getProperty("jdbc.driver");
		String url = properties.getProperty("jdbc.url");
		String username = properties.getProperty("jdbc.username");
		String password= properties.getProperty("jdbc.password");
		
		Class.forName(driver);
		Connection con = DriverManager.getConnection(url, username, password);
		
		System.out.println("Got the connection ");
		
		Statement st = con.createStatement();
		
		int x = st.executeUpdate("insert into student values(500,'rama')");
		System.out.println(x + "row(s) inserted");
		//close the connection 
		con.close();
		
		
	}

}
db.properties:
```````````````
jdbc.driver=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/techm
jdbc.username=root
jdbc.password=root


multithreading in java
````````````````````````
java is multithreaded progrmming language 

how can we say it is multithreaded programming langugage?

 in java, default it contains one main thread 
 
  thread: it is like a task 
  a smallest unit of execution within a process. 
  
  
example:
````````````
package com.techm.multithreading;

public class Test1 extends Thread{
	//to provide the logic for thread
	public void run()
	{
		for(int i=1;i<=10;i++)
		{
			System.out.println(Thread.currentThread().getName() + "-->" + i);
		}
		
	}
	
	public static void main(String[] args) {
		
		
		
		//create the thread 
		Test1 obj  = new Test1();
		obj.setName("rk");
		obj.start();
		
		
		Test1 obj1 = new Test1();
		obj1.setName("chanda");
		obj1.start();
	
	}

}

output:
``````````
rk-->1
chanda-->1
rk-->2
chanda-->2
rk-->3
rk-->4
chanda-->3
rk-->5
chanda-->4
rk-->6
chanda-->5
rk-->7
chanda-->6
rk-->8
chanda-->7
rk-->9
chanda-->8
rk-->10
chanda-->9
chanda-->10

example:
```````````
package com.techm.multithreading;

public class Test1 extends Thread{
	//to provide the logic for thread
	public void run()
	{
		for(int i=1;i<=10;i++)
		{
			System.out.println(Thread.currentThread().getName() + "-->" + i);
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		
	}
	
	public static void main(String[] args) throws InterruptedException {
		
		
		
		//create the thread 
		Test1 obj  = new Test1();
		obj.setName("rk");
		obj.start();
		
		for(int i=1;i<=10;i++)
		{
			System.out.println(Thread.currentThread().getName() + "-->" + i);
			Thread.sleep(500);
		}
		
	}

}



Test1.java:
`````````````
package com.techm.multithreading;

public class Test1 extends Thread{
	//to provide the logic for thread
	public void run()
	{
		System.out.println("test1 thread");
		
	}

}

Test2.java:
````````````
package com.techm.multithreading;

public class Test2  implements Runnable
{
  public void run()
  {
	  
	  System.out.println("Test2 thread");
  }
  
  
}

Test3.java:
````````````
package com.techm.multithreading;

public class Test3 {
	
	public static void main(String[] args) {
		
		Test1 obj1 = new Test1();
		//create the Runnable object
		Test2 obj2 = new Test2();
		//convert Runnable object into Thread object 
		
		Thread t2 = new Thread(obj2);
		
		obj1.start();
		t2.start();
	}

}


synchronization:
````````````````
when we have multple threads are trying to access the shared resource 
it gives the allowness to only one thread at a time, this concept is known 
as synchronization

to achieve this synchronization in java, we have 

 synchrnized methods 
 synchronized block 
 static synchrnozation 
 
Test1.java:
````````````
package com.techm.multithreading;

public class Test1 extends Thread{
	
	Table t;
	Test1(Table t)
	{
		this.t=t;
	}
	public void run()
	{
		t.printTable(5);
	}
	

}

Test2.java:
``````````````
package com.techm.multithreading;

public class Test2  extends Thread
{
	Table t;
	public Test2(Table t)
	{
		this.t=t;
	}
  public void run()
  {
	  
	 t.printTable(6);
  }
  
}

Table.java:
``````````````
package com.techm.multithreading;

public class Test3 {
	
	public static void main(String[] args) {
		
		Table obj = new Table();
		Test1 t1 = new Test1(obj);
		Test2 t2 = new Test2(obj);
		t1.start();
		t2.start();
	}

}

Table.java:
``````````````
package com.techm.multithreading;

public class Table {
	//synchronized
	public synchronized void printTable(int n)
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println(n*i);
		}
		try {
			Thread.sleep(500);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

}

junit:

junit is a widely used open-source testing framework for java. 

 
junit is commonly used for unit testing in java applications to ensure 
the reliablity and correctness of the code. 

current version of junit5

we can use these annotations to configure and control the behaviour of your 
tests. 

1.@Test
2.@BeforeEach
3.@AfterEach
4.@BeforeAll
5.@AfterAll
6.@DisplayName
7.@Disabled
8.@Tag
9.@RepeatedTest
10.@ParameterizedTest


package com.techm.junit;

public class Calculator {

	 public int sum(int x, int y)
	 {
		 return x+y;
	 }
	 
	 public int mul(int x, int y)
	 {
		 return x*y;
	 }
}


TestCalculator.java:
```````````````````````
package com.techm.junit;

import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

class TestCalculator {
static Calculator calc;

 @BeforeAll
	public static void setUp()
	{
		calc = new Calculator();
	}
	
	@Test
	@DisplayName("testing sum method")
	void testSum() {

		
		int result = calc.sum(4, 5);
		assertEquals(9, result);		
	}
	
	@Test
	@DisplayName("testing mul method")
	void testMul()
	{
		
		int result = calc.mul(4, 5);
		assertEquals(20, result);
	}
	
	@AfterAll
	public static void tearDown()
	{
		calc = null;
	}

}



ant
maven
gradle 
  - build automation tools 
  
  automation
     -compiling source code 
	 -managing dependencies
	 -packaging the software (jar or war)
	 -saving time
	 
  dependency maangement 
  
  
  
 @ParameterizedTest:
 allows you to run a test multiple times with different arguments
 
naming convention

 //test<System under Test> _<condition or state change>_<expected result>
 
 testIntegerDivision_WhenFourIsDividedByTwo_ShouldReturnTwo()
 

MathUtils.java:
``````````````````
package com.techm;

public class MathUtils {
	public static int divide(int dividend,int divisor) {
		
		if(divisor==0) {
			throw new ArithmeticException("cannot divide by zero");
		}
		return dividend/divisor;
		
	}

}

TestMathUtils.java:
````````````````````
package com.techm;

import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.Test;

class TestMathUtils {

	@Test
	void testDivideByZero() {
		
		assertThrows(ArithmeticException.class,()->{
			
			MathUtils.divide(10, 0);
		});
	}
	
	@Test
	public void testDivide()
	{
		int result = MathUtils.divide(10,2);
		assertEquals(5, result);
	}

}

------------------------------
package com.techm;

import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;


class TestMathUtilsParameterized
{
	@ParameterizedTest
	@CsvSource({"10,2,5","12,4,3","8,2,4"})
	void testDivide(int dividend,int divisor,int expectedQuotient) {
		
		int result = MathUtils.divide(dividend,divisor);
		
		assertEquals(expectedQuotient, result,()->"unexpected result for divide operation");
	}

}


to work with @ParameterizedTest and @CsvSource annotations,in pom.xml file 
we have to the following dependency



       <dependency>
			<groupId>org.junit.jupiter</groupId>
			<artifactId>junit-jupiter-api</artifactId>
			<version>5.10.1</version>
			<scope>test</scope>

		</dependency>
		<dependency>
			<groupId>org.junit.jupiter</groupId>
			<artifactId>junit-jupiter-engine</artifactId>
			<version>5.10.1</version>
		</dependency>
		<!--
		https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-params -->
		<dependency>
			<groupId>org.junit.jupiter</groupId>
			<artifactId>junit-jupiter-params</artifactId>
			<version>5.10.1</version>
			<scope>test</scope>
		</dependency>


example:
`````````
package com.techm;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.stream.Stream;

import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.CsvFileSource;
import org.junit.jupiter.params.provider.MethodSource;

class TestMathUtilsParameterized {
	@ParameterizedTest
	// @CsvSource({"10,2,5","12,4,3","8,2,4"})
	//@CsvFileSource(resources = "/myfile.csv")
	// @ValueSource(ints = {10,2,5,12,4,3})
	 @MethodSource("dataProvider")
	void testDivide(int dividend, int divisor, int expectedQuotient) {

		int result = MathUtils.divide(dividend, divisor);

		assertEquals(expectedQuotient, result, () -> "unexpected result for divide operation");
	}

	static Stream<Arguments> dataProvider() {
		return Stream.of(Arguments.of(10, 2, 5), Arguments.of(12, 4, 3), Arguments.of(8, 2, 4));
	}

	//@ParameterizedTest
	// @ValueSource(strings = {"rk","abc","xyz"})
	void testValueSource(String x) {
		System.out.println(x);
	}

}


@Order annotation:
``````````````````
package com.techm;

import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;

class OrderExample {

	@Test
	@Order(1)
	void test1() {
		System.out.println("first");
	}

	@Test
	@Order(2)
	void test2() {
		System.out.println("second");
	}
	@Test
	@Order(3)
	void test3() {
		System.out.println("third");
	}



}

git:
```
git is a distributed version control system. 
purpose: source code management 
it tracks changes in files, allowing multiple contributors to collaborate 
on a project.

git repository -storage area 


  clone that repository into your personal workspace
  
  commit that changes into remote git repository 
  
  
git init

  -initializes a new git repository in the current directory.
  
  
github:
GitHub is a code hosting platform for version control and collaboration. 
It lets you and others work together on projects from anywhere.


we commited our directory into local git repository. 

   commit the same to remote repository. 
   
signup 
credentials 
login 


->git init
->git add . 
->git commit -m "message"
->git remote add origin <remoterepository_url>
->git push -u origin master


stesps we are following in case of eclipse:
first maintain  github repository remotely.
open eclipse click on search bar on top right 
search for git 
click on git repostiory
on top of this click on clone git repostiory 
paste the created github repostiroy url
click on next 
click on next
right click on project-> click on team -> click on share project
->select the correct repository from the drop down 
->click on finish 
->right click on project -> click on team -> click on commit
  |
  drage the files from unstaged to staged area
  |
  we should give commit message in the commit area 
  |
  click on push and commit 
  |
  it will ask for github credentials 
  
    user name: .....
	password: 


instead of giving the password better we generate token and then provide 
in place of password 

to generated token , go to developer settings and then generate token 
while we are generating check in repo check box and then generate and give 
the same in password field and then click on finish 


now open your remote repository and you will get all the files 



  ->standalone applications 
  ->web applications 
   
servlet:
````````

servlet is a server side technology given by sunmicrosystem 

implementations are provided by server vendors in the form of jar files. 

 clinet - server architecture
 
  
clinet -> a program from where you are sending the request

server -> a program which is processing your request and gives response back .


without server can i develop any dynamic web application?

  no 
  
  we should require server 
  
 apache tomcat
 ibm weblogic
 jetty
 glasfish
 webspehere
 ... 
 
 WelcomeServlet.java:
 
 package com.techm;

import java.io.IOException;
import javax.servlet.GenericServlet;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.annotation.WebServlet;


@WebServlet("/chanda")
public class WelcomeServlet extends GenericServlet {

	
	public void init()
	{
		System.out.println("welcome to init");
	}
	@Override
	public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
		// TODO Auto-generated method stub
		System.out.println("welcome to service");
	}
	
	public void destroy()
	{
		System.out.println("welcome to destroy");
	}
	
	
	
}

how can we specify servlet url pattern:

  by using @WebServlet annotation on top of servlet class 
  
  always requested url pattern and servlet url pattern must be matched 
  otherwise we willget 404 error. 
  


package com.techm;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.GenericServlet;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.annotation.WebServlet;


@WebServlet("/chanda")
public class WelcomeServlet extends GenericServlet {

	
	
	@Override
	public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
		
		
		PrintWriter pw = res.getWriter();
		
		pw.println("welcome to servlet technology");
		
	}
	
	
	
	
}





<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>form-handling</title>
</head>
<body>

<form action="formservlet">

Enter firstno:  <input type="text" name="fno"/><br/>
Enter secondno: <input type="text" name="sno"/><br/>

<input type="submit" value="sum"/>

</form>

</body>
</html>

FormServlet.java:
````````````````````
package com.techm;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.GenericServlet;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.annotation.WebServlet;

/**
 * Servlet implementation class FormServlet
 */
@WebServlet("/formservlet")
public class FormServlet extends GenericServlet {

	@Override
	public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
		
		int s1 = Integer.parseInt(req.getParameter("fno"));
		int s2 = Integer.parseInt(req.getParameter("sno"));
		
		int sum = s1+s2;
		PrintWriter pw = res.getWriter();
		pw.println("the sum of given two no. is:" + sum);
		
	}

}

http://localhost:8080/FormHandlingDemo/formservlet?fno=23&sno=56

http://localhost:8080/FormHandlingDemo/formservlet?fno=23&sno=56


http://localhost:8080/FormHandlingDemo/formservlet

doGet() and doPost()



package com.techm;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class FormServlet
 */
@WebServlet("/formservlet")
public class FormServlet extends HttpServlet {

	@Override
	public void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
		
		int s1 = Integer.parseInt(req.getParameter("fno"));
		int s2 = Integer.parseInt(req.getParameter("sno"));
		
		int sum = s1+s2;
		PrintWriter pw = res.getWriter();
		pw.println("the sum of given two no. is:" + sum);
		
	}

}

<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>form-handling</title>
</head>
<body>

<form action="formservlet" method="post">

Enter firstno:  <input type="text" name="fno"/><br/>
Enter secondno: <input type="text" name="sno"/><br/>

<input type="submit" value="sum"/>

</form>

</body>
</html>



redirecting mechanism:
````````````````````````
when we make a requet to a particular url that will be redirected to a new url 
based on the requrement. 
 
 some oldwebsites -> new websites
 
 endusers are not aware 
 
 when they try to hit the old website url, it is automatically redirected 
 to their migrated new website url .
 
 HttpServletResponse 
 
    sendRedirect()
 

package com.techm;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class RedirectingDemo
 */
@WebServlet("/RedirectingDemo")
public class RedirectingDemo extends HttpServlet {
	
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	
	response.sendRedirect("http://www.google.com");
	
	}

}


servlet and jdbc integration:
`````````````````````````````
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>form-handling</title>
</head>
<body>

<form action="RegisterServlet" method="post">

Enter student id:  <input type="text" name="stid"/><br/>
Enter student name: <input type="text" name="stname"/><br/>

<input type="submit" value="register"/>

</form>

</body>
</html>


RegisterServlet.java:
```````````````````````
package com.techm;

import java.io.IOException;
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class RegisterServlet
 */
@WebServlet("/RegisterServlet")
public class RegisterServlet extends HttpServlet {
	
	public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		try {
		int stid = Integer.parseInt(request.getParameter("stid"));
		String stname = request.getParameter("stname");
		
		Class.forName("com.mysql.cj.jdbc.Driver");
		Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/techm","root","root");
		
		PreparedStatement ps = con.prepareStatement("insert into student values(?,?)");
		ps.setInt(1, stid);
		ps.setString(2, stname);
		
		int x= ps.executeUpdate();
		
		PrintWriter pw = response.getWriter();
		if(x>0) {
		pw.println("registration successfully done");
		}
		else
		{
			pw.println("something went wrong");
		}
		
		con.close();
		}
		catch(Exception e)
		{
			System.out.println(e);
		}
		
		
		
	}

}

how to define the servlet by extends HttpServlet 
doGet vs doPost
redirecting mechanism 
servlet jdbc integration 
SourceServlet.java:

package com.techm;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class SourceServlet
 */
@WebServlet("/SourceServlet")
public class SourceServlet extends HttpServlet {
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	
		PrintWriter pw = response.getWriter();
		pw.println("<h2>Source servlet</h2>");
		pw.println("<p>This is the source servlet</p>");
		
	    
		RequestDispatcher rd = request.getRequestDispatcher("/DestinationServlet");
		
		rd.include(request, response);
		
		
		
	}

}

DestinationServlet.java:
``````````````````````````
package com.techm;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class DestinationServlet
 */
@WebServlet("/DestinationServlet")
public class DestinationServlet extends HttpServlet {
	public  void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		PrintWriter pw = response.getWriter();
		pw.println("<h2>Destination servlet</h2>");
		pw.println("<p>This is the destination servlet</p>");
		
	
	}

}



SourceServlet:
```````````````
package com.techm;

import java.io.IOException;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;


@WebServlet("/SourceServlet")
public class SourceServlet extends HttpServlet {
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	
	//setting an attribute in the request scope
		//request.setAttribute("name", "rk");
		
		//response.getWriter().println(request.getAttribute("name"));
		
		//setting an attibute in the session scope 
		//HttpSession session = request.getSession();
	
    //session.setAttribute("name", "rk");
		
		ServletContext context = getServletContext();
		context.setAttribute("name", "rk");
	    
	}

}

	
TargetServlet.java:
``````````````````````
package com.techm;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class TargetServlet
 */
@WebServlet("/TargetServlet")
public class TargetServlet extends HttpServlet {
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	
	   //String name = (String)request.getAttribute("name");
	   //response.getWriter().println("name is: " + name);
		
		//String name= (String)request.getSession().getAttribute("name");
	    //response.getWriter().println("session value is: " + name);
		
		String name = (String)getServletContext().getAttribute("name");
		response.getWriter().println("application scope value is: " + name);
	}

}


->servlet collaboration 
     RequestDispatcher -forward() and include()
->adding the data into different scopes 
     -request, session and application(ServletContext)
	 
	 
web.xml:
```````````

<?xml version="1.0" encoding="UTF-8"?>
<web-app>

	<servlet>
		<servlet-name>welcome</servlet-name>
		<servlet-class>com.techm.WelcomeServlet</servlet-class>
	</servlet>
	<servlet-mapping>
		<servlet-name>welcome</servlet-name>
		<url-pattern>/welcome</url-pattern>
	</servlet-mapping>
	
	
	
</web-app>


jsp:
````
  java server pages.
  
  
using this technology we also can develop dynamic web based applications 

we are writing the java code using tags

  jsp is a tag based programming language. 
  
  we are using tags. 
  
  
jsp can be divided into three categories of tags 

 
  1. scripting tags
  2. directive tags
  3. action tags/elements
  
  

1.scripting tags
  purpose: to insert the java code 
  


 can be again divided into three types 

   scriptlet tag
   expression tag
   declarative tag
   
     jsp -> servlet only 
	 jsp translator 

where should we write the servlet code?
    src/main/java  
	    =package => servlet 
		
where should we keep our jsp code?

   ->inside webapp folder 
   
   
index.jsp:

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
  <h1>welcome to jsp from techm </h1>
</body>
</html>



scriptlet tag:

<%   java code    %>

whatever the code we are keeping inside scriptlet tag that will be moved 
to _jspService(){} of equivalent generated servlet class. 

expression tag:


<%=  %>

Expression tag is used to display output of the JSP application. 
Scriptlet tag is used to include Java source code. Scriptlet tag 
is mostly used for Form action pages implementation.

example on scripting tags:
````````````````````````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
  
  
  <!-- declarative tag -->
  <%!
     int a=10;
     public static int sum(int x, int y)
     {
    	return x+y; 
     }
  
  %>
  
  <!-- scriptlet tag -->
  <%
     int x=100;
     out.println("x vlaue is: " + x);
     
     
  %>
  <br/>
  <!--  expression tag -->
  
  <%= "welcome to techm " %>
  
  <br/>
  
  <%
  int y= sum(5,6);
 
  %>
  <%= "the sum value is:" + y %>
  
</body>
</html>


directive tags:

these directives help configure and structure the jsp page, providing 
information to the jsp container during the transalation phase. 


   page directive tag
   include directive tag
   taglib directive tag
   
page directive tag:

  defines attributes for the entire jsp page. 
    
  common attributes 
     language 
	 contentType
	 import
	 session 
	 buffer
	 autoFlush
	 isThreadSafe
	 isErrorPage
	 errorPage
	 ... 
	 
syntax:

  <%@ page language="java" contentType="text/html" %>
  
 example:
 
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"
    import="java.util.Date,java.io.InputStream"
    %>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>


<%

out.println("today's date is: " + new Date());
%>
</body>
</html>



include directive:
``````````````````
includes a file at the time the page is translated.
the content of the included file becomes part of the jsp page.

example:

<%@ include file="header.jsp"/>


<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
<h2>welcome to demo jsp page</h2>
</body>
</html>


demo2.jsp:
````````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
  <%@ include file="demo1.jsp" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>

</body>
</html>

taglib directive we are using to implement custom directive tags. 

<%@ taglibe %>

declares a tag library, which defines custom tags used in the jsp page. 


jsp action elements:
```````````````````
these action elements are used to control the flow between pages and to use 
java bean.

  jsp:forward
  jsp:include
  jsp:useBean
  jsp:setProperty
  jsp:getProperty
  jsp:param....
  
  
jsp:forward:


   to forward the request to another resource it may be jsp, 
   html or other resource. 
   
   

<jsp:forward page="">

demo3.jsp:
``````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
<h2>This is demo2 jsp page</h2>
<jsp:forward page="printdate.jsp">

   <jsp:param name="name" value="rk"/>
</jsp:forward>
</body>
</html>
printdate.jsp:
```````````
<%@page import="java.util.Calendar"%>
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
<% out.println("Todays is:" + Calendar.getInstance().getTime()); %>
<%= request.getParameter("name");%>
</body>
</html>

jsp:include action element:
```````````````````````````
it is used to include the content of another resoure it may be jsp,
html,or servlet.

it includes the resource at request time so it is better for dynamic pages
because there might be changes in future.



java bean:
java bean is also a class that should follow some conventions.

 ->it should have no arg constructor
 ->it should provide setter methods and getter methods 


usebean.jsp:
````````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<jsp:useBean id="obj" class="com.techm.Employee"></jsp:useBean>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
<%
obj.setId(100);
obj.setName("rk");
out.println("employee id is: " + obj.getId());
out.println("employee name is: " + obj.getName());
%>
</body>
</html>
Employee.java:
```````````````
package com.techm;

import java.io.Serializable;

public class Employee implements Serializable{
	
	private int id;
	private String name;
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	
	public Employee()
	{
		
	}

}



--------
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>

<form action="process.jsp" method="post">
Enter empid: <input type="text" name="id"/><br/>
Enter empname:<input type="text" name="name"/><br/>
<input type="submit" value="register"/>

</form>
</body>
</html>

------------
package com.techm;

import java.io.Serializable;

public class Employee implements Serializable{
	
	private int id;
	private String name;
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	
	public Employee()
	{
		
	}

}

process.jsp:
``````````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<jsp:useBean id="obj" class="com.techm.Employee"></jsp:useBean>
<%-- <jsp:setProperty property="id" name="obj"/>
<jsp:setProperty property="name" name="obj"/> --%>

<jsp:setProperty property="*" name="obj"/>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
<jsp:getProperty property="id" name="obj"/>
<jsp:getProperty property="name" name="obj"/>
</body>
</html>


mvc 

   model
   view
   controller
   
   
  it is a design pattern that separates 
     business logic, 
	 presentation logic, 
	 and data 
	 

controller acts as an interface between 

   model and view
   
   
 ->controller intrecepts all the incoming requests.
 
 model:
 model represents the state of the application i.e. data.
 
 it also can have business logic. 
 
 view:
 represents the presentation i.e UI(user interface).
 
 1.navigation control is centralized
 2.easy to maintain the large application 
 
 servlet ->as controller
 jsp -> view component
 java bean -> model 
 
 

ControllerServlet.java:
``````````````````````
package com.techm.controller;

import java.io.IOException;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.techm.model.LoginBean;

@WebServlet("/ControllerServlet")
public class ControllerServlet extends HttpServlet {
	public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	
	String name = request.getParameter("name");
	String password= request.getParameter("password");
	
	LoginBean bean = new LoginBean();
	
	bean.setName(name);
	bean.setPassword(password);
	
	request.setAttribute("bean", bean);
	
	boolean status = bean.validate();
	if(status)
	{
		RequestDispatcher rd = request.getRequestDispatcher("login-success.jsp");
		rd.forward(request, response);
	}
	else
	{
		RequestDispatcher rd = request.getRequestDispatcher("login-error.jsp");
		rd.forward(request, response);
	}
	}

}

LoginBean.java:
``````````````
package com.techm.model;

import java.io.Serializable;

public class LoginBean implements Serializable{

	private String name;
	private String password;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getPassword() {
		return password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
	
	public LoginBean()
	{
		
	}
	
	public boolean validate()
	{
		if(password.equals("admin"))
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	
}

index.jsp:
````````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
<form action="ControllerServlet" method="post">

Enter Name: <input type="text" name="name"><br/>
Enter Password: <input type="password" name="password"><br/>
<input type="submit" value="login">


</form>


</body>
</html>

login-error.jsp:
``````````````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
<p>Sorry! username or password error</p>
<%@ include file="index.jsp" %>
</body>
</html>

login-success.jsp:
``````````````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"
    import="com.techm.model.LoginBean"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
<%

LoginBean bean = (LoginBean)request.getAttribute("bean");
out.println("Welcome," + bean.getName());
%>


</body>
</html>


registration application demo:
````````````````````````````
index.jsp:
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
<form action="process.jsp">
User name: <input type="text" name="uname"/><br/>
User email: <input type="text" name="uemail"/><br/>
User password: <input type="password" name="upass"/><br/>
<input type="submit" value="register"/>

</form>
</body>
</html>
process.jsp:
````````````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"
    import="com.techm.dao.RegisterDao"%>
 <jsp:useBean id="obj" class="com.techm.model.User"/>
 <jsp:setProperty property="*" name="obj"/>   
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
<% 
   int status = RegisterDao.register(obj);
    if(status>0)
    	out.println("<h2>You are successfully registerd");
%>
</body>
</html>

User.java:
`````````
package com.techm.model;

import java.io.Serializable;

public class User implements Serializable{

	private String uname,upass,uemail;

	public String getUname() {
		return uname;
	}

	public void setUname(String uname) {
		this.uname = uname;
	}

	public String getUpass() {
		return upass;
	}

	public void setUpass(String upass) {
		this.upass = upass;
	}

	public String getUemail() {
		return uemail;
	}

	public void setUemail(String uemail) {
		this.uemail = uemail;
	}
	public User()
	{
		
	}
}

Provider.java:
``````````````
package com.techm.dao;

public interface Provider {

	String DRIVER="com.mysql.cj.jdbc.Driver";
	String CONNECTION_URL="jdbc:mysql://localhost:3306/techm";
	String USERNAME="root";
	String PASSWORD="root";
	
}

ConnectionProvider.java:
`````````````````````````
package com.techm.dao;

import java.sql.Connection;
import java.sql.DriverManager;

public class ConnectionProvider {

	
	private static Connection con = null;
	
	static
	{
		
		
		try {
			Class.forName(Provider.DRIVER);
			con= DriverManager.getConnection(Provider.CONNECTION_URL, Provider.USERNAME, Provider.PASSWORD);
			
			
			
			
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	
	
	public static Connection getCon()
	{
		return con;
	}
	
}

	

RegisterDao.java:
``````````````
package com.techm.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

import com.techm.model.User;

public class RegisterDao {

	
	public static int register(User obj)
	{
		int status = 0;
		
		
		try {
			Connection con = ConnectionProvider.getCon();
			PreparedStatement ps = con.prepareStatement("insert into user values(?,?,?)");
			ps.setString(1, obj.getUname());
			ps.setString(2, obj.getUemail());
			ps.setString(3, obj.getUpass());
			status = ps.executeUpdate();
			
			
			
			
			
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return status;
		
	}
}


spring framework:
`````````````````
servlet and jsp
 - to give an idea 
 how we can develop the web based applications
 
 jdbc
 servlet
 jsp
    -technologies -> interfaces 
	implementations are provided by 
	database vendors
	server vendors 
	
 
spring:

   spring is an application framework 
   framework = interfaces + implementations
   who gave this spring framework:
   
   rod johnson 
   
   given by which organization:
   
   pivotol 
   
   purpose: 
    
	we can develop both standalone applications + distributed applications
	
core java 
  -standalone applications 
  
servlet & jsp 
   -dynamic web based applications 
   
 then why again spring?
  
   
loosely coupled applications 


class Test
{

  public void display(Integer s)
  {
    sysout("display" + s);
  }
}

class Sum
{
  main()
  {
    Test t = new Test();
	t.display(45);
  }
}

without Test class object, we can't run the Sum class. 
that means both Sum and Test classe(s) are tightly coupled with each other. 

class Test
{

  Test(String s)
  {
  
  }
}

class Sum
{
  main()
  {
    
	
  }
}


Tight coupling refers to a situation where two or more software components are closely connected and depend on each other to function properly. Loose coupling, on the other hand, means that the components are less dependent on each other and can operate more independently





dependency injection:


    through constructor or using setter methods 
	to inject the values. 
	
	  ->constructor injection 
	  ->setter injection 
	  
Now in the technical word, dependency injection is a technique whereby one object (or static method) supplies the dependencies of another object. So, transferring the task of creating the object to someone else and directly using the dependency is called dependency injection.


IOC is Principle & DEPENDENCY injection 


  -INVERSION OF CONTROL 
  
 DEPENDENCY INJECTION 
   -Design Pattern 
   
   
 Spring framework, we have modules 
 it is a modularized aplication framework 

  every module is having some responsibility and purpose. 

   spring core module -base module -standalone application 
spring jdbc module -  persisentence logic -database logic 
spring aop module - cross cutting concerns(primary logic + secondary logic) 
spring web mvc module - using this we can develop web based applications
spring orm module - using this also we can achieve persistence logic 
   with orm we do have more benefits 
spring testing module 


   
   hibernate 
   jdbc drawbacks
   hibernate,ibatis,eclipselink etc.. 
   orm framework and benefits of using this orm framework?
   
   
only mavenized projects 

 
spring ioc container 

  practically what it is you know?
  
    it is an interface
	  
           ->ApplicationContext 
		   
 Central interface to provide configuration for an application


interface 

  
  package com.techm;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
        
    	
    	
    	ApplicationContext context = new ClassPathXmlApplicationContext("applicationcontext.xml");
    	Student student = (Student)context.getBean("stu");
    	
    	student.display();
    	
    }
}


Student.java:
`````````````
package com.techm;

import java.io.Serializable;

public class Student implements Serializable{

	 private int stid;
	 private String stname;
	
	 
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	 
	public String toString()
	{
		return stid + " " + stname;
	}
	public Student() {
		super();
	}
	public Student(int stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	 
	//business logic
	public void display()
	{
		System.out.println("Student id: " + this.getStid());
		System.out.println("Student name:" + this.getStname());
	}
	 
}


applicationcontext.xml:
``````````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"
	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:jee="http://www.springframework.org/schema/jee" xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:task="http://www.springframework.org/schema/task"
	xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.2.xsd">

	
	<bean id="stu" class="com.techm.Student">
	     <!-- setter injection  -->
	    <property name="stid" value="100"/>
	    <property name="stname" value="rk"/>
	     
	    <!-- constructor injection -->
	    
	    <constructor-arg name="stid" value="200"></constructor-arg>
	    <constructor-arg name="stname" value="chanda"></constructor-arg>
	</bean>
	
	
</beans>

pom.xml:
``````````
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>6.1.2</version>
</dependency>


How to inject reference based objects :
`````````````````````````````````````````
package com.techm;

import java.io.Serializable;

public class Student implements Serializable {

	private int stid;
	private String stname;
	private Address address;

	public Student(int stid, String stname, Address address) {
		super();
		this.stid = stid;
		this.stname = stname;
		this.address = address;
	}

	public int getStid() {
		return stid;
	}

	public void setStid(int stid) {
		this.stid = stid;
	}

	public String getStname() {
		return stname;
	}

	public void setStname(String stname) {
		this.stname = stname;
	}

	public Address getAddress() {
		return address;
	}

	public void setAddress(Address address) {
		this.address = address;
	}

	public Student() {
		super();
	}

	// business logic
	public void display() {
		System.out.println("Student id: " + this.getStid());
		System.out.println("Student name:" + this.getStname());
		System.out.println("student city name is: " + this.getAddress().getCityName());
		System.out.println("student state name is: " + this.getAddress().getStateName());
	}

}


Address.java:
`````````````
package com.techm;

public class Address {

	private String cityName;
	private String stateName;
	public String getCityName() {
		return cityName;
	}
	public void setCityName(String cityName) {
		this.cityName = cityName;
	}
	public String getStateName() {
		return stateName;
	}
	public void setStateName(String stateName) {
		this.stateName = stateName;
	}
	public Address(String cityName, String stateName) {
		super();
		this.cityName = cityName;
		this.stateName = stateName;
	}
	@Override
	public String toString() {
		return "Address [cityName=" + cityName + ", stateName=" + stateName + "]";
	}
	public Address() {
		super();
	}
	
}

applicationcontext.xml:
````````````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"
	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:jee="http://www.springframework.org/schema/jee" xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:task="http://www.springframework.org/schema/task"
	xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.2.xsd">

	
	<bean id="stu" class="com.techm.Student">
	     <!-- setter injection  -->
	    <property name="stid" value="100"/>
	    <property name="stname" value="rk"/>
	    <property name="address" ref="add"/>
	  
	</bean>
	<bean id="add" class="com.techm.Address">
	
	   <!-- constructor injection -->
	   <constructor-arg name="cityName" value="Pune"/>
	   <constructor-arg name="stateName" value="MT"/>
	</bean>
	
	
</beans>


how to inject list collection type data:
````````````````````````````````````````
package com.techm;

import java.io.Serializable;
import java.util.List;

public class Student implements Serializable {

	private int stid;
	private String stname;
	private List<Address> address;

	
	public Student(int stid, String stname, List<Address> address) {
		super();
		this.stid = stid;
		this.stname = stname;
		this.address = address;
	}

	public int getStid() {
		return stid;
	}

	public void setStid(int stid) {
		this.stid = stid;
	}

	public String getStname() {
		return stname;
	}

	public void setStname(String stname) {
		this.stname = stname;
	}

	public List<Address> getAddress() {
		return address;
	}

	public void setAddress(List<Address> address) {
		this.address = address;
	}

	public Student() {
		super();
	}

	// business logic
	public void display() {
		System.out.println("Student id: " + this.getStid());
		System.out.println("Student name:" + this.getStname());
		System.out.println("student temporary address is: " + this.getAddress().get(0));
		System.out.println("student permanent address is: " + this.getAddress().get(1));
	}

}

Address.java:
`````````````
package com.techm;

public class Address {

	private String cityName;
	private String stateName;
	public String getCityName() {
		return cityName;
	}
	public void setCityName(String cityName) {
		this.cityName = cityName;
	}
	public String getStateName() {
		return stateName;
	}
	public void setStateName(String stateName) {
		this.stateName = stateName;
	}
	public Address(String cityName, String stateName) {
		super();
		this.cityName = cityName;
		this.stateName = stateName;
	}
	@Override
	public String toString() {
		return "Address [cityName=" + cityName + ", stateName=" + stateName + "]";
	}
	public Address() {
		super();
	}
	
}

applicationcontext.xml:
``````````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"
	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:jee="http://www.springframework.org/schema/jee" xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:task="http://www.springframework.org/schema/task"
	xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.2.xsd">

	
	<bean id="stu" class="com.techm.Student">
	     <!-- setter injection  -->
	    <property name="stid" value="100"/>
	    <property name="stname" value="rk"/>
	    <property name="address">
	       <list>
	          <ref bean="tempadd"/>
	          <ref bean="permadd"/>
	       </list>
	    
	    </property>
	  
	</bean>
	<bean id="tempadd" class="com.techm.Address">
	
	    <property name="cityName" value="PUNE"/>
	    <property name="stateName" value="MT"/>
	</bean>
	
	<bean id="permadd" class="com.techm.Address">
	
	    <property name="cityName" value="HYD"/>
	    <property name="stateName" value="TG"/>
	</bean>

</beans>


App.java
``````````
package com.techm;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
        
    	
    	
    	ApplicationContext context = new ClassPathXmlApplicationContext("applicationcontext.xml");
    	Student student = (Student)context.getBean("stu");
    	
    	student.display();
    	
    }
}

autowiring:
```````````````
package com.techm;

public class Student {
   
	private Address address;

	public Address getAddress() {
		return address;
	}

	public void setAddress(Address address) {
		this.address = address;
	}

	public Student(Address address) {
		super();
		this.address = address;
	}

	@Override
	public String toString() {
		return "Student [address=" + address + "]";
	}

	public Student() {
		super();
	}
	
}

applicationcontext.xml:
```````````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"
	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:jee="http://www.springframework.org/schema/jee" xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:task="http://www.springframework.org/schema/task"
	xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.2.xsd">
<bean id="stu" class="com.techm.Student" autowire="byName"/>
<bean id="address" class="com.techm.Address">
   <property name="cityName" value="PUNE"/>
   <property name="stateName" value="MT"/>
</bean>


</beans>
App.java:
````````````
package com.techm;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationcontext.xml");
        Student student = context.getBean(Student.class);
    	System.out.println("student city name is:" + student.getAddress().getCityName());
    	System.out.println("student state name is: " + student.getAddress().getStateName());
    	
    	
    }
}

when autowire attribute value is byType ioc container will not look for bean id
value and property name instead of that it will look for bean element class 
attribute value type and bean class property type if both are matched or compatible then automatically the bean object will be injected into another 
bean.
applicationcontext.xml:
````````````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"
	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:jee="http://www.springframework.org/schema/jee" xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:task="http://www.springframework.org/schema/task"
	xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.2.xsd">
<bean id="stu" class="com.techm.Student" autowire="byType"/>
<bean id="add" class="com.techm.Address">
   <property name="cityName" value="PUNE"/>
   <property name="stateName" value="MT"/>
</bean>


</beans>


note:
when we are using byName or byType internally which injection will be happend?
 answer: setter injection 
 
when we are using constructor as the value for autowire attribute of bean element then it internally invokes constructor of the bean that means constructor injection occurs.

 
annotation based wiring:
``````````````````````````
package com.techm;

import org.springframework.beans.factory.annotation.Autowired;

public class Student {
   
	@Autowired
	private Address address;

	public Address getAddress() {
		return address;
	}

	public void setAddress(Address address) {
		this.address = address;
	}

	public Student(Address address) {
		super();
		this.address = address;
	}

	@Override
	public String toString() {
		return "Student [address=" + address + "]";
	}

	public Student() {
		super();
	}
	
}

----------------
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"
	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:jee="http://www.springframework.org/schema/jee" xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:task="http://www.springframework.org/schema/task"
	xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.2.xsd">
<context:annotation-config/>
<bean id="stu" class="com.techm.Student"/>
<bean id="add" class="com.techm.Address">
   <property name="cityName" value="PUNE"/>
   <property name="stateName" value="MT"/>
</bean>


</beans>

note:
in case of annotation based wiring, internally ioc container consider by specifying autowire attribute as byType 
by default annotation based wiring is disabled, to make it enable we have to 
add one element in spring configuration file i.e <context:annotaion-config/>

autodiscovery:
````````````````
in case of autodiscovery we no need to define the bean element.


Student.java:
```````````````
package com.techm;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class Student {
   
	@Autowired
	private Address address;

	
	@Override
	public String toString() {
		return "Student [address=" + address + "]";
	}


	public Address getAddress() {
		return address;
	}


	public void setAddress(Address address) {
		this.address = address;
	}

	
}

Address.java:
``````````````
package com.techm;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class Address {
	@Value("PUNE")
	private String cityName;
	@Value("MT")
	private String stateName;
	public Address() {
		super();
		// TODO Auto-generated constructor stub
	}
	@Override
	public String toString() {
		return "Address [cityName=" + cityName + ", stateName=" + stateName + "]";
	}
	public Address(String cityName, String stateName) {
		super();
		this.cityName = cityName;
		this.stateName = stateName;
	}
	public String getCityName() {
		return cityName;
	}
	public void setCityName(String cityName) {
		this.cityName = cityName;
	}
	public String getStateName() {
		return stateName;
	}
	public void setStateName(String stateName) {
		this.stateName = stateName;
	}

}

applicationcontext.xml:
`````````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"
	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:jee="http://www.springframework.org/schema/jee" xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:task="http://www.springframework.org/schema/task"
	xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.2.xsd">
<context:component-scan base-package="com.techm"></context:component-scan>
</beans>

App.java:
````````````
package com.techm;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationcontext.xml");
        Student student = context.getBean(Student.class);
    	System.out.println("student city name is:" + student.getAddress().getCityName());
    	System.out.println("student state name is: " + student.getAddress().getStateName());
    	
    	
    }
}


explicit wiring (everything is required <bean> element <property>)
|
autowiring(<property> element is not required,autowire attribute is required)
|
annotation based wiring(autowire attribute is not required , but @Autowired annotationis required)
|
autodiscovery(nothing is required even bean element is also but we should use 
@Component annotation)


java based configuration:
````````````````````````````
App.java:
````````````
package com.techm;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

import com.techm.config.MyConfig;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
        ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class);
        Student student = context.getBean(Student.class);
    	System.out.println("student city name is:" + student.getAddress().getCityName());
    	System.out.println("student state name is: " + student.getAddress().getStateName());
    	
    	
    }
}

MyConfig.java:
````````````````
package com.techm.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

import com.techm.Address;

@Configuration
@ComponentScan(basePackages = "com.techm")
public class MyConfig {

	/*
	 * @Bean public Address getAddressBean() 
	 * {
	 *  return new Address(); 
	 * }
	 */

}

spring jdbc module:
````````````````````
spring jdbc module provides a way to work with relational database using jdbc 
in a simplified manner. 

pom.xml:
```````````
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>6.1.2</version>
</dependency>
<!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
    <version>6.1.2</version>
</dependency>
<!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.33</version>
</dependency>

UserDao.java:
``````````````
package com.techm.dao;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Repository;

//@Repository
public class UserDao {

	@Autowired
	private JdbcTemplate jdbcTemplate;
	
	
	public JdbcTemplate getJdbcTemplate() {
		return jdbcTemplate;
	}

	public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public void createUserTable()
	{
		jdbcTemplate.execute("create table if not exists user(id int primary key, name varchar(20))");
	}
	
	public void insertUser(int id, String name) {
		jdbcTemplate.update("insert into user(id,name) values(?,?)",id,name);
	}
	
	public String findUserNameById(int id)
	{
		
		return jdbcTemplate.queryForObject("SELECT name from user where id=?",String.class,id);
	}
}

applicationcontext.xml:
``````````````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:p="http://www.springframework.org/schema/p"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:jee="http://www.springframework.org/schema/jee"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:task="http://www.springframework.org/schema/task"
	xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.2.xsd">

	<bean id="dao" class="com.techm.dao.UserDao">

		<property name="jdbcTemplate" ref="template" />
	</bean>

	<bean id="template"
		class="org.springframework.jdbc.core.JdbcTemplate">

		<property name="dataSource" ref="ds" />

	</bean>


	<bean id="ds"
		class="org.springframework.jdbc.datasource.DriverManagerDataSource">

		<property name="driverClassName"
			value="com.mysql.cj.jdbc.Driver" />
		<property name="url"
			value="jdbc:mysql://localhost:3306/techm" />
		<property name="username" value="root" />
		<property name="password" value="root" />

	</bean>

</beans>

App.java:
````````````
package com.techm;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.techm.dao.UserDao;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
       ApplicationContext context = new ClassPathXmlApplicationContext("applicationcontext.xml");
       
       UserDao dao = (UserDao)context.getBean("dao");
       
       //dao.createUserTable();
       //dao.insertUser(3, "swaroop");
       
       String userName = dao.findUserNameById(1);
       System.out.println("User name: " + userName);
    }
}



 spring jdbc module with java based configuration:
 `````````````````````````````````````````````````````
 package com.techm;

import javax.sql.DataSource;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DriverManagerDataSource;

@Configuration
public class MyConfig {

	@Bean
	public DataSource getDataSource()
	{
		DriverManagerDataSource ds = new DriverManagerDataSource();
		ds.setDriverClassName("com.mysql.cj.jdbc.Driver");
		ds.setUrl("jdbc:mysql://localhost:3306/techm");
		ds.setUsername("root");
		ds.setPassword("root");
		return ds;
	}
	
	@Bean
	public JdbcTemplate getTemplate()
	{
		JdbcTemplate jdbcTemplate = new JdbcTemplate();
		jdbcTemplate.setDataSource(getDataSource());
		return jdbcTemplate;
	}
	
	@Bean
	public StudentDao getDao()
	{
		StudentDao dao = new StudentDao();
		dao.setJdbcTemplate(getTemplate());
		return dao;
	}
}


Student.java:
``````````````````
package com.techm;

public class Student {
	private int stid;
	private String stname;
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	public Student(int stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	@Override
	public String toString() {
		return "Student [stid=" + stid + ", stname=" + stname + "]";
	}
	public Student() {
		super();
		// TODO Auto-generated constructor stub
	}
	
	

}

StudentDao.java:
```````````````````
package com.techm;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

//@Repository
public class StudentDao {

	@Autowired
	 private JdbcTemplate jdbcTemplate;
	 
	 public JdbcTemplate getJdbcTemplate() {
		return jdbcTemplate;
	}

	public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public int saveStudent(Student student)
	 {
		 String sql = "insert into student values(?,?)";
		 return jdbcTemplate.update(sql, student.getStid(),student.getStname());
	 }
	
	public int updateStdent(Student student)
	{
		String sql = "update student set stname=? where stid=?";
		return jdbcTemplate.update(sql,student.getStname(),student.getStid());
	}
	 
	public int deleteStudent(Student student)
	{
		String sql = "delete from student where stid=?";
		return jdbcTemplate.update(sql,student.getStid());
	}
	public List<Student> getAllStudents(){
		String sql = "select * From student";
		return jdbcTemplate.query(sql, new StudentRowMapper());
	}
	 
}

App.java:
```````````
package com.techm;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
         ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class);
		StudentDao dao = context.getBean(StudentDao.class);
		Student student = new Student();
		student.setStid(200);
		student.setStname("rk");

		// int x = dao.saveStudent(student);
		 //int x = dao.updateStdent(student);
		 //int x = dao.deleteStudent(student);
		 //System.out.println(x + "row(s) deleted");

		  List<Student> list = dao.getAllStudents();
          for(Student s: list)
          {
        	  System.out.println(s.getStid() + " " + s.getStname());
          }
    }
}

StudentRowMapper.java:
```````````````````````
package com.techm;

import java.sql.ResultSet;
import java.sql.SQLException;

import org.springframework.jdbc.core.RowMapper;

public class StudentRowMapper implements RowMapper<Student> {

	public Student mapRow(ResultSet rs, int rowNum) throws SQLException {
		Student student = new Student();
		student.setStid(rs.getInt(1));
		student.setStname(rs.getString(2));
		return student;
	}

}

spring web mvc module:

WelcomeController.java:
package com.techm.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.servlet.ModelAndView;

@Controller
public class WelcomeController {

	@RequestMapping(method = RequestMethod.GET,value = "/welcome")
	public ModelAndView welcome()
	{
		ModelAndView mv = new ModelAndView();
		mv.setViewName("welcome");
		return mv;
	}
	
	
}

web.xml(under WEB-INF):
`````````````````````
<!DOCTYPE web-app PUBLIC
 "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
 "http://java.sun.com/dtd/web-app_2_3.dtd" >

<web-app>
  <display-name>Archetype Created Web Application</display-name>
  
  <servlet>
  <servlet-name>spring</servlet-name>
  <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
  </servlet>
  <servlet-mapping>
  <servlet-name>spring</servlet-name>
  <url-pattern>/</url-pattern>
  </servlet-mapping>
</web-app>

spring-servlet.xml(unser WEB-INF folder):
`````````````````````````````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:mvc="http://www.springframework.org/schema/mvc"
	xsi:schemaLocation="  
        http://www.springframework.org/schema/beans  
        http://www.springframework.org/schema/beans/spring-beans.xsd  
        http://www.springframework.org/schema/context  
        http://www.springframework.org/schema/context/spring-context.xsd  
        http://www.springframework.org/schema/mvc  
        http://www.springframework.org/schema/mvc/spring-mvc.xsd">

<context:component-scan base-package="com.techm"></context:component-scan>
<bean id="iv" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
   <property name="prefix" value="/WEB-INF/jsps/"/>
   <property name="suffix" value=".jsp"/>

</bean>

</beans>

welcome.jsp:
``````````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
<h2>welcome to spring mvc module</h2>
</body>
</html>


how can i add java object to the Model and make it displayed in jsp page:

Student.java:
```````````````
package com.techm.model;

public class Student {
	
	private int stid;
	private String stname;
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	public Student() {
		super();
		// TODO Auto-generated constructor stub
	}
	public Student(int stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	@Override
	public String toString() {
		return stid + " " + stname;
	}
	
	

}

WelcomeController.java:
```````````````````````
package com.techm.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.servlet.ModelAndView;

import com.techm.model.Student;

@Controller
public class WelcomeController {

	@RequestMapping(method = RequestMethod.GET,value = "/welcome")
	public ModelAndView welcome()
	{
		ModelAndView mv = new ModelAndView();
		//mv.addObject("name","rk");
		
		Student student = new Student();
		
		student.setStid(100);
		student.setStname("chanda");
		
		mv.addObject("swaroop", student);
		
		mv.setViewName("welcome");
		return mv;
	}
	
	
}

welcome.jsp:
```````````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"
    isELIgnored="false"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
<h2>welcome to spring mvc module</h2>

${swaroop}

</body>
</html>

how can i send the control from controller to view and viceversa.,

RegistrationController.java:
`````````````````````````````
package com.techm.controller;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.servlet.ModelAndView;

import com.techm.model.Student;

@Controller
public class RegistrationController {

	@RequestMapping(method = RequestMethod.GET,value="/showreg")
	public ModelAndView showReg()
	{
		ModelAndView mv = new ModelAndView();
		mv.setViewName("userreg");
		return mv;
	}
	@RequestMapping(method = RequestMethod.POST,value="/registration")
	public ModelAndView registration(HttpServletRequest request,HttpServletResponse response)
	{
		int stid = Integer.parseInt(request.getParameter("stid"));
		String stname= request.getParameter("stname");
		Student student = new Student();
		student.setStid(stid);
		student.setStname(stname);
		ModelAndView mv = new ModelAndView();
		mv.addObject("student",student);
		mv.setViewName("success");
		return mv;
		
		
	}
	
}

userreg.jsp:
``````````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Student Information</title>
</head>
<body>
<form action="registration" method="post">

Enter Student id: <input type="text" name="stid"/><br/>
Enter Student name:<input type="text" name="stname"/><br/>
<input type="submit" value="register"/>
</form>

</body>
</html>
success.jsp:
`````````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"
    isELIgnored="false"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
Student Recrods are : <br/>
${student}
</body>
</html>


pom.xml:
````````
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>5.3.18</version>
</dependency>

The @RequestParam is used to read the HTML form data provided by a user and bind it to the request parameter.

Using @RequestParam:
`````````````````````

@RequestMapping(method = RequestMethod.POST, value = "/registration")
	public ModelAndView registration(@RequestParam("stid") int stid, @RequestParam("stname") String stname) {
		Student student = new Student();
		student.setStid(stid);
		student.setStname(stname);
		ModelAndView mv = new ModelAndView();
		mv.addObject("student", student);
		mv.setViewName("success");
		return mv;
	}
	
using @ModelAttribute:
```````````````````````
@RequestMapping(method = RequestMethod.POST, value = "/registration")
	public ModelAndView registration(@ModelAttribute("student") Student student) 		
		ModelAndView mv = new ModelAndView();	
		mv.setViewName("success");
		return mv;
	}
	
orm:
````
  object releational mapping 
  
  object -> java object 
  realational -> database table
  
    relate java object -> database table 
	
insert into student values(?,?);

save the java object 
->automatically it gets saved as a row inside the database table. 

User.java:
````````````
package com.techm.entity;

import javax.persistence.Id;

@javax.persistence.Entity
public class User {
	
	@Id
	private Long id;
	
	private String username;

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}
	

}

App.java:
``````````
package com.techm;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.boot.Metadata;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistry;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;

import com.techm.entity.User;

/**
 * Hello world!
 *
 */
public class App {
	public static void main(String[] args) {

		StandardServiceRegistry ssr = 
				new StandardServiceRegistryBuilder().
				configure("hibernate.cfg.xml").
				build();
		Metadata meta = new MetadataSources(ssr).getMetadataBuilder().build();
		
        SessionFactory factory = meta.getSessionFactoryBuilder().build();
        
        Session session = factory.openSession();
        
        Transaction transaction = session.beginTransaction();
        
        User user = new User();
        user.setId(100L);
        user.setUsername("Rama");
        
        session.save(user);
        
        transaction.commit();
        System.out.println("successfully saved");
        factory.close();
        session.close();
        
	}
}

hibernate.cfg.xml(src/main/resources)
``````````````````````````````````````
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-configuration PUBLIC 
  "-//Hibernate/Hibernate Configuration DTD 3.0//EN" 
  "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>

<session-factory>
    <property name="connection.driver_class">com.mysql.cj.jdbc.Driver</property>
    <property name="connection.url">jdbc:mysql://localhost:3306/techm</property>
    <property name="dialect">org.hibernate.dialect.MySQL8Dialect</property>
    <property name="connection.username">root</property>
    <property name="connection.password">root</property>
    
    <property name="show_sql">true</property>
    <property name="format_sql">true</property>
    <property name="hbm2ddl.auto">update</property>
    <mapping class="com.techm.entity.User"/>
  </session-factory>

</hibernate-configuration>


pom.xml:
``````````
<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
			<version>5.5.7.Final</version>
		</dependency>

		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>8.0.33</version>
		</dependency>
		

JPA provides the @Embeddable annotation to declare that a class will be embedded by other entities. The JPA annotation @Embedded is used to embed a type into another entity.

Employee.java:
``````````````
package com.techm.entity;

import javax.persistence.Embedded;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

import org.hibernate.annotations.Generated;

@Entity
public class Employee {

	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	 private Integer empid; 
	 private String empname;
	 @Embedded
	 private Address empaddress;
	 
	 
	public Integer getEmpid() {
		return empid;
	}
	public void setEmpid(Integer empid) {
		this.empid = empid;
	}
	public String getEmpname() {
		return empname;
	}
	public void setEmpname(String empname) {
		this.empname = empname;
	}
	public Address getEmpaddress() {
		return empaddress;
	}
	public void setEmpaddress(Address empaddress) {
		this.empaddress = empaddress;
	}
	 
}

Address.java:
```````````````
package com.techm.entity;

import javax.persistence.Embeddable;

@Embeddable
public class Address {

	private String cityName;
	public String getCityName() {
		return cityName;
	}
	public void setCityName(String cityName) {
		this.cityName = cityName;
	}
	public String getStateName() {
		return stateName;
	}
	public void setStateName(String stateName) {
		this.stateName = stateName;
	}
	private String stateName;
	
}

hibernate.cfg.xml:
````````````````````
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-configuration PUBLIC 
  "-//Hibernate/Hibernate Configuration DTD 3.0//EN" 
  "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>

<session-factory>
    <property name="connection.driver_class">com.mysql.cj.jdbc.Driver</property>
    <property name="connection.url">jdbc:mysql://localhost:3306/techm</property>
    <property name="dialect">org.hibernate.dialect.MySQL8Dialect</property>
    <property name="connection.username">root</property>
    <property name="connection.password">root</property>
    
    <property name="show_sql">true</property>
    <property name="format_sql">true</property>
    <property name="hbm2ddl.auto">update</property>
    <mapping class="com.techm.entity.Employee"/>
  </session-factory>

</hibernate-configuration>
App.java:
``````````
package com.techm;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.boot.Metadata;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistry;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;

import com.techm.entity.Address;
import com.techm.entity.Employee;

/**
 * Hello world!
 *
 */
public class App 
{
	public static void main(String[] args) {
		
	
	StandardServiceRegistry ssr = 
			new StandardServiceRegistryBuilder().
			configure("hibernate.cfg.xml").
			build();
	Metadata meta = new MetadataSources(ssr).getMetadataBuilder().build();
	
    SessionFactory factory = meta.getSessionFactoryBuilder().build();
    
    Session session = factory.openSession();
    
    Transaction transaction = session.beginTransaction();
    
    Address address = new Address();
    address.setCityName("pune");
    address.setStateName("MT");
    Employee employee = new Employee();
    employee.setEmpname("rk");
    employee.setEmpaddress(address);
    
    session.save(employee);
    
    transaction.commit();
    System.out.println("successfully saved");
    factory.close();
    session.close();
	}
}


hibernate query language:

App.java:
`````````
List<Employee> list = session.createQuery("from Employee").getResultList();
   
     for(Employee e: list)
     {
    	 System.out.println(e.getEmpid() + " " + e.getEmpname() + " " + e.getEmpaddress().getCityName() + "  " +e.getEmpaddress().getStateName());
     }
	 



findbyid:
`````````
Employee employee = session.get(Employee.class, 2);
     System.out.println(employee.getEmpname());
	 
assignment:

hibernate inheritance mapping:


 table per hierarchy 
 table per sub class
 table per concrete class 

 
 
hibernate relations:
`````````````````````````
Student.java:
`````````````
package com.techm.entity;

import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToOne;

@Entity
public class Student {
	
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private Integer stid;
	private String stname;
	
	@OneToOne(cascade = CascadeType.ALL,targetEntity = Address.class)
	@JoinColumn(name = "add_id",referencedColumnName = "addid")
	private Address address;

	public Integer getStid() {
		return stid;
	}

	public void setStid(Integer stid) {
		this.stid = stid;
	}

	public String getStname() {
		return stname;
	}

	public void setStname(String stname) {
		this.stname = stname;
	}

	public Address getAddress() {
		return address;
	}

	public void setAddress(Address address) {
		this.address = address;
	}
	
	

}
Address.java:
``````````````
package com.techm.entity;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class Address {
@Id
@GeneratedValue(strategy = GenerationType.AUTO)
	private Integer addid;
	
private String place;

public Integer getAddid() {
	return addid;
}

public void setAddid(Integer addid) {
	this.addid = addid;
}

public String getPlace() {
	return place;
}

public void setPlace(String place) {
	this.place = place;
}

}

App.java:
`````````````
package com.techm;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.boot.Metadata;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistry;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;

import com.techm.entity.Address;

import com.techm.entity.Student;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
    	StandardServiceRegistry ssr = new StandardServiceRegistryBuilder().configure("hiberanate.cfg.xml").build();

		Metadata meta = new MetadataSources(ssr).getMetadataBuilder().build();

		SessionFactory factory = meta.getSessionFactoryBuilder().build();

		Session session = factory.openSession();
		
		Transaction t = session.beginTransaction();
		
		Address address = new Address();
		address.setPlace("hyd");
		Student student = new Student();
		student.setStname("rk");
		student.setAddress(address);
		
		session.save(student);
		t.commit();
		
		session.close();
		
		System.out.println("success");
		
    }
}

one to many:
````````````
package com.techm.entity;

import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;

@Entity
public class Student {
	
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private Integer stid;
	private String stname;
	
	@OneToMany(cascade = CascadeType.ALL)
	@JoinColumn(name = "st_id")
	private Set<Address> address;
	
	public Integer getStid() {
		return stid;
	}

	public void setStid(Integer stid) {
		this.stid = stid;
	}

	public String getStname() {
		return stname;
	}

	public void setStname(String stname) {
		this.stname = stname;
	}

	public Set<Address> getAddress() {
		return address;
	}

	public void setAddress(Set<Address> address) {
		this.address = address;
	}

	
	
	

}

Address.java:
````````````
package com.techm.entity;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class Address {
@Id
@GeneratedValue(strategy = GenerationType.AUTO)
private Integer addid;
	
private String place;

public Integer getAddid() {
	return addid;
}

public void setAddid(Integer addid) {
	this.addid = addid;
}

public String getPlace() {
	return place;
}

public void setPlace(String place) {
	this.place = place;
}

}

App.java:
``````````
package com.techm;

import java.util.HashSet;
import java.util.Set;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.boot.Metadata;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistry;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;

import com.techm.entity.Address;
import com.techm.entity.Student;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
    	StandardServiceRegistry ssr = new StandardServiceRegistryBuilder().configure("hiberanate.cfg.xml").build();

		Metadata meta = new MetadataSources(ssr).getMetadataBuilder().build();

		SessionFactory factory = meta.getSessionFactoryBuilder().build();

		Session session = factory.openSession();
		
		Transaction t = session.beginTransaction();
		
		Address address1 = new Address();
		address1.setPlace("hyd");
		
		Address address2 = new Address();
		address2.setPlace("bangalore");
		
		
		Student student = new Student();
		student.setStname("rk");
		
		Set<Address> addr = new HashSet<Address>();
		addr.add(address1);
		addr.add(address2);
		
		student.setAddress(addr);
		
		session.save(student);
		t.commit();
		
		session.close();
		
		System.out.println("succss");
		
    }
}


  ->many to one
  ->many to many 
  

App.java(understanding firstlevel cache):
```````````````````````````````````````````
package com.techm;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.boot.Metadata;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistry;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;

import com.techm.entity.User;

/**
 * Hello world!
 *
 */
public class App {
	public static void main(String[] args) {

		StandardServiceRegistry ssr = 
				new StandardServiceRegistryBuilder().
				configure("hibernate.cfg.xml").
				build();
		Metadata meta = new MetadataSources(ssr).getMetadataBuilder().build();
		
        SessionFactory factory = meta.getSessionFactoryBuilder().build();
        
        Session session = factory.openSession();
        Session session1  = factory.openSession();
        
        Transaction transaction = session.beginTransaction();
        
       /* User user = new User();
        user.setId(200L);
        user.setUsername("Chanda");
        
        session.save(user);*/
        
        User user = session.load(User.class, 100L);
        System.err.println(user.getId() + " " + user.getUsername());
        
        User user1 = session1.load(User.class, 100L);
        System.err.println(user1.getId() + " " + user1.getUsername());
        transaction.commit();
        //System.out.println("successfully saved");
        factory.close();
        session.close();
        
	}
}


spring orm module:
`````````````````
<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context</artifactId>
			<version>5.3.10</version>
		</dependency>


		<!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core -->
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
			<version>5.5.7.Final</version>
		</dependency>

		<!-- https://mvnrepository.com/artifact/org.springframework/spring-orm -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-orm</artifactId>
			<version>5.3.10</version>
		</dependency>
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>8.0.33</version>
		</dependency>
		


App.java:
````````
package com.techm;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.techm.dao.StudentDao;
import com.techm.entity.Student;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {

 	   ApplicationContext context = new ClassPathXmlApplicationContext("applicationcontext.xml");
 	   
 	   StudentDao dao = context.getBean(StudentDao.class);
 	   
 	   Student stu = new Student();
 	   stu.setFirstName("swetha");
 	   stu.setLastName("techm");
 	   int x = dao.saveStudent(stu);
 	   System.out.println(x + "row(s) inserted");
    }
}


StudentDao.java:
``````````````
package com.techm.dao;


import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.orm.hibernate5.HibernateTemplate;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import com.techm.entity.Student;

@Repository
public class StudentDao {

	@Autowired
	private HibernateTemplate template;

	public HibernateTemplate getTemplate() {
		return template;
	}

	public void setTemplate(HibernateTemplate template) {
		this.template = template;
	}
	
	@Transactional
	public int saveStudent(Student student)
	{
		
		Integer i = (Integer)template.save(student);
	    return i;
	}
	
}
Student.java:
``````````````
package com.techm.entity;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class Student {
	
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private int stid;
	private String firstName;
	private String lastName;
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getFirstName() {
		return firstName;
	}
	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}
	public String getLastName() {
		return lastName;
	}
	public void setLastName(String lastName) {
		this.lastName = lastName;
	}
	

}

applicationcontext.xml:
````````````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd  
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd">



	<tx:annotation-driven />
	<context:component-scan base-package="com.techm"></context:component-scan>

	<!-- <bean id="dao" class="com.techm.dao.StudentDao">

		<property name="template" ref="template" />

	</bean> -->

	<bean id="template"
		class="org.springframework.orm.hibernate5.HibernateTemplate">

		<property name="sessionFactory" ref="mySessionFactory" />
	</bean>

	<bean id="mySessionFactory"
		class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
		<property name="dataSource" ref="ds" />
		<property name="annotatedClasses">
			<list>
				<value>com.techm.entity.Student</value>
			</list>
		</property>
		<property name="hibernateProperties">

			<props>
				<prop key="hibernate.dialect">org.hibernate.dialect.MySQL8Dialect</prop>
				<prop key="hibernate.hbm2ddl.auto">update</prop>
				<prop key="hibernate.show_sql">true</prop>
				<prop key="hibernate.format_sql">true</prop>

			</props>

		</property>

	</bean>


	<bean id="ds"
		class="org.springframework.jdbc.datasource.DriverManagerDataSource">

		<property name="driverClassName"
			value="com.mysql.cj.jdbc.Driver" />
		<property name="url" value="jdbc:mysql://localhost:3306/techm" />
		<property name="username" value="root" />
		<property name="password" value="root" />

	</bean>


	<bean
		class="org.springframework.orm.hibernate5.HibernateTransactionManager"
		name="transactionManager">

		<property name="sessionFactory" ref="mySessionFactory" />

	</bean>




</beans>


springboot:


open source java based framework

  standalone apps
  production grade spring based apps
  
  
  embeded web server
  tomcat
  configuration management
  parent starter project (version issues)
  
  spring boot parent version 
    
	  what are the compatible dependecnies 
	  
StudentController.java:
``````````````````````
package com.techm.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.techm.entity.Student;
import com.techm.service.StudentService;

@RestController
@RequestMapping("/api/")
public class StudentController {
	@Autowired
	private StudentService service;
//@RequestMapping(method = RequestMethod.GET,value="/welcome")	
   @GetMapping("/welcome")
	public String display() {
	
	return "welcome to springboot";
}
  
 @PostMapping("/student")
 public Student saveStudent(@RequestBody Student student)
 {
	return service.saveStudent(student);
	
 }
 //update
 //delete
 //findbyid 
 //findallstudents 
 
 
 
   
	
}


Student.java:
``````````````
package com.techm.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;


@Entity
public class Student {

	@Id
	private Integer stid;
	private String stname;
	public Integer getStid() {
		return stid;
	}
	public void setStid(Integer stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	public Student() {
		super();
		// TODO Auto-generated constructor stub
	}
	public Student(Integer stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	
	
	
}


StudentService.java:
````````````````````
package com.techm.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.techm.entity.Student;
import com.techm.repository.StudentRepository;
@Service
public class StudentService {

	
	@Autowired
	private StudentRepository repository;
	
	public Student saveStudent(Student student)
	{
		return repository.save(student);
	}
}
'
StudentRepository.java:
`````````````````````````
package com.techm.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.techm.entity.Student;

@Repository
public interface StudentRepository extends JpaRepository<Student, Integer> {

}


application.properties:
`````````````````````````
spring.datasource.url=jdbc:mysql://localhost:3306/techm
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect


exception handling in springboot:
``````````````````````````````````
The methods within @RestControllerAdvice (marked with @ExceptionHandler ) are accessible globally to multiple @Controller components, and their purpose is to catch exceptions and transform them into HTTP responses. The @ExceptionHandler annotation specifies the type of Exception that should be managed.


package com.techm.exception;

import java.util.HashMap;
import java.util.Map;
import java.util.NoSuchElementException;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class ApplicationExceptionHandler {

	@ResponseStatus(HttpStatus.BAD_REQUEST)
	@ExceptionHandler(MethodArgumentNotValidException.class)
	public Map<String,String> handleInvalidArgument(MethodArgumentNotValidException ex)
	{
		Map<String,String> errorMap = new HashMap();
		
		ex.getBindingResult().getFieldErrors().forEach(error ->
				errorMap.put(error.getField(), error.getDefaultMessage())
				);
		return errorMap;
		
	}
	
	@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
	@ExceptionHandler(NoSuchElementException.class)
	public Map<String,String>  handleBusinessException(NoSuchElementException ex)
	{
		Map<String,String> errorMap = new HashMap();
		errorMap.put("errorMessage",ex.getMessage());
		return errorMap;
	}
	
}

UserNotFoundException.java:
`````````````````````````````
package com.techm.exception;

public class UserNotFoundException extends Exception{

	public UserNotFoundException(String message) {
		super(message);
		// TODO Auto-generated constructor stub
	}

	
	
}

User.java:
```````````
package com.techm.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import lombok.Data;

@Entity

public class User {
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private int userId;
	@NotNull(message = "username shouldn't be null")
	private String name;
	@Email(message="invalid email addres")
	private String email;
	@Pattern(regexp = "^\\d{10}$",message = "invalid mobile number entered")
	private String mobile;
	
	private String gender;
	@Min(18)
	@Max(60)
	private int age;
	
	@NotBlank
	private String nationality;

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}

	public String getMobile() {
		return mobile;
	}

	public void setMobile(String mobile) {
		this.mobile = mobile;
	}

	public String getGender() {
		return gender;
	}

	public void setGender(String gender) {
		this.gender = gender;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public String getNationality() {
		return nationality;
	}

	public void setNationality(String nationality) {
		this.nationality = nationality;
	}
	

}

UserController.java:
```````````````````
package com.techm.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.techm.entity.User;
import com.techm.exception.UserNotFoundException;
import com.techm.service.UserService;

import jakarta.validation.Valid;

@RestController
@RequestMapping("/users")
public class UserController {

	@Autowired
	private UserService service;
	
	@PostMapping("/signup")
	public ResponseEntity<User> saveUser(@RequestBody @Valid User user)
	{
		return new ResponseEntity<User>(service.saveUser(user), HttpStatus.CREATED);
		
	}
	
	@GetMapping("/{id}")
	public ResponseEntity<User> getUser(@PathVariable int id) throws UserNotFoundException
	{
		return ResponseEntity.ok(service.getUser(id));
	}
	
	
	//MethodArgumentNotValidException
}

UserRepository.java:
```````````````````````
package com.techm.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.techm.entity.User;

@Repository
public interface UserRepository extends JpaRepository<User, Integer> {

}

UserService.java:
`````````````````
package com.techm.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.techm.entity.User;
import com.techm.exception.UserNotFoundException;
import com.techm.repository.UserRepository;

@Service
public class UserService {

	@Autowired
	private UserRepository repository;
	
	
	public User saveUser(User user)
	{
		return repository.save(user);
	}
	
	public User getUser(int id) throws UserNotFoundException
	{
		User user = repository.findById(id).get();
	   if(user!=null) {
		   return user;
	   }
	   else
	   {
		   System.out.println("call came");
		   throw new UserNotFoundException("user not found with id: " + id);
	   }
	}
}


application.yaml:
`````````````````````
server:
    port: 9090
spring:
    datasource:
        password: root
        url: jdbc:mysql://localhost:3306/techm
        username: root
    jpa:
        hibernate:
            ddl-auto: update
        properties:
            hibernate:
                format_sql: true
        show-sql: true
		


boot class:
````````````
package com.techm;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SpringbootValidationsApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringbootValidationsApplication.class, args);
	}

}


query generation from method names:
spring data jpa query methods are the most powerful methods, we can create query methods to select records from the database  without writing sql queries. Behind the scenes, spring data jpa will create sql queries based on the query method and execute the query for us.

                           findByName(String name)
						   
select id,name,description,active,image_url,price,sku from products where name='productname'

we can create query methods fro repository using entity fileds. 
creating query methods is also called finder methods(findBy,findAll...)

						   
package com.techm.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.techm.entity.User;

@Repository
public interface UserRepository extends JpaRepository<User, Integer> {

	User findFirstByName(String name);
	User findByEmail(String email);
	User findByNameAndEmail(String name,String email);
	User findByNameOrEmail(String name,String email);

}

	
Entity to dto 
and dto to entitiy conversion 
inmemory database(h2)
swagger api

<dependency>
			<groupId>org.springdoc</groupId>
 		<artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
			<version>2.0.2</version>
		</dependency> 

http://localhost:9090/swagger-ui/index.html
	
	Swagger in Spring Boot is an open-source project that helps generate documents of REST APIs for RESTful web services via a web browser. It renders the documentation of an API visually using web services. Open API is the specification, and Swagger is a tool that helps implement the API specification
	
	
	
	microservices
	docker
	jenkins
	mockito
	jpql
	
	